// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Gets all artists from a given item, folder, or the entire library.
    ///
    /// - Remark: HTTP `GET /Artists`.
    /// - Remark: Generated from `#/paths//Artists/get(GetArtists)`.
    public func GetArtists(_ input: Operations.GetArtists.Input) async throws -> Operations.GetArtists.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetArtists.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Artists",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "minCommunityRating",
                    value: input.query.minCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "startIndex",
                    value: input.query.startIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "searchTerm",
                    value: input.query.searchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "parentId",
                    value: input.query.parentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "fields",
                    value: input.query.fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "excludeItemTypes",
                    value: input.query.excludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "includeItemTypes",
                    value: input.query.includeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "filters",
                    value: input.query.filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "isFavorite",
                    value: input.query.isFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "mediaTypes",
                    value: input.query.mediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "genres",
                    value: input.query.genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "genreIds",
                    value: input.query.genreIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "officialRatings",
                    value: input.query.officialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tags",
                    value: input.query.tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "years",
                    value: input.query.years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enableUserData",
                    value: input.query.enableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "imageTypeLimit",
                    value: input.query.imageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enableImageTypes",
                    value: input.query.enableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "person",
                    value: input.query.person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "personIds",
                    value: input.query.personIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "personTypes",
                    value: input.query.personTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "studios",
                    value: input.query.studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "studioIds",
                    value: input.query.studioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "userId",
                    value: input.query.userId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nameStartsWithOrGreater",
                    value: input.query.nameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nameStartsWith",
                    value: input.query.nameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nameLessThan",
                    value: input.query.nameLessThan
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sortBy",
                    value: input.query.sortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sortOrder",
                    value: input.query.sortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enableImages",
                    value: input.query.enableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enableTotalRecordCount",
                    value: input.query.enableTotalRecordCount
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetArtists.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/json",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDtoQueryResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDtoQueryResult.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_camelcase_quot_(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDtoQueryResult.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_pascalcase_quot_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an artist by name.
    ///
    /// - Remark: HTTP `GET /Artists/{name}`.
    /// - Remark: Generated from `#/paths//Artists/{name}/get(GetArtistByName)`.
    public func GetArtistByName(_ input: Operations.GetArtistByName.Input) async throws -> Operations.GetArtistByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetArtistByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Artists/{}",
                    parameters: [
                        input.path.name
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "userId",
                    value: input.query.userId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetArtistByName.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/json",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_camelcase_quot_(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDto.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_pascalcase_quot_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// - Remark: HTTP `GET /Items`.
    /// - Remark: Generated from `#/paths//Items/get(GetItems)`.
    public func GetItems(_ input: Operations.GetItems.Input) async throws -> Operations.GetItems.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetItems.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Items",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "userId",
                    value: input.query.userId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "maxOfficialRating",
                    value: input.query.maxOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hasThemeSong",
                    value: input.query.hasThemeSong
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hasThemeVideo",
                    value: input.query.hasThemeVideo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hasSubtitles",
                    value: input.query.hasSubtitles
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hasSpecialFeature",
                    value: input.query.hasSpecialFeature
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hasTrailer",
                    value: input.query.hasTrailer
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "adjacentTo",
                    value: input.query.adjacentTo
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "indexNumber",
                    value: input.query.indexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "parentIndexNumber",
                    value: input.query.parentIndexNumber
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hasParentalRating",
                    value: input.query.hasParentalRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "isHd",
                    value: input.query.isHd
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "is4K",
                    value: input.query.is4K
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "locationTypes",
                    value: input.query.locationTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "excludeLocationTypes",
                    value: input.query.excludeLocationTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "isMissing",
                    value: input.query.isMissing
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "isUnaired",
                    value: input.query.isUnaired
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "minCommunityRating",
                    value: input.query.minCommunityRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "minCriticRating",
                    value: input.query.minCriticRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "minPremiereDate",
                    value: input.query.minPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "minDateLastSaved",
                    value: input.query.minDateLastSaved
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "minDateLastSavedForUser",
                    value: input.query.minDateLastSavedForUser
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "maxPremiereDate",
                    value: input.query.maxPremiereDate
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hasOverview",
                    value: input.query.hasOverview
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hasImdbId",
                    value: input.query.hasImdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hasTmdbId",
                    value: input.query.hasTmdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hasTvdbId",
                    value: input.query.hasTvdbId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "isMovie",
                    value: input.query.isMovie
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "isSeries",
                    value: input.query.isSeries
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "isNews",
                    value: input.query.isNews
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "isKids",
                    value: input.query.isKids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "isSports",
                    value: input.query.isSports
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "excludeItemIds",
                    value: input.query.excludeItemIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "startIndex",
                    value: input.query.startIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "recursive",
                    value: input.query.recursive
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "searchTerm",
                    value: input.query.searchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sortOrder",
                    value: input.query.sortOrder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "parentId",
                    value: input.query.parentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "fields",
                    value: input.query.fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "excludeItemTypes",
                    value: input.query.excludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "includeItemTypes",
                    value: input.query.includeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "filters",
                    value: input.query.filters
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "isFavorite",
                    value: input.query.isFavorite
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "mediaTypes",
                    value: input.query.mediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "imageTypes",
                    value: input.query.imageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sortBy",
                    value: input.query.sortBy
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "isPlayed",
                    value: input.query.isPlayed
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "genres",
                    value: input.query.genres
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "officialRatings",
                    value: input.query.officialRatings
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tags",
                    value: input.query.tags
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "years",
                    value: input.query.years
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enableUserData",
                    value: input.query.enableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "imageTypeLimit",
                    value: input.query.imageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enableImageTypes",
                    value: input.query.enableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "person",
                    value: input.query.person
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "personIds",
                    value: input.query.personIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "personTypes",
                    value: input.query.personTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "studios",
                    value: input.query.studios
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "artists",
                    value: input.query.artists
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "excludeArtistIds",
                    value: input.query.excludeArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "artistIds",
                    value: input.query.artistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "albumArtistIds",
                    value: input.query.albumArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "contributingArtistIds",
                    value: input.query.contributingArtistIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "albums",
                    value: input.query.albums
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "albumIds",
                    value: input.query.albumIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ids",
                    value: input.query.ids
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "videoTypes",
                    value: input.query.videoTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "minOfficialRating",
                    value: input.query.minOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "isLocked",
                    value: input.query.isLocked
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "isPlaceHolder",
                    value: input.query.isPlaceHolder
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hasOfficialRating",
                    value: input.query.hasOfficialRating
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "collapseBoxSetItems",
                    value: input.query.collapseBoxSetItems
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "minWidth",
                    value: input.query.minWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "minHeight",
                    value: input.query.minHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "maxWidth",
                    value: input.query.maxWidth
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "maxHeight",
                    value: input.query.maxHeight
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "is3D",
                    value: input.query.is3D
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "seriesStatus",
                    value: input.query.seriesStatus
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nameStartsWithOrGreater",
                    value: input.query.nameStartsWithOrGreater
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nameStartsWith",
                    value: input.query.nameStartsWith
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "nameLessThan",
                    value: input.query.nameLessThan
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "studioIds",
                    value: input.query.studioIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "genreIds",
                    value: input.query.genreIds
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enableTotalRecordCount",
                    value: input.query.enableTotalRecordCount
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enableImages",
                    value: input.query.enableImages
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetItems.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/json",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDtoQueryResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDtoQueryResult.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_camelcase_quot_(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDtoQueryResult.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_pascalcase_quot_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Item User Data.
    ///
    /// - Remark: HTTP `GET /UserItems/{itemId}/UserData`.
    /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/get(GetItemUserData)`.
    public func GetItemUserData(_ input: Operations.GetItemUserData.Input) async throws -> Operations.GetItemUserData.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetItemUserData.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/UserItems/{}/UserData",
                    parameters: [
                        input.path.itemId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "userId",
                    value: input.query.userId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetItemUserData.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/json",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_camelcase_quot_(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_pascalcase_quot_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetItemUserData.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/json",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ProblemDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ProblemDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_camelcase_quot_(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ProblemDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_pascalcase_quot_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Item User Data.
    ///
    /// - Remark: HTTP `POST /UserItems/{itemId}/UserData`.
    /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/post(UpdateItemUserData)`.
    public func UpdateItemUserData(_ input: Operations.UpdateItemUserData.Input) async throws -> Operations.UpdateItemUserData.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UpdateItemUserData.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/UserItems/{}/UserData",
                    parameters: [
                        input.path.itemId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "userId",
                    value: input.query.userId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .text_json(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/json"
                    )
                case let .application__ast__plus_json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/*+json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UpdateItemUserData.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/json",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_camelcase_quot_(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_pascalcase_quot_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UpdateItemUserData.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/json",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ProblemDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ProblemDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_camelcase_quot_(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ProblemDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_pascalcase_quot_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets items based on a query.
    ///
    /// - Remark: HTTP `GET /UserItems/Resume`.
    /// - Remark: Generated from `#/paths//UserItems/Resume/get(GetResumeItems)`.
    public func GetResumeItems(_ input: Operations.GetResumeItems.Input) async throws -> Operations.GetResumeItems.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetResumeItems.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/UserItems/Resume",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "userId",
                    value: input.query.userId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "startIndex",
                    value: input.query.startIndex
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "searchTerm",
                    value: input.query.searchTerm
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "parentId",
                    value: input.query.parentId
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "fields",
                    value: input.query.fields
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "mediaTypes",
                    value: input.query.mediaTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enableUserData",
                    value: input.query.enableUserData
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "imageTypeLimit",
                    value: input.query.imageTypeLimit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enableImageTypes",
                    value: input.query.enableImageTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "excludeItemTypes",
                    value: input.query.excludeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "includeItemTypes",
                    value: input.query.includeItemTypes
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enableTotalRecordCount",
                    value: input.query.enableTotalRecordCount
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enableImages",
                    value: input.query.enableImages
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "excludeActiveSessions",
                    value: input.query.excludeActiveSessions
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetResumeItems.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/json",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDtoQueryResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDtoQueryResult.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_camelcase_quot_(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDtoQueryResult.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_pascalcase_quot_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets all user media folders.
    ///
    /// - Remark: HTTP `GET /Library/MediaFolders`.
    /// - Remark: Generated from `#/paths//Library/MediaFolders/get(GetMediaFolders)`.
    public func GetMediaFolders(_ input: Operations.GetMediaFolders.Input) async throws -> Operations.GetMediaFolders.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetMediaFolders.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Library/MediaFolders",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "isHidden",
                    value: input.query.isHidden
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetMediaFolders.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/json",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDtoQueryResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDtoQueryResult.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_camelcase_quot_(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BaseItemDtoQueryResult.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_pascalcase_quot_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets an item's lyrics.
    ///
    /// - Remark: HTTP `GET /Audio/{itemId}/Lyrics`.
    /// - Remark: Generated from `#/paths//Audio/{itemId}/Lyrics/get(GetLyrics)`.
    public func GetLyrics(_ input: Operations.GetLyrics.Input) async throws -> Operations.GetLyrics.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetLyrics.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Audio/{}/Lyrics",
                    parameters: [
                        input.path.itemId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLyrics.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/json",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LyricDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LyricDto.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_camelcase_quot_(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.LyricDto.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_pascalcase_quot_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetLyrics.Output.NotFound.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/json",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ProblemDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ProblemDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_camelcase_quot_(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ProblemDetails.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_pascalcase_quot_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .notFound(.init(body: body))
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Gets public information about the server.
    ///
    /// - Remark: HTTP `GET /System/Info/Public`.
    /// - Remark: Generated from `#/paths//System/Info/Public/get(GetPublicSystemInfo)`.
    public func GetPublicSystemInfo(_ input: Operations.GetPublicSystemInfo.Input) async throws -> Operations.GetPublicSystemInfo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.GetPublicSystemInfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/System/Info/Public",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.GetPublicSystemInfo.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/json",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PublicSystemInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PublicSystemInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_camelcase_quot_(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PublicSystemInfo.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_pascalcase_quot_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Authenticates a user by name.
    ///
    /// - Remark: HTTP `POST /Users/AuthenticateByName`.
    /// - Remark: Generated from `#/paths//Users/AuthenticateByName/post(AuthenticateUserByName)`.
    public func AuthenticateUserByName(_ input: Operations.AuthenticateUserByName.Input) async throws -> Operations.AuthenticateUserByName.Output {
        try await client.send(
            input: input,
            forOperation: Operations.AuthenticateUserByName.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/Users/AuthenticateByName",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                case let .text_json(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "text/json"
                    )
                case let .application__ast__plus_json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/*+json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.AuthenticateUserByName.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/json",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AuthenticationResult.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AuthenticationResult.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_camelcase_quot_(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AuthenticationResult.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_pascalcase_quot_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Marks an item as a favorite.
    ///
    /// - Remark: HTTP `POST /UserFavoriteItems/{itemId}`.
    /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/post(MarkFavoriteItem)`.
    public func MarkFavoriteItem(_ input: Operations.MarkFavoriteItem.Input) async throws -> Operations.MarkFavoriteItem.Output {
        try await client.send(
            input: input,
            forOperation: Operations.MarkFavoriteItem.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/UserFavoriteItems/{}",
                    parameters: [
                        input.path.itemId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "userId",
                    value: input.query.userId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.MarkFavoriteItem.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/json",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_camelcase_quot_(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_pascalcase_quot_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Unmarks item as a favorite.
    ///
    /// - Remark: HTTP `DELETE /UserFavoriteItems/{itemId}`.
    /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/delete(UnmarkFavoriteItem)`.
    public func UnmarkFavoriteItem(_ input: Operations.UnmarkFavoriteItem.Input) async throws -> Operations.UnmarkFavoriteItem.Output {
        try await client.send(
            input: input,
            forOperation: Operations.UnmarkFavoriteItem.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/UserFavoriteItems/{}",
                    parameters: [
                        input.path.itemId
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "userId",
                    value: input.query.userId
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.UnmarkFavoriteItem.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/json",
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_camelcase_quot_(value)
                            }
                        )
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserItemDataDto.self,
                            from: responseBody,
                            transforming: { value in
                                .application_json_profile__quot_pascalcase_quot_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 401:
                    return .unauthorized(.init())
                case 403:
                    return .forbidden(.init())
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}

// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
/// A type that performs HTTP operations defined by the OpenAPI document.
public protocol APIProtocol: Sendable {
    /// Gets all artists from a given item, folder, or the entire library.
    ///
    /// - Remark: HTTP `GET /Artists`.
    /// - Remark: Generated from `#/paths//Artists/get(GetArtists)`.
    func GetArtists(_ input: Operations.GetArtists.Input) async throws -> Operations.GetArtists.Output
    /// Gets an artist by name.
    ///
    /// - Remark: HTTP `GET /Artists/{name}`.
    /// - Remark: Generated from `#/paths//Artists/{name}/get(GetArtistByName)`.
    func GetArtistByName(_ input: Operations.GetArtistByName.Input) async throws -> Operations.GetArtistByName.Output
    /// Gets items based on a query.
    ///
    /// - Remark: HTTP `GET /Items`.
    /// - Remark: Generated from `#/paths//Items/get(GetItems)`.
    func GetItems(_ input: Operations.GetItems.Input) async throws -> Operations.GetItems.Output
    /// Get Item User Data.
    ///
    /// - Remark: HTTP `GET /UserItems/{itemId}/UserData`.
    /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/get(GetItemUserData)`.
    func GetItemUserData(_ input: Operations.GetItemUserData.Input) async throws -> Operations.GetItemUserData.Output
    /// Update Item User Data.
    ///
    /// - Remark: HTTP `POST /UserItems/{itemId}/UserData`.
    /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/post(UpdateItemUserData)`.
    func UpdateItemUserData(_ input: Operations.UpdateItemUserData.Input) async throws -> Operations.UpdateItemUserData.Output
    /// Gets items based on a query.
    ///
    /// - Remark: HTTP `GET /UserItems/Resume`.
    /// - Remark: Generated from `#/paths//UserItems/Resume/get(GetResumeItems)`.
    func GetResumeItems(_ input: Operations.GetResumeItems.Input) async throws -> Operations.GetResumeItems.Output
    /// Gets all user media folders.
    ///
    /// - Remark: HTTP `GET /Library/MediaFolders`.
    /// - Remark: Generated from `#/paths//Library/MediaFolders/get(GetMediaFolders)`.
    func GetMediaFolders(_ input: Operations.GetMediaFolders.Input) async throws -> Operations.GetMediaFolders.Output
    /// Gets public information about the server.
    ///
    /// - Remark: HTTP `GET /System/Info/Public`.
    /// - Remark: Generated from `#/paths//System/Info/Public/get(GetPublicSystemInfo)`.
    func GetPublicSystemInfo(_ input: Operations.GetPublicSystemInfo.Input) async throws -> Operations.GetPublicSystemInfo.Output
    /// Authenticates a user by name.
    ///
    /// - Remark: HTTP `POST /Users/AuthenticateByName`.
    /// - Remark: Generated from `#/paths//Users/AuthenticateByName/post(AuthenticateUserByName)`.
    func AuthenticateUserByName(_ input: Operations.AuthenticateUserByName.Input) async throws -> Operations.AuthenticateUserByName.Output
    /// Marks an item as a favorite.
    ///
    /// - Remark: HTTP `POST /UserFavoriteItems/{itemId}`.
    /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/post(MarkFavoriteItem)`.
    func MarkFavoriteItem(_ input: Operations.MarkFavoriteItem.Input) async throws -> Operations.MarkFavoriteItem.Output
    /// Unmarks item as a favorite.
    ///
    /// - Remark: HTTP `DELETE /UserFavoriteItems/{itemId}`.
    /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/delete(UnmarkFavoriteItem)`.
    func UnmarkFavoriteItem(_ input: Operations.UnmarkFavoriteItem.Input) async throws -> Operations.UnmarkFavoriteItem.Output
}

/// Convenience overloads for operation inputs.
extension APIProtocol {
    /// Gets all artists from a given item, folder, or the entire library.
    ///
    /// - Remark: HTTP `GET /Artists`.
    /// - Remark: Generated from `#/paths//Artists/get(GetArtists)`.
    public func GetArtists(
        query: Operations.GetArtists.Input.Query = .init(),
        headers: Operations.GetArtists.Input.Headers = .init()
    ) async throws -> Operations.GetArtists.Output {
        try await GetArtists(Operations.GetArtists.Input(
            query: query,
            headers: headers
        ))
    }
    /// Gets an artist by name.
    ///
    /// - Remark: HTTP `GET /Artists/{name}`.
    /// - Remark: Generated from `#/paths//Artists/{name}/get(GetArtistByName)`.
    public func GetArtistByName(
        path: Operations.GetArtistByName.Input.Path,
        query: Operations.GetArtistByName.Input.Query = .init(),
        headers: Operations.GetArtistByName.Input.Headers = .init()
    ) async throws -> Operations.GetArtistByName.Output {
        try await GetArtistByName(Operations.GetArtistByName.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Gets items based on a query.
    ///
    /// - Remark: HTTP `GET /Items`.
    /// - Remark: Generated from `#/paths//Items/get(GetItems)`.
    public func GetItems(
        query: Operations.GetItems.Input.Query = .init(),
        headers: Operations.GetItems.Input.Headers = .init()
    ) async throws -> Operations.GetItems.Output {
        try await GetItems(Operations.GetItems.Input(
            query: query,
            headers: headers
        ))
    }
    /// Get Item User Data.
    ///
    /// - Remark: HTTP `GET /UserItems/{itemId}/UserData`.
    /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/get(GetItemUserData)`.
    public func GetItemUserData(
        path: Operations.GetItemUserData.Input.Path,
        query: Operations.GetItemUserData.Input.Query = .init(),
        headers: Operations.GetItemUserData.Input.Headers = .init()
    ) async throws -> Operations.GetItemUserData.Output {
        try await GetItemUserData(Operations.GetItemUserData.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Update Item User Data.
    ///
    /// - Remark: HTTP `POST /UserItems/{itemId}/UserData`.
    /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/post(UpdateItemUserData)`.
    public func UpdateItemUserData(
        path: Operations.UpdateItemUserData.Input.Path,
        query: Operations.UpdateItemUserData.Input.Query = .init(),
        headers: Operations.UpdateItemUserData.Input.Headers = .init(),
        body: Operations.UpdateItemUserData.Input.Body
    ) async throws -> Operations.UpdateItemUserData.Output {
        try await UpdateItemUserData(Operations.UpdateItemUserData.Input(
            path: path,
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Gets items based on a query.
    ///
    /// - Remark: HTTP `GET /UserItems/Resume`.
    /// - Remark: Generated from `#/paths//UserItems/Resume/get(GetResumeItems)`.
    public func GetResumeItems(
        query: Operations.GetResumeItems.Input.Query = .init(),
        headers: Operations.GetResumeItems.Input.Headers = .init()
    ) async throws -> Operations.GetResumeItems.Output {
        try await GetResumeItems(Operations.GetResumeItems.Input(
            query: query,
            headers: headers
        ))
    }
    /// Gets all user media folders.
    ///
    /// - Remark: HTTP `GET /Library/MediaFolders`.
    /// - Remark: Generated from `#/paths//Library/MediaFolders/get(GetMediaFolders)`.
    public func GetMediaFolders(
        query: Operations.GetMediaFolders.Input.Query = .init(),
        headers: Operations.GetMediaFolders.Input.Headers = .init()
    ) async throws -> Operations.GetMediaFolders.Output {
        try await GetMediaFolders(Operations.GetMediaFolders.Input(
            query: query,
            headers: headers
        ))
    }
    /// Gets public information about the server.
    ///
    /// - Remark: HTTP `GET /System/Info/Public`.
    /// - Remark: Generated from `#/paths//System/Info/Public/get(GetPublicSystemInfo)`.
    public func GetPublicSystemInfo(headers: Operations.GetPublicSystemInfo.Input.Headers = .init()) async throws -> Operations.GetPublicSystemInfo.Output {
        try await GetPublicSystemInfo(Operations.GetPublicSystemInfo.Input(headers: headers))
    }
    /// Authenticates a user by name.
    ///
    /// - Remark: HTTP `POST /Users/AuthenticateByName`.
    /// - Remark: Generated from `#/paths//Users/AuthenticateByName/post(AuthenticateUserByName)`.
    public func AuthenticateUserByName(
        headers: Operations.AuthenticateUserByName.Input.Headers = .init(),
        body: Operations.AuthenticateUserByName.Input.Body
    ) async throws -> Operations.AuthenticateUserByName.Output {
        try await AuthenticateUserByName(Operations.AuthenticateUserByName.Input(
            headers: headers,
            body: body
        ))
    }
    /// Marks an item as a favorite.
    ///
    /// - Remark: HTTP `POST /UserFavoriteItems/{itemId}`.
    /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/post(MarkFavoriteItem)`.
    public func MarkFavoriteItem(
        path: Operations.MarkFavoriteItem.Input.Path,
        query: Operations.MarkFavoriteItem.Input.Query = .init(),
        headers: Operations.MarkFavoriteItem.Input.Headers = .init()
    ) async throws -> Operations.MarkFavoriteItem.Output {
        try await MarkFavoriteItem(Operations.MarkFavoriteItem.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Unmarks item as a favorite.
    ///
    /// - Remark: HTTP `DELETE /UserFavoriteItems/{itemId}`.
    /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/delete(UnmarkFavoriteItem)`.
    public func UnmarkFavoriteItem(
        path: Operations.UnmarkFavoriteItem.Input.Path,
        query: Operations.UnmarkFavoriteItem.Input.Query = .init(),
        headers: Operations.UnmarkFavoriteItem.Input.Headers = .init()
    ) async throws -> Operations.UnmarkFavoriteItem.Output {
        try await UnmarkFavoriteItem(Operations.UnmarkFavoriteItem.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
}

/// Server URLs defined in the OpenAPI document.
public enum Servers {
    public enum Server1 {
        public static func url() throws -> Foundation.URL {
            try Foundation.URL(
                validatingOpenAPIServerURL: "http://localhost",
                variables: []
            )
        }
    }
    @available(*, deprecated, renamed: "Servers.Server1.url")
    public static func server1() throws -> Foundation.URL {
        try Foundation.URL(
            validatingOpenAPIServerURL: "http://localhost",
            variables: []
        )
    }
}

/// Types generated from the components section of the OpenAPI document.
public enum Components {
    /// Types generated from the `#/components/schemas` section of the OpenAPI document.
    public enum Schemas {
        /// An entity representing a user's access schedule.
        ///
        /// - Remark: Generated from `#/components/schemas/AccessSchedule`.
        public struct AccessSchedule: Codable, Hashable, Sendable {
            /// Gets the id of this instance.
            ///
            /// - Remark: Generated from `#/components/schemas/AccessSchedule/Id`.
            public var Id: Swift.Int32?
            /// Gets the id of the associated user.
            ///
            /// - Remark: Generated from `#/components/schemas/AccessSchedule/UserId`.
            public var UserId: Swift.String?
            /// Gets or sets the day of week.
            ///
            /// - Remark: Generated from `#/components/schemas/AccessSchedule/DayOfWeek`.
            public struct DayOfWeekPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/AccessSchedule/DayOfWeek/value1`.
                public var value1: Components.Schemas.DynamicDayOfWeek
                /// Creates a new `DayOfWeekPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.DynamicDayOfWeek) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the day of week.
            ///
            /// - Remark: Generated from `#/components/schemas/AccessSchedule/DayOfWeek`.
            public var DayOfWeek: Components.Schemas.AccessSchedule.DayOfWeekPayload?
            /// Gets or sets the start hour.
            ///
            /// - Remark: Generated from `#/components/schemas/AccessSchedule/StartHour`.
            public var StartHour: Swift.Double?
            /// Gets or sets the end hour.
            ///
            /// - Remark: Generated from `#/components/schemas/AccessSchedule/EndHour`.
            public var EndHour: Swift.Double?
            /// Creates a new `AccessSchedule`.
            ///
            /// - Parameters:
            ///   - Id: Gets the id of this instance.
            ///   - UserId: Gets the id of the associated user.
            ///   - DayOfWeek: Gets or sets the day of week.
            ///   - StartHour: Gets or sets the start hour.
            ///   - EndHour: Gets or sets the end hour.
            public init(
                Id: Swift.Int32? = nil,
                UserId: Swift.String? = nil,
                DayOfWeek: Components.Schemas.AccessSchedule.DayOfWeekPayload? = nil,
                StartHour: Swift.Double? = nil,
                EndHour: Swift.Double? = nil
            ) {
                self.Id = Id
                self.UserId = UserId
                self.DayOfWeek = DayOfWeek
                self.StartHour = StartHour
                self.EndHour = EndHour
            }
            public enum CodingKeys: String, CodingKey {
                case Id
                case UserId
                case DayOfWeek
                case StartHour
                case EndHour
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Id = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .Id
                )
                UserId = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .UserId
                )
                DayOfWeek = try container.decodeIfPresent(
                    Components.Schemas.AccessSchedule.DayOfWeekPayload.self,
                    forKey: .DayOfWeek
                )
                StartHour = try container.decodeIfPresent(
                    Swift.Double.self,
                    forKey: .StartHour
                )
                EndHour = try container.decodeIfPresent(
                    Swift.Double.self,
                    forKey: .EndHour
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Id",
                    "UserId",
                    "DayOfWeek",
                    "StartHour",
                    "EndHour"
                ])
            }
        }
        /// An enum representing formats of spatial audio.
        ///
        /// - Remark: Generated from `#/components/schemas/AudioSpatialFormat`.
        @frozen public enum AudioSpatialFormat: String, Codable, Hashable, Sendable, CaseIterable {
            case None = "None"
            case DolbyAtmos = "DolbyAtmos"
            case DTSX = "DTSX"
        }
        /// The authenticate user by name request body.
        ///
        /// - Remark: Generated from `#/components/schemas/AuthenticateUserByName`.
        public struct AuthenticateUserByName: Codable, Hashable, Sendable {
            /// Gets or sets the username.
            ///
            /// - Remark: Generated from `#/components/schemas/AuthenticateUserByName/Username`.
            public var Username: Swift.String?
            /// Gets or sets the plain text password.
            ///
            /// - Remark: Generated from `#/components/schemas/AuthenticateUserByName/Pw`.
            public var Pw: Swift.String?
            /// Creates a new `AuthenticateUserByName`.
            ///
            /// - Parameters:
            ///   - Username: Gets or sets the username.
            ///   - Pw: Gets or sets the plain text password.
            public init(
                Username: Swift.String? = nil,
                Pw: Swift.String? = nil
            ) {
                self.Username = Username
                self.Pw = Pw
            }
            public enum CodingKeys: String, CodingKey {
                case Username
                case Pw
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Username = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Username
                )
                Pw = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Pw
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Username",
                    "Pw"
                ])
            }
        }
        /// A class representing an authentication result.
        ///
        /// - Remark: Generated from `#/components/schemas/AuthenticationResult`.
        public struct AuthenticationResult: Codable, Hashable, Sendable {
            /// Class UserDto.
            ///
            /// - Remark: Generated from `#/components/schemas/AuthenticationResult/User`.
            public struct UserPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/AuthenticationResult/User/value1`.
                public var value1: Components.Schemas.UserDto
                /// Creates a new `UserPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.UserDto) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try value1.encode(to: encoder)
                }
            }
            /// Class UserDto.
            ///
            /// - Remark: Generated from `#/components/schemas/AuthenticationResult/User`.
            public var User: Components.Schemas.AuthenticationResult.UserPayload?
            /// Session info DTO.
            ///
            /// - Remark: Generated from `#/components/schemas/AuthenticationResult/SessionInfo`.
            public struct SessionInfoPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/AuthenticationResult/SessionInfo/value1`.
                public var value1: Components.Schemas.SessionInfoDto
                /// Creates a new `SessionInfoPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.SessionInfoDto) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try value1.encode(to: encoder)
                }
            }
            /// Session info DTO.
            ///
            /// - Remark: Generated from `#/components/schemas/AuthenticationResult/SessionInfo`.
            public var SessionInfo: Components.Schemas.AuthenticationResult.SessionInfoPayload?
            /// Gets or sets the access token.
            ///
            /// - Remark: Generated from `#/components/schemas/AuthenticationResult/AccessToken`.
            public var AccessToken: Swift.String?
            /// Gets or sets the server id.
            ///
            /// - Remark: Generated from `#/components/schemas/AuthenticationResult/ServerId`.
            public var ServerId: Swift.String?
            /// Creates a new `AuthenticationResult`.
            ///
            /// - Parameters:
            ///   - User: Class UserDto.
            ///   - SessionInfo: Session info DTO.
            ///   - AccessToken: Gets or sets the access token.
            ///   - ServerId: Gets or sets the server id.
            public init(
                User: Components.Schemas.AuthenticationResult.UserPayload? = nil,
                SessionInfo: Components.Schemas.AuthenticationResult.SessionInfoPayload? = nil,
                AccessToken: Swift.String? = nil,
                ServerId: Swift.String? = nil
            ) {
                self.User = User
                self.SessionInfo = SessionInfo
                self.AccessToken = AccessToken
                self.ServerId = ServerId
            }
            public enum CodingKeys: String, CodingKey {
                case User
                case SessionInfo
                case AccessToken
                case ServerId
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                User = try container.decodeIfPresent(
                    Components.Schemas.AuthenticationResult.UserPayload.self,
                    forKey: .User
                )
                SessionInfo = try container.decodeIfPresent(
                    Components.Schemas.AuthenticationResult.SessionInfoPayload.self,
                    forKey: .SessionInfo
                )
                AccessToken = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .AccessToken
                )
                ServerId = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ServerId
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "User",
                    "SessionInfo",
                    "AccessToken",
                    "ServerId"
                ])
            }
        }
        /// This is strictly used as a data transfer object from the api layer.
        /// This holds information about a BaseItem in a format that is convenient for the client.
        ///
        /// - Remark: Generated from `#/components/schemas/BaseItemDto`.
        public struct BaseItemDto: Codable, Hashable, Sendable {
            /// Gets or sets the name.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Name`.
            public var Name: Swift.String? {
                get  {
                    storage.value.Name
                }
                _modify {
                    yield &storage.value.Name
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/OriginalTitle`.
            public var OriginalTitle: Swift.String? {
                get  {
                    storage.value.OriginalTitle
                }
                _modify {
                    yield &storage.value.OriginalTitle
                }
            }
            /// Gets or sets the server identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ServerId`.
            public var ServerId: Swift.String? {
                get  {
                    storage.value.ServerId
                }
                _modify {
                    yield &storage.value.ServerId
                }
            }
            /// Gets or sets the id.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Id`.
            public var Id: Swift.String? {
                get  {
                    storage.value.Id
                }
                _modify {
                    yield &storage.value.Id
                }
            }
            /// Gets or sets the etag.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Etag`.
            public var Etag: Swift.String? {
                get  {
                    storage.value.Etag
                }
                _modify {
                    yield &storage.value.Etag
                }
            }
            /// Gets or sets the type of the source.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/SourceType`.
            public var SourceType: Swift.String? {
                get  {
                    storage.value.SourceType
                }
                _modify {
                    yield &storage.value.SourceType
                }
            }
            /// Gets or sets the playlist item identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/PlaylistItemId`.
            public var PlaylistItemId: Swift.String? {
                get  {
                    storage.value.PlaylistItemId
                }
                _modify {
                    yield &storage.value.PlaylistItemId
                }
            }
            /// Gets or sets the date created.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/DateCreated`.
            public var DateCreated: Foundation.Date? {
                get  {
                    storage.value.DateCreated
                }
                _modify {
                    yield &storage.value.DateCreated
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/DateLastMediaAdded`.
            public var DateLastMediaAdded: Foundation.Date? {
                get  {
                    storage.value.DateLastMediaAdded
                }
                _modify {
                    yield &storage.value.DateLastMediaAdded
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ExtraType`.
            public struct ExtraTypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ExtraType/value1`.
                public var value1: Components.Schemas.ExtraType
                /// Creates a new `ExtraTypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.ExtraType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ExtraType`.
            public var ExtraType: Components.Schemas.BaseItemDto.ExtraTypePayload? {
                get  {
                    storage.value.ExtraType
                }
                _modify {
                    yield &storage.value.ExtraType
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/AirsBeforeSeasonNumber`.
            public var AirsBeforeSeasonNumber: Swift.Int32? {
                get  {
                    storage.value.AirsBeforeSeasonNumber
                }
                _modify {
                    yield &storage.value.AirsBeforeSeasonNumber
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/AirsAfterSeasonNumber`.
            public var AirsAfterSeasonNumber: Swift.Int32? {
                get  {
                    storage.value.AirsAfterSeasonNumber
                }
                _modify {
                    yield &storage.value.AirsAfterSeasonNumber
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/AirsBeforeEpisodeNumber`.
            public var AirsBeforeEpisodeNumber: Swift.Int32? {
                get  {
                    storage.value.AirsBeforeEpisodeNumber
                }
                _modify {
                    yield &storage.value.AirsBeforeEpisodeNumber
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/CanDelete`.
            public var CanDelete: Swift.Bool? {
                get  {
                    storage.value.CanDelete
                }
                _modify {
                    yield &storage.value.CanDelete
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/CanDownload`.
            public var CanDownload: Swift.Bool? {
                get  {
                    storage.value.CanDownload
                }
                _modify {
                    yield &storage.value.CanDownload
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/HasLyrics`.
            public var HasLyrics: Swift.Bool? {
                get  {
                    storage.value.HasLyrics
                }
                _modify {
                    yield &storage.value.HasLyrics
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/HasSubtitles`.
            public var HasSubtitles: Swift.Bool? {
                get  {
                    storage.value.HasSubtitles
                }
                _modify {
                    yield &storage.value.HasSubtitles
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/PreferredMetadataLanguage`.
            public var PreferredMetadataLanguage: Swift.String? {
                get  {
                    storage.value.PreferredMetadataLanguage
                }
                _modify {
                    yield &storage.value.PreferredMetadataLanguage
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/PreferredMetadataCountryCode`.
            public var PreferredMetadataCountryCode: Swift.String? {
                get  {
                    storage.value.PreferredMetadataCountryCode
                }
                _modify {
                    yield &storage.value.PreferredMetadataCountryCode
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Container`.
            public var Container: Swift.String? {
                get  {
                    storage.value.Container
                }
                _modify {
                    yield &storage.value.Container
                }
            }
            /// Gets or sets the name of the sort.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/SortName`.
            public var SortName: Swift.String? {
                get  {
                    storage.value.SortName
                }
                _modify {
                    yield &storage.value.SortName
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ForcedSortName`.
            public var ForcedSortName: Swift.String? {
                get  {
                    storage.value.ForcedSortName
                }
                _modify {
                    yield &storage.value.ForcedSortName
                }
            }
            /// Gets or sets the video3 D format.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Video3DFormat`.
            public struct Video3DFormatPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Video3DFormat/value1`.
                public var value1: Components.Schemas.Video3DFormat
                /// Creates a new `Video3DFormatPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.Video3DFormat) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the video3 D format.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Video3DFormat`.
            public var Video3DFormat: Components.Schemas.BaseItemDto.Video3DFormatPayload? {
                get  {
                    storage.value.Video3DFormat
                }
                _modify {
                    yield &storage.value.Video3DFormat
                }
            }
            /// Gets or sets the premiere date.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/PremiereDate`.
            public var PremiereDate: Foundation.Date? {
                get  {
                    storage.value.PremiereDate
                }
                _modify {
                    yield &storage.value.PremiereDate
                }
            }
            /// Gets or sets the external urls.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ExternalUrls`.
            public var ExternalUrls: [Components.Schemas.ExternalUrl]? {
                get  {
                    storage.value.ExternalUrls
                }
                _modify {
                    yield &storage.value.ExternalUrls
                }
            }
            /// Gets or sets the media versions.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/MediaSources`.
            public var MediaSources: [Components.Schemas.MediaSourceInfo]? {
                get  {
                    storage.value.MediaSources
                }
                _modify {
                    yield &storage.value.MediaSources
                }
            }
            /// Gets or sets the critic rating.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/CriticRating`.
            public var CriticRating: Swift.Float? {
                get  {
                    storage.value.CriticRating
                }
                _modify {
                    yield &storage.value.CriticRating
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ProductionLocations`.
            public var ProductionLocations: [Swift.String]? {
                get  {
                    storage.value.ProductionLocations
                }
                _modify {
                    yield &storage.value.ProductionLocations
                }
            }
            /// Gets or sets the path.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Path`.
            public var Path: Swift.String? {
                get  {
                    storage.value.Path
                }
                _modify {
                    yield &storage.value.Path
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/EnableMediaSourceDisplay`.
            public var EnableMediaSourceDisplay: Swift.Bool? {
                get  {
                    storage.value.EnableMediaSourceDisplay
                }
                _modify {
                    yield &storage.value.EnableMediaSourceDisplay
                }
            }
            /// Gets or sets the official rating.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/OfficialRating`.
            public var OfficialRating: Swift.String? {
                get  {
                    storage.value.OfficialRating
                }
                _modify {
                    yield &storage.value.OfficialRating
                }
            }
            /// Gets or sets the custom rating.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/CustomRating`.
            public var CustomRating: Swift.String? {
                get  {
                    storage.value.CustomRating
                }
                _modify {
                    yield &storage.value.CustomRating
                }
            }
            /// Gets or sets the channel identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ChannelId`.
            public var ChannelId: Swift.String? {
                get  {
                    storage.value.ChannelId
                }
                _modify {
                    yield &storage.value.ChannelId
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ChannelName`.
            public var ChannelName: Swift.String? {
                get  {
                    storage.value.ChannelName
                }
                _modify {
                    yield &storage.value.ChannelName
                }
            }
            /// Gets or sets the overview.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Overview`.
            public var Overview: Swift.String? {
                get  {
                    storage.value.Overview
                }
                _modify {
                    yield &storage.value.Overview
                }
            }
            /// Gets or sets the taglines.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Taglines`.
            public var Taglines: [Swift.String]? {
                get  {
                    storage.value.Taglines
                }
                _modify {
                    yield &storage.value.Taglines
                }
            }
            /// Gets or sets the genres.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Genres`.
            public var Genres: [Swift.String]? {
                get  {
                    storage.value.Genres
                }
                _modify {
                    yield &storage.value.Genres
                }
            }
            /// Gets or sets the community rating.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/CommunityRating`.
            public var CommunityRating: Swift.Float? {
                get  {
                    storage.value.CommunityRating
                }
                _modify {
                    yield &storage.value.CommunityRating
                }
            }
            /// Gets or sets the cumulative run time ticks.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/CumulativeRunTimeTicks`.
            public var CumulativeRunTimeTicks: Swift.Int64? {
                get  {
                    storage.value.CumulativeRunTimeTicks
                }
                _modify {
                    yield &storage.value.CumulativeRunTimeTicks
                }
            }
            /// Gets or sets the run time ticks.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/RunTimeTicks`.
            public var RunTimeTicks: Swift.Int64? {
                get  {
                    storage.value.RunTimeTicks
                }
                _modify {
                    yield &storage.value.RunTimeTicks
                }
            }
            /// Gets or sets the play access.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/PlayAccess`.
            public struct PlayAccessPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/PlayAccess/value1`.
                public var value1: Components.Schemas.PlayAccess
                /// Creates a new `PlayAccessPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.PlayAccess) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the play access.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/PlayAccess`.
            public var PlayAccess: Components.Schemas.BaseItemDto.PlayAccessPayload? {
                get  {
                    storage.value.PlayAccess
                }
                _modify {
                    yield &storage.value.PlayAccess
                }
            }
            /// Gets or sets the aspect ratio.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/AspectRatio`.
            public var AspectRatio: Swift.String? {
                get  {
                    storage.value.AspectRatio
                }
                _modify {
                    yield &storage.value.AspectRatio
                }
            }
            /// Gets or sets the production year.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ProductionYear`.
            public var ProductionYear: Swift.Int32? {
                get  {
                    storage.value.ProductionYear
                }
                _modify {
                    yield &storage.value.ProductionYear
                }
            }
            /// Gets or sets a value indicating whether this instance is place holder.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsPlaceHolder`.
            public var IsPlaceHolder: Swift.Bool? {
                get  {
                    storage.value.IsPlaceHolder
                }
                _modify {
                    yield &storage.value.IsPlaceHolder
                }
            }
            /// Gets or sets the number.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Number`.
            public var Number: Swift.String? {
                get  {
                    storage.value.Number
                }
                _modify {
                    yield &storage.value.Number
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ChannelNumber`.
            public var ChannelNumber: Swift.String? {
                get  {
                    storage.value.ChannelNumber
                }
                _modify {
                    yield &storage.value.ChannelNumber
                }
            }
            /// Gets or sets the index number.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/IndexNumber`.
            public var IndexNumber: Swift.Int32? {
                get  {
                    storage.value.IndexNumber
                }
                _modify {
                    yield &storage.value.IndexNumber
                }
            }
            /// Gets or sets the index number end.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/IndexNumberEnd`.
            public var IndexNumberEnd: Swift.Int32? {
                get  {
                    storage.value.IndexNumberEnd
                }
                _modify {
                    yield &storage.value.IndexNumberEnd
                }
            }
            /// Gets or sets the parent index number.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentIndexNumber`.
            public var ParentIndexNumber: Swift.Int32? {
                get  {
                    storage.value.ParentIndexNumber
                }
                _modify {
                    yield &storage.value.ParentIndexNumber
                }
            }
            /// Gets or sets the trailer urls.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/RemoteTrailers`.
            public var RemoteTrailers: [Components.Schemas.MediaUrl]? {
                get  {
                    storage.value.RemoteTrailers
                }
                _modify {
                    yield &storage.value.RemoteTrailers
                }
            }
            /// Gets or sets the provider ids.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ProviderIds`.
            public struct ProviderIdsPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.String?]
                /// Creates a new `ProviderIdsPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Swift.String?] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// Gets or sets the provider ids.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ProviderIds`.
            public var ProviderIds: Components.Schemas.BaseItemDto.ProviderIdsPayload? {
                get  {
                    storage.value.ProviderIds
                }
                _modify {
                    yield &storage.value.ProviderIds
                }
            }
            /// Gets or sets a value indicating whether this instance is HD.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsHD`.
            public var IsHD: Swift.Bool? {
                get  {
                    storage.value.IsHD
                }
                _modify {
                    yield &storage.value.IsHD
                }
            }
            /// Gets or sets a value indicating whether this instance is folder.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsFolder`.
            public var IsFolder: Swift.Bool? {
                get  {
                    storage.value.IsFolder
                }
                _modify {
                    yield &storage.value.IsFolder
                }
            }
            /// Gets or sets the parent id.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentId`.
            public var ParentId: Swift.String? {
                get  {
                    storage.value.ParentId
                }
                _modify {
                    yield &storage.value.ParentId
                }
            }
            /// The base item kind.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Type`.
            public struct _TypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Type/value1`.
                public var value1: Components.Schemas.BaseItemKind
                /// Creates a new `_TypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.BaseItemKind) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// The base item kind.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Type`.
            public var _Type: Components.Schemas.BaseItemDto._TypePayload? {
                get  {
                    storage.value._Type
                }
                _modify {
                    yield &storage.value._Type
                }
            }
            /// Gets or sets the people.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/People`.
            public var People: [Components.Schemas.BaseItemPerson]? {
                get  {
                    storage.value.People
                }
                _modify {
                    yield &storage.value.People
                }
            }
            /// Gets or sets the studios.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Studios`.
            public var Studios: [Components.Schemas.NameGuidPair]? {
                get  {
                    storage.value.Studios
                }
                _modify {
                    yield &storage.value.Studios
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/GenreItems`.
            public var GenreItems: [Components.Schemas.NameGuidPair]? {
                get  {
                    storage.value.GenreItems
                }
                _modify {
                    yield &storage.value.GenreItems
                }
            }
            /// Gets or sets whether the item has a logo, this will hold the Id of the Parent that has one.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentLogoItemId`.
            public var ParentLogoItemId: Swift.String? {
                get  {
                    storage.value.ParentLogoItemId
                }
                _modify {
                    yield &storage.value.ParentLogoItemId
                }
            }
            /// Gets or sets whether the item has any backdrops, this will hold the Id of the Parent that has one.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentBackdropItemId`.
            public var ParentBackdropItemId: Swift.String? {
                get  {
                    storage.value.ParentBackdropItemId
                }
                _modify {
                    yield &storage.value.ParentBackdropItemId
                }
            }
            /// Gets or sets the parent backdrop image tags.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentBackdropImageTags`.
            public var ParentBackdropImageTags: [Swift.String]? {
                get  {
                    storage.value.ParentBackdropImageTags
                }
                _modify {
                    yield &storage.value.ParentBackdropImageTags
                }
            }
            /// Gets or sets the local trailer count.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/LocalTrailerCount`.
            public var LocalTrailerCount: Swift.Int32? {
                get  {
                    storage.value.LocalTrailerCount
                }
                _modify {
                    yield &storage.value.LocalTrailerCount
                }
            }
            /// Gets or sets the user data for this item based on the user it's being requested for.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/UserData`.
            public struct UserDataPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/UserData/value1`.
                public var value1: Components.Schemas.UserItemDataDto
                /// Creates a new `UserDataPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.UserItemDataDto) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try value1.encode(to: encoder)
                }
            }
            /// Gets or sets the user data for this item based on the user it's being requested for.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/UserData`.
            public var UserData: Components.Schemas.BaseItemDto.UserDataPayload? {
                get  {
                    storage.value.UserData
                }
                _modify {
                    yield &storage.value.UserData
                }
            }
            /// Gets or sets the recursive item count.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/RecursiveItemCount`.
            public var RecursiveItemCount: Swift.Int32? {
                get  {
                    storage.value.RecursiveItemCount
                }
                _modify {
                    yield &storage.value.RecursiveItemCount
                }
            }
            /// Gets or sets the child count.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ChildCount`.
            public var ChildCount: Swift.Int32? {
                get  {
                    storage.value.ChildCount
                }
                _modify {
                    yield &storage.value.ChildCount
                }
            }
            /// Gets or sets the name of the series.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeriesName`.
            public var SeriesName: Swift.String? {
                get  {
                    storage.value.SeriesName
                }
                _modify {
                    yield &storage.value.SeriesName
                }
            }
            /// Gets or sets the series id.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeriesId`.
            public var SeriesId: Swift.String? {
                get  {
                    storage.value.SeriesId
                }
                _modify {
                    yield &storage.value.SeriesId
                }
            }
            /// Gets or sets the season identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeasonId`.
            public var SeasonId: Swift.String? {
                get  {
                    storage.value.SeasonId
                }
                _modify {
                    yield &storage.value.SeasonId
                }
            }
            /// Gets or sets the special feature count.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/SpecialFeatureCount`.
            public var SpecialFeatureCount: Swift.Int32? {
                get  {
                    storage.value.SpecialFeatureCount
                }
                _modify {
                    yield &storage.value.SpecialFeatureCount
                }
            }
            /// Gets or sets the display preferences id.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/DisplayPreferencesId`.
            public var DisplayPreferencesId: Swift.String? {
                get  {
                    storage.value.DisplayPreferencesId
                }
                _modify {
                    yield &storage.value.DisplayPreferencesId
                }
            }
            /// Gets or sets the status.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Status`.
            public var Status: Swift.String? {
                get  {
                    storage.value.Status
                }
                _modify {
                    yield &storage.value.Status
                }
            }
            /// Gets or sets the air time.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/AirTime`.
            public var AirTime: Swift.String? {
                get  {
                    storage.value.AirTime
                }
                _modify {
                    yield &storage.value.AirTime
                }
            }
            /// Gets or sets the air days.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/AirDays`.
            public var AirDays: [Components.Schemas.DayOfWeek]? {
                get  {
                    storage.value.AirDays
                }
                _modify {
                    yield &storage.value.AirDays
                }
            }
            /// Gets or sets the tags.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Tags`.
            public var Tags: [Swift.String]? {
                get  {
                    storage.value.Tags
                }
                _modify {
                    yield &storage.value.Tags
                }
            }
            /// Gets or sets the primary image aspect ratio, after image enhancements.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/PrimaryImageAspectRatio`.
            public var PrimaryImageAspectRatio: Swift.Double? {
                get  {
                    storage.value.PrimaryImageAspectRatio
                }
                _modify {
                    yield &storage.value.PrimaryImageAspectRatio
                }
            }
            /// Gets or sets the artists.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Artists`.
            public var Artists: [Swift.String]? {
                get  {
                    storage.value.Artists
                }
                _modify {
                    yield &storage.value.Artists
                }
            }
            /// Gets or sets the artist items.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ArtistItems`.
            public var ArtistItems: [Components.Schemas.NameGuidPair]? {
                get  {
                    storage.value.ArtistItems
                }
                _modify {
                    yield &storage.value.ArtistItems
                }
            }
            /// Gets or sets the album.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Album`.
            public var Album: Swift.String? {
                get  {
                    storage.value.Album
                }
                _modify {
                    yield &storage.value.Album
                }
            }
            /// Gets or sets the type of the collection.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/CollectionType`.
            public struct CollectionTypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/CollectionType/value1`.
                public var value1: Components.Schemas.CollectionType
                /// Creates a new `CollectionTypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.CollectionType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the type of the collection.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/CollectionType`.
            public var CollectionType: Components.Schemas.BaseItemDto.CollectionTypePayload? {
                get  {
                    storage.value.CollectionType
                }
                _modify {
                    yield &storage.value.CollectionType
                }
            }
            /// Gets or sets the display order.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/DisplayOrder`.
            public var DisplayOrder: Swift.String? {
                get  {
                    storage.value.DisplayOrder
                }
                _modify {
                    yield &storage.value.DisplayOrder
                }
            }
            /// Gets or sets the album id.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/AlbumId`.
            public var AlbumId: Swift.String? {
                get  {
                    storage.value.AlbumId
                }
                _modify {
                    yield &storage.value.AlbumId
                }
            }
            /// Gets or sets the album image tag.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/AlbumPrimaryImageTag`.
            public var AlbumPrimaryImageTag: Swift.String? {
                get  {
                    storage.value.AlbumPrimaryImageTag
                }
                _modify {
                    yield &storage.value.AlbumPrimaryImageTag
                }
            }
            /// Gets or sets the series primary image tag.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeriesPrimaryImageTag`.
            public var SeriesPrimaryImageTag: Swift.String? {
                get  {
                    storage.value.SeriesPrimaryImageTag
                }
                _modify {
                    yield &storage.value.SeriesPrimaryImageTag
                }
            }
            /// Gets or sets the album artist.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/AlbumArtist`.
            public var AlbumArtist: Swift.String? {
                get  {
                    storage.value.AlbumArtist
                }
                _modify {
                    yield &storage.value.AlbumArtist
                }
            }
            /// Gets or sets the album artists.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/AlbumArtists`.
            public var AlbumArtists: [Components.Schemas.NameGuidPair]? {
                get  {
                    storage.value.AlbumArtists
                }
                _modify {
                    yield &storage.value.AlbumArtists
                }
            }
            /// Gets or sets the name of the season.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeasonName`.
            public var SeasonName: Swift.String? {
                get  {
                    storage.value.SeasonName
                }
                _modify {
                    yield &storage.value.SeasonName
                }
            }
            /// Gets or sets the media streams.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/MediaStreams`.
            public var MediaStreams: [Components.Schemas.MediaStream]? {
                get  {
                    storage.value.MediaStreams
                }
                _modify {
                    yield &storage.value.MediaStreams
                }
            }
            /// Gets or sets the type of the video.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/VideoType`.
            public struct VideoTypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/VideoType/value1`.
                public var value1: Components.Schemas.VideoType
                /// Creates a new `VideoTypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.VideoType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the type of the video.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/VideoType`.
            public var VideoType: Components.Schemas.BaseItemDto.VideoTypePayload? {
                get  {
                    storage.value.VideoType
                }
                _modify {
                    yield &storage.value.VideoType
                }
            }
            /// Gets or sets the part count.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/PartCount`.
            public var PartCount: Swift.Int32? {
                get  {
                    storage.value.PartCount
                }
                _modify {
                    yield &storage.value.PartCount
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/MediaSourceCount`.
            public var MediaSourceCount: Swift.Int32? {
                get  {
                    storage.value.MediaSourceCount
                }
                _modify {
                    yield &storage.value.MediaSourceCount
                }
            }
            /// Gets or sets the image tags.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageTags`.
            public struct ImageTagsPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.String]
                /// Creates a new `ImageTagsPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Swift.String] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// Gets or sets the image tags.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageTags`.
            public var ImageTags: Components.Schemas.BaseItemDto.ImageTagsPayload? {
                get  {
                    storage.value.ImageTags
                }
                _modify {
                    yield &storage.value.ImageTags
                }
            }
            /// Gets or sets the backdrop image tags.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/BackdropImageTags`.
            public var BackdropImageTags: [Swift.String]? {
                get  {
                    storage.value.BackdropImageTags
                }
                _modify {
                    yield &storage.value.BackdropImageTags
                }
            }
            /// Gets or sets the screenshot image tags.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ScreenshotImageTags`.
            public var ScreenshotImageTags: [Swift.String]? {
                get  {
                    storage.value.ScreenshotImageTags
                }
                _modify {
                    yield &storage.value.ScreenshotImageTags
                }
            }
            /// Gets or sets the parent logo image tag.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentLogoImageTag`.
            public var ParentLogoImageTag: Swift.String? {
                get  {
                    storage.value.ParentLogoImageTag
                }
                _modify {
                    yield &storage.value.ParentLogoImageTag
                }
            }
            /// Gets or sets whether the item has fan art, this will hold the Id of the Parent that has one.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentArtItemId`.
            public var ParentArtItemId: Swift.String? {
                get  {
                    storage.value.ParentArtItemId
                }
                _modify {
                    yield &storage.value.ParentArtItemId
                }
            }
            /// Gets or sets the parent art image tag.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentArtImageTag`.
            public var ParentArtImageTag: Swift.String? {
                get  {
                    storage.value.ParentArtImageTag
                }
                _modify {
                    yield &storage.value.ParentArtImageTag
                }
            }
            /// Gets or sets the series thumb image tag.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeriesThumbImageTag`.
            public var SeriesThumbImageTag: Swift.String? {
                get  {
                    storage.value.SeriesThumbImageTag
                }
                _modify {
                    yield &storage.value.SeriesThumbImageTag
                }
            }
            /// Gets or sets the blurhashes for the image tags.
            /// Maps image type to dictionary mapping image tag to blurhash value.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes`.
            public struct ImageBlurHashesPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Primary`.
                public struct PrimaryPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `PrimaryPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Primary`.
                public var Primary: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.PrimaryPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Art`.
                public struct ArtPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `ArtPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Art`.
                public var Art: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ArtPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Backdrop`.
                public struct BackdropPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `BackdropPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Backdrop`.
                public var Backdrop: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.BackdropPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Banner`.
                public struct BannerPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `BannerPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Banner`.
                public var Banner: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.BannerPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Logo`.
                public struct LogoPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `LogoPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Logo`.
                public var Logo: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.LogoPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Thumb`.
                public struct ThumbPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `ThumbPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Thumb`.
                public var Thumb: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ThumbPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Disc`.
                public struct DiscPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `DiscPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Disc`.
                public var Disc: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.DiscPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Box`.
                public struct BoxPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `BoxPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Box`.
                public var Box: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.BoxPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Screenshot`.
                public struct ScreenshotPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `ScreenshotPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Screenshot`.
                public var Screenshot: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ScreenshotPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Menu`.
                public struct MenuPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `MenuPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Menu`.
                public var Menu: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.MenuPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Chapter`.
                public struct ChapterPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `ChapterPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Chapter`.
                public var Chapter: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ChapterPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/BoxRear`.
                public struct BoxRearPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `BoxRearPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/BoxRear`.
                public var BoxRear: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.BoxRearPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Profile`.
                public struct ProfilePayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `ProfilePayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Profile`.
                public var Profile: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ProfilePayload?
                /// Creates a new `ImageBlurHashesPayload`.
                ///
                /// - Parameters:
                ///   - Primary:
                ///   - Art:
                ///   - Backdrop:
                ///   - Banner:
                ///   - Logo:
                ///   - Thumb:
                ///   - Disc:
                ///   - Box:
                ///   - Screenshot:
                ///   - Menu:
                ///   - Chapter:
                ///   - BoxRear:
                ///   - Profile:
                public init(
                    Primary: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.PrimaryPayload? = nil,
                    Art: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ArtPayload? = nil,
                    Backdrop: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.BackdropPayload? = nil,
                    Banner: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.BannerPayload? = nil,
                    Logo: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.LogoPayload? = nil,
                    Thumb: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ThumbPayload? = nil,
                    Disc: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.DiscPayload? = nil,
                    Box: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.BoxPayload? = nil,
                    Screenshot: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ScreenshotPayload? = nil,
                    Menu: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.MenuPayload? = nil,
                    Chapter: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ChapterPayload? = nil,
                    BoxRear: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.BoxRearPayload? = nil,
                    Profile: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ProfilePayload? = nil
                ) {
                    self.Primary = Primary
                    self.Art = Art
                    self.Backdrop = Backdrop
                    self.Banner = Banner
                    self.Logo = Logo
                    self.Thumb = Thumb
                    self.Disc = Disc
                    self.Box = Box
                    self.Screenshot = Screenshot
                    self.Menu = Menu
                    self.Chapter = Chapter
                    self.BoxRear = BoxRear
                    self.Profile = Profile
                }
                public enum CodingKeys: String, CodingKey {
                    case Primary
                    case Art
                    case Backdrop
                    case Banner
                    case Logo
                    case Thumb
                    case Disc
                    case Box
                    case Screenshot
                    case Menu
                    case Chapter
                    case BoxRear
                    case Profile
                }
            }
            /// Gets or sets the blurhashes for the image tags.
            /// Maps image type to dictionary mapping image tag to blurhash value.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes`.
            public var ImageBlurHashes: Components.Schemas.BaseItemDto.ImageBlurHashesPayload? {
                get  {
                    storage.value.ImageBlurHashes
                }
                _modify {
                    yield &storage.value.ImageBlurHashes
                }
            }
            /// Gets or sets the series studio.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeriesStudio`.
            public var SeriesStudio: Swift.String? {
                get  {
                    storage.value.SeriesStudio
                }
                _modify {
                    yield &storage.value.SeriesStudio
                }
            }
            /// Gets or sets the parent thumb item id.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentThumbItemId`.
            public var ParentThumbItemId: Swift.String? {
                get  {
                    storage.value.ParentThumbItemId
                }
                _modify {
                    yield &storage.value.ParentThumbItemId
                }
            }
            /// Gets or sets the parent thumb image tag.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentThumbImageTag`.
            public var ParentThumbImageTag: Swift.String? {
                get  {
                    storage.value.ParentThumbImageTag
                }
                _modify {
                    yield &storage.value.ParentThumbImageTag
                }
            }
            /// Gets or sets the parent primary image item identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentPrimaryImageItemId`.
            public var ParentPrimaryImageItemId: Swift.String? {
                get  {
                    storage.value.ParentPrimaryImageItemId
                }
                _modify {
                    yield &storage.value.ParentPrimaryImageItemId
                }
            }
            /// Gets or sets the parent primary image tag.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentPrimaryImageTag`.
            public var ParentPrimaryImageTag: Swift.String? {
                get  {
                    storage.value.ParentPrimaryImageTag
                }
                _modify {
                    yield &storage.value.ParentPrimaryImageTag
                }
            }
            /// Gets or sets the chapters.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Chapters`.
            public var Chapters: [Components.Schemas.ChapterInfo]? {
                get  {
                    storage.value.Chapters
                }
                _modify {
                    yield &storage.value.Chapters
                }
            }
            /// Gets or sets the trickplay manifest.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Trickplay`.
            public struct TrickplayPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Trickplay/additionalProperties`.
                public struct additionalPropertiesPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Components.Schemas.TrickplayInfo]
                    /// Creates a new `additionalPropertiesPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Components.Schemas.TrickplayInfo] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// A container of undocumented properties.
                public var additionalProperties: [String: Components.Schemas.BaseItemDto.TrickplayPayload.additionalPropertiesPayload]
                /// Creates a new `TrickplayPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Components.Schemas.BaseItemDto.TrickplayPayload.additionalPropertiesPayload] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// Gets or sets the trickplay manifest.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Trickplay`.
            public var Trickplay: Components.Schemas.BaseItemDto.TrickplayPayload? {
                get  {
                    storage.value.Trickplay
                }
                _modify {
                    yield &storage.value.Trickplay
                }
            }
            /// Gets or sets the type of the location.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/LocationType`.
            public struct LocationTypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/LocationType/value1`.
                public var value1: Components.Schemas.LocationType
                /// Creates a new `LocationTypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.LocationType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the type of the location.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/LocationType`.
            public var LocationType: Components.Schemas.BaseItemDto.LocationTypePayload? {
                get  {
                    storage.value.LocationType
                }
                _modify {
                    yield &storage.value.LocationType
                }
            }
            /// Gets or sets the type of the iso.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsoType`.
            public struct IsoTypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsoType/value1`.
                public var value1: Components.Schemas.IsoType
                /// Creates a new `IsoTypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.IsoType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the type of the iso.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsoType`.
            public var IsoType: Components.Schemas.BaseItemDto.IsoTypePayload? {
                get  {
                    storage.value.IsoType
                }
                _modify {
                    yield &storage.value.IsoType
                }
            }
            /// Media types.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/MediaType`.
            public struct MediaTypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/MediaType/value1`.
                public var value1: Components.Schemas.MediaType
                /// Creates a new `MediaTypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.MediaType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Media types.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/MediaType`.
            public var MediaType: Components.Schemas.BaseItemDto.MediaTypePayload? {
                get  {
                    storage.value.MediaType
                }
                _modify {
                    yield &storage.value.MediaType
                }
            }
            /// Gets or sets the end date.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/EndDate`.
            public var EndDate: Foundation.Date? {
                get  {
                    storage.value.EndDate
                }
                _modify {
                    yield &storage.value.EndDate
                }
            }
            /// Gets or sets the locked fields.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/LockedFields`.
            public var LockedFields: [Components.Schemas.MetadataField]? {
                get  {
                    storage.value.LockedFields
                }
                _modify {
                    yield &storage.value.LockedFields
                }
            }
            /// Gets or sets the trailer count.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/TrailerCount`.
            public var TrailerCount: Swift.Int32? {
                get  {
                    storage.value.TrailerCount
                }
                _modify {
                    yield &storage.value.TrailerCount
                }
            }
            /// Gets or sets the movie count.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/MovieCount`.
            public var MovieCount: Swift.Int32? {
                get  {
                    storage.value.MovieCount
                }
                _modify {
                    yield &storage.value.MovieCount
                }
            }
            /// Gets or sets the series count.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeriesCount`.
            public var SeriesCount: Swift.Int32? {
                get  {
                    storage.value.SeriesCount
                }
                _modify {
                    yield &storage.value.SeriesCount
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ProgramCount`.
            public var ProgramCount: Swift.Int32? {
                get  {
                    storage.value.ProgramCount
                }
                _modify {
                    yield &storage.value.ProgramCount
                }
            }
            /// Gets or sets the episode count.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/EpisodeCount`.
            public var EpisodeCount: Swift.Int32? {
                get  {
                    storage.value.EpisodeCount
                }
                _modify {
                    yield &storage.value.EpisodeCount
                }
            }
            /// Gets or sets the song count.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/SongCount`.
            public var SongCount: Swift.Int32? {
                get  {
                    storage.value.SongCount
                }
                _modify {
                    yield &storage.value.SongCount
                }
            }
            /// Gets or sets the album count.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/AlbumCount`.
            public var AlbumCount: Swift.Int32? {
                get  {
                    storage.value.AlbumCount
                }
                _modify {
                    yield &storage.value.AlbumCount
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ArtistCount`.
            public var ArtistCount: Swift.Int32? {
                get  {
                    storage.value.ArtistCount
                }
                _modify {
                    yield &storage.value.ArtistCount
                }
            }
            /// Gets or sets the music video count.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/MusicVideoCount`.
            public var MusicVideoCount: Swift.Int32? {
                get  {
                    storage.value.MusicVideoCount
                }
                _modify {
                    yield &storage.value.MusicVideoCount
                }
            }
            /// Gets or sets a value indicating whether [enable internet providers].
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/LockData`.
            public var LockData: Swift.Bool? {
                get  {
                    storage.value.LockData
                }
                _modify {
                    yield &storage.value.LockData
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Width`.
            public var Width: Swift.Int32? {
                get  {
                    storage.value.Width
                }
                _modify {
                    yield &storage.value.Width
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Height`.
            public var Height: Swift.Int32? {
                get  {
                    storage.value.Height
                }
                _modify {
                    yield &storage.value.Height
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/CameraMake`.
            public var CameraMake: Swift.String? {
                get  {
                    storage.value.CameraMake
                }
                _modify {
                    yield &storage.value.CameraMake
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/CameraModel`.
            public var CameraModel: Swift.String? {
                get  {
                    storage.value.CameraModel
                }
                _modify {
                    yield &storage.value.CameraModel
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Software`.
            public var Software: Swift.String? {
                get  {
                    storage.value.Software
                }
                _modify {
                    yield &storage.value.Software
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ExposureTime`.
            public var ExposureTime: Swift.Double? {
                get  {
                    storage.value.ExposureTime
                }
                _modify {
                    yield &storage.value.ExposureTime
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/FocalLength`.
            public var FocalLength: Swift.Double? {
                get  {
                    storage.value.FocalLength
                }
                _modify {
                    yield &storage.value.FocalLength
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageOrientation`.
            public struct ImageOrientationPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageOrientation/value1`.
                public var value1: Components.Schemas.ImageOrientation
                /// Creates a new `ImageOrientationPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.ImageOrientation) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageOrientation`.
            public var ImageOrientation: Components.Schemas.BaseItemDto.ImageOrientationPayload? {
                get  {
                    storage.value.ImageOrientation
                }
                _modify {
                    yield &storage.value.ImageOrientation
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Aperture`.
            public var Aperture: Swift.Double? {
                get  {
                    storage.value.Aperture
                }
                _modify {
                    yield &storage.value.Aperture
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ShutterSpeed`.
            public var ShutterSpeed: Swift.Double? {
                get  {
                    storage.value.ShutterSpeed
                }
                _modify {
                    yield &storage.value.ShutterSpeed
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Latitude`.
            public var Latitude: Swift.Double? {
                get  {
                    storage.value.Latitude
                }
                _modify {
                    yield &storage.value.Latitude
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Longitude`.
            public var Longitude: Swift.Double? {
                get  {
                    storage.value.Longitude
                }
                _modify {
                    yield &storage.value.Longitude
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Altitude`.
            public var Altitude: Swift.Double? {
                get  {
                    storage.value.Altitude
                }
                _modify {
                    yield &storage.value.Altitude
                }
            }
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsoSpeedRating`.
            public var IsoSpeedRating: Swift.Int32? {
                get  {
                    storage.value.IsoSpeedRating
                }
                _modify {
                    yield &storage.value.IsoSpeedRating
                }
            }
            /// Gets or sets the series timer identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeriesTimerId`.
            public var SeriesTimerId: Swift.String? {
                get  {
                    storage.value.SeriesTimerId
                }
                _modify {
                    yield &storage.value.SeriesTimerId
                }
            }
            /// Gets or sets the program identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ProgramId`.
            public var ProgramId: Swift.String? {
                get  {
                    storage.value.ProgramId
                }
                _modify {
                    yield &storage.value.ProgramId
                }
            }
            /// Gets or sets the channel primary image tag.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ChannelPrimaryImageTag`.
            public var ChannelPrimaryImageTag: Swift.String? {
                get  {
                    storage.value.ChannelPrimaryImageTag
                }
                _modify {
                    yield &storage.value.ChannelPrimaryImageTag
                }
            }
            /// Gets or sets the start date of the recording, in UTC.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/StartDate`.
            public var StartDate: Foundation.Date? {
                get  {
                    storage.value.StartDate
                }
                _modify {
                    yield &storage.value.StartDate
                }
            }
            /// Gets or sets the completion percentage.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/CompletionPercentage`.
            public var CompletionPercentage: Swift.Double? {
                get  {
                    storage.value.CompletionPercentage
                }
                _modify {
                    yield &storage.value.CompletionPercentage
                }
            }
            /// Gets or sets a value indicating whether this instance is repeat.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsRepeat`.
            public var IsRepeat: Swift.Bool? {
                get  {
                    storage.value.IsRepeat
                }
                _modify {
                    yield &storage.value.IsRepeat
                }
            }
            /// Gets or sets the episode title.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/EpisodeTitle`.
            public var EpisodeTitle: Swift.String? {
                get  {
                    storage.value.EpisodeTitle
                }
                _modify {
                    yield &storage.value.EpisodeTitle
                }
            }
            /// Gets or sets the type of the channel.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ChannelType`.
            public struct ChannelTypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ChannelType/value1`.
                public var value1: Components.Schemas.ChannelType
                /// Creates a new `ChannelTypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.ChannelType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the type of the channel.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/ChannelType`.
            public var ChannelType: Components.Schemas.BaseItemDto.ChannelTypePayload? {
                get  {
                    storage.value.ChannelType
                }
                _modify {
                    yield &storage.value.ChannelType
                }
            }
            /// Gets or sets the audio.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Audio`.
            public struct AudioPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Audio/value1`.
                public var value1: Components.Schemas.ProgramAudio
                /// Creates a new `AudioPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.ProgramAudio) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the audio.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/Audio`.
            public var Audio: Components.Schemas.BaseItemDto.AudioPayload? {
                get  {
                    storage.value.Audio
                }
                _modify {
                    yield &storage.value.Audio
                }
            }
            /// Gets or sets a value indicating whether this instance is movie.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsMovie`.
            public var IsMovie: Swift.Bool? {
                get  {
                    storage.value.IsMovie
                }
                _modify {
                    yield &storage.value.IsMovie
                }
            }
            /// Gets or sets a value indicating whether this instance is sports.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsSports`.
            public var IsSports: Swift.Bool? {
                get  {
                    storage.value.IsSports
                }
                _modify {
                    yield &storage.value.IsSports
                }
            }
            /// Gets or sets a value indicating whether this instance is series.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsSeries`.
            public var IsSeries: Swift.Bool? {
                get  {
                    storage.value.IsSeries
                }
                _modify {
                    yield &storage.value.IsSeries
                }
            }
            /// Gets or sets a value indicating whether this instance is live.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsLive`.
            public var IsLive: Swift.Bool? {
                get  {
                    storage.value.IsLive
                }
                _modify {
                    yield &storage.value.IsLive
                }
            }
            /// Gets or sets a value indicating whether this instance is news.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsNews`.
            public var IsNews: Swift.Bool? {
                get  {
                    storage.value.IsNews
                }
                _modify {
                    yield &storage.value.IsNews
                }
            }
            /// Gets or sets a value indicating whether this instance is kids.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsKids`.
            public var IsKids: Swift.Bool? {
                get  {
                    storage.value.IsKids
                }
                _modify {
                    yield &storage.value.IsKids
                }
            }
            /// Gets or sets a value indicating whether this instance is premiere.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsPremiere`.
            public var IsPremiere: Swift.Bool? {
                get  {
                    storage.value.IsPremiere
                }
                _modify {
                    yield &storage.value.IsPremiere
                }
            }
            /// Gets or sets the timer identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/TimerId`.
            public var TimerId: Swift.String? {
                get  {
                    storage.value.TimerId
                }
                _modify {
                    yield &storage.value.TimerId
                }
            }
            /// Gets or sets the gain required for audio normalization.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/NormalizationGain`.
            public var NormalizationGain: Swift.Float? {
                get  {
                    storage.value.NormalizationGain
                }
                _modify {
                    yield &storage.value.NormalizationGain
                }
            }
            /// Gets or sets the current program.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/CurrentProgram`.
            public struct CurrentProgramPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/CurrentProgram/value1`.
                public var value1: Components.Schemas.BaseItemDto
                /// Creates a new `CurrentProgramPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.BaseItemDto) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try value1.encode(to: encoder)
                }
            }
            /// Gets or sets the current program.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDto/CurrentProgram`.
            public var CurrentProgram: Components.Schemas.BaseItemDto.CurrentProgramPayload? {
                get  {
                    storage.value.CurrentProgram
                }
                _modify {
                    yield &storage.value.CurrentProgram
                }
            }
            /// Creates a new `BaseItemDto`.
            ///
            /// - Parameters:
            ///   - Name: Gets or sets the name.
            ///   - OriginalTitle:
            ///   - ServerId: Gets or sets the server identifier.
            ///   - Id: Gets or sets the id.
            ///   - Etag: Gets or sets the etag.
            ///   - SourceType: Gets or sets the type of the source.
            ///   - PlaylistItemId: Gets or sets the playlist item identifier.
            ///   - DateCreated: Gets or sets the date created.
            ///   - DateLastMediaAdded:
            ///   - ExtraType:
            ///   - AirsBeforeSeasonNumber:
            ///   - AirsAfterSeasonNumber:
            ///   - AirsBeforeEpisodeNumber:
            ///   - CanDelete:
            ///   - CanDownload:
            ///   - HasLyrics:
            ///   - HasSubtitles:
            ///   - PreferredMetadataLanguage:
            ///   - PreferredMetadataCountryCode:
            ///   - Container:
            ///   - SortName: Gets or sets the name of the sort.
            ///   - ForcedSortName:
            ///   - Video3DFormat: Gets or sets the video3 D format.
            ///   - PremiereDate: Gets or sets the premiere date.
            ///   - ExternalUrls: Gets or sets the external urls.
            ///   - MediaSources: Gets or sets the media versions.
            ///   - CriticRating: Gets or sets the critic rating.
            ///   - ProductionLocations:
            ///   - Path: Gets or sets the path.
            ///   - EnableMediaSourceDisplay:
            ///   - OfficialRating: Gets or sets the official rating.
            ///   - CustomRating: Gets or sets the custom rating.
            ///   - ChannelId: Gets or sets the channel identifier.
            ///   - ChannelName:
            ///   - Overview: Gets or sets the overview.
            ///   - Taglines: Gets or sets the taglines.
            ///   - Genres: Gets or sets the genres.
            ///   - CommunityRating: Gets or sets the community rating.
            ///   - CumulativeRunTimeTicks: Gets or sets the cumulative run time ticks.
            ///   - RunTimeTicks: Gets or sets the run time ticks.
            ///   - PlayAccess: Gets or sets the play access.
            ///   - AspectRatio: Gets or sets the aspect ratio.
            ///   - ProductionYear: Gets or sets the production year.
            ///   - IsPlaceHolder: Gets or sets a value indicating whether this instance is place holder.
            ///   - Number: Gets or sets the number.
            ///   - ChannelNumber:
            ///   - IndexNumber: Gets or sets the index number.
            ///   - IndexNumberEnd: Gets or sets the index number end.
            ///   - ParentIndexNumber: Gets or sets the parent index number.
            ///   - RemoteTrailers: Gets or sets the trailer urls.
            ///   - ProviderIds: Gets or sets the provider ids.
            ///   - IsHD: Gets or sets a value indicating whether this instance is HD.
            ///   - IsFolder: Gets or sets a value indicating whether this instance is folder.
            ///   - ParentId: Gets or sets the parent id.
            ///   - _Type: The base item kind.
            ///   - People: Gets or sets the people.
            ///   - Studios: Gets or sets the studios.
            ///   - GenreItems:
            ///   - ParentLogoItemId: Gets or sets whether the item has a logo, this will hold the Id of the Parent that has one.
            ///   - ParentBackdropItemId: Gets or sets whether the item has any backdrops, this will hold the Id of the Parent that has one.
            ///   - ParentBackdropImageTags: Gets or sets the parent backdrop image tags.
            ///   - LocalTrailerCount: Gets or sets the local trailer count.
            ///   - UserData: Gets or sets the user data for this item based on the user it's being requested for.
            ///   - RecursiveItemCount: Gets or sets the recursive item count.
            ///   - ChildCount: Gets or sets the child count.
            ///   - SeriesName: Gets or sets the name of the series.
            ///   - SeriesId: Gets or sets the series id.
            ///   - SeasonId: Gets or sets the season identifier.
            ///   - SpecialFeatureCount: Gets or sets the special feature count.
            ///   - DisplayPreferencesId: Gets or sets the display preferences id.
            ///   - Status: Gets or sets the status.
            ///   - AirTime: Gets or sets the air time.
            ///   - AirDays: Gets or sets the air days.
            ///   - Tags: Gets or sets the tags.
            ///   - PrimaryImageAspectRatio: Gets or sets the primary image aspect ratio, after image enhancements.
            ///   - Artists: Gets or sets the artists.
            ///   - ArtistItems: Gets or sets the artist items.
            ///   - Album: Gets or sets the album.
            ///   - CollectionType: Gets or sets the type of the collection.
            ///   - DisplayOrder: Gets or sets the display order.
            ///   - AlbumId: Gets or sets the album id.
            ///   - AlbumPrimaryImageTag: Gets or sets the album image tag.
            ///   - SeriesPrimaryImageTag: Gets or sets the series primary image tag.
            ///   - AlbumArtist: Gets or sets the album artist.
            ///   - AlbumArtists: Gets or sets the album artists.
            ///   - SeasonName: Gets or sets the name of the season.
            ///   - MediaStreams: Gets or sets the media streams.
            ///   - VideoType: Gets or sets the type of the video.
            ///   - PartCount: Gets or sets the part count.
            ///   - MediaSourceCount:
            ///   - ImageTags: Gets or sets the image tags.
            ///   - BackdropImageTags: Gets or sets the backdrop image tags.
            ///   - ScreenshotImageTags: Gets or sets the screenshot image tags.
            ///   - ParentLogoImageTag: Gets or sets the parent logo image tag.
            ///   - ParentArtItemId: Gets or sets whether the item has fan art, this will hold the Id of the Parent that has one.
            ///   - ParentArtImageTag: Gets or sets the parent art image tag.
            ///   - SeriesThumbImageTag: Gets or sets the series thumb image tag.
            ///   - ImageBlurHashes: Gets or sets the blurhashes for the image tags.
            /// Maps image type to dictionary mapping image tag to blurhash value.
            ///   - SeriesStudio: Gets or sets the series studio.
            ///   - ParentThumbItemId: Gets or sets the parent thumb item id.
            ///   - ParentThumbImageTag: Gets or sets the parent thumb image tag.
            ///   - ParentPrimaryImageItemId: Gets or sets the parent primary image item identifier.
            ///   - ParentPrimaryImageTag: Gets or sets the parent primary image tag.
            ///   - Chapters: Gets or sets the chapters.
            ///   - Trickplay: Gets or sets the trickplay manifest.
            ///   - LocationType: Gets or sets the type of the location.
            ///   - IsoType: Gets or sets the type of the iso.
            ///   - MediaType: Media types.
            ///   - EndDate: Gets or sets the end date.
            ///   - LockedFields: Gets or sets the locked fields.
            ///   - TrailerCount: Gets or sets the trailer count.
            ///   - MovieCount: Gets or sets the movie count.
            ///   - SeriesCount: Gets or sets the series count.
            ///   - ProgramCount:
            ///   - EpisodeCount: Gets or sets the episode count.
            ///   - SongCount: Gets or sets the song count.
            ///   - AlbumCount: Gets or sets the album count.
            ///   - ArtistCount:
            ///   - MusicVideoCount: Gets or sets the music video count.
            ///   - LockData: Gets or sets a value indicating whether [enable internet providers].
            ///   - Width:
            ///   - Height:
            ///   - CameraMake:
            ///   - CameraModel:
            ///   - Software:
            ///   - ExposureTime:
            ///   - FocalLength:
            ///   - ImageOrientation:
            ///   - Aperture:
            ///   - ShutterSpeed:
            ///   - Latitude:
            ///   - Longitude:
            ///   - Altitude:
            ///   - IsoSpeedRating:
            ///   - SeriesTimerId: Gets or sets the series timer identifier.
            ///   - ProgramId: Gets or sets the program identifier.
            ///   - ChannelPrimaryImageTag: Gets or sets the channel primary image tag.
            ///   - StartDate: Gets or sets the start date of the recording, in UTC.
            ///   - CompletionPercentage: Gets or sets the completion percentage.
            ///   - IsRepeat: Gets or sets a value indicating whether this instance is repeat.
            ///   - EpisodeTitle: Gets or sets the episode title.
            ///   - ChannelType: Gets or sets the type of the channel.
            ///   - Audio: Gets or sets the audio.
            ///   - IsMovie: Gets or sets a value indicating whether this instance is movie.
            ///   - IsSports: Gets or sets a value indicating whether this instance is sports.
            ///   - IsSeries: Gets or sets a value indicating whether this instance is series.
            ///   - IsLive: Gets or sets a value indicating whether this instance is live.
            ///   - IsNews: Gets or sets a value indicating whether this instance is news.
            ///   - IsKids: Gets or sets a value indicating whether this instance is kids.
            ///   - IsPremiere: Gets or sets a value indicating whether this instance is premiere.
            ///   - TimerId: Gets or sets the timer identifier.
            ///   - NormalizationGain: Gets or sets the gain required for audio normalization.
            ///   - CurrentProgram: Gets or sets the current program.
            public init(
                Name: Swift.String? = nil,
                OriginalTitle: Swift.String? = nil,
                ServerId: Swift.String? = nil,
                Id: Swift.String? = nil,
                Etag: Swift.String? = nil,
                SourceType: Swift.String? = nil,
                PlaylistItemId: Swift.String? = nil,
                DateCreated: Foundation.Date? = nil,
                DateLastMediaAdded: Foundation.Date? = nil,
                ExtraType: Components.Schemas.BaseItemDto.ExtraTypePayload? = nil,
                AirsBeforeSeasonNumber: Swift.Int32? = nil,
                AirsAfterSeasonNumber: Swift.Int32? = nil,
                AirsBeforeEpisodeNumber: Swift.Int32? = nil,
                CanDelete: Swift.Bool? = nil,
                CanDownload: Swift.Bool? = nil,
                HasLyrics: Swift.Bool? = nil,
                HasSubtitles: Swift.Bool? = nil,
                PreferredMetadataLanguage: Swift.String? = nil,
                PreferredMetadataCountryCode: Swift.String? = nil,
                Container: Swift.String? = nil,
                SortName: Swift.String? = nil,
                ForcedSortName: Swift.String? = nil,
                Video3DFormat: Components.Schemas.BaseItemDto.Video3DFormatPayload? = nil,
                PremiereDate: Foundation.Date? = nil,
                ExternalUrls: [Components.Schemas.ExternalUrl]? = nil,
                MediaSources: [Components.Schemas.MediaSourceInfo]? = nil,
                CriticRating: Swift.Float? = nil,
                ProductionLocations: [Swift.String]? = nil,
                Path: Swift.String? = nil,
                EnableMediaSourceDisplay: Swift.Bool? = nil,
                OfficialRating: Swift.String? = nil,
                CustomRating: Swift.String? = nil,
                ChannelId: Swift.String? = nil,
                ChannelName: Swift.String? = nil,
                Overview: Swift.String? = nil,
                Taglines: [Swift.String]? = nil,
                Genres: [Swift.String]? = nil,
                CommunityRating: Swift.Float? = nil,
                CumulativeRunTimeTicks: Swift.Int64? = nil,
                RunTimeTicks: Swift.Int64? = nil,
                PlayAccess: Components.Schemas.BaseItemDto.PlayAccessPayload? = nil,
                AspectRatio: Swift.String? = nil,
                ProductionYear: Swift.Int32? = nil,
                IsPlaceHolder: Swift.Bool? = nil,
                Number: Swift.String? = nil,
                ChannelNumber: Swift.String? = nil,
                IndexNumber: Swift.Int32? = nil,
                IndexNumberEnd: Swift.Int32? = nil,
                ParentIndexNumber: Swift.Int32? = nil,
                RemoteTrailers: [Components.Schemas.MediaUrl]? = nil,
                ProviderIds: Components.Schemas.BaseItemDto.ProviderIdsPayload? = nil,
                IsHD: Swift.Bool? = nil,
                IsFolder: Swift.Bool? = nil,
                ParentId: Swift.String? = nil,
                _Type: Components.Schemas.BaseItemDto._TypePayload? = nil,
                People: [Components.Schemas.BaseItemPerson]? = nil,
                Studios: [Components.Schemas.NameGuidPair]? = nil,
                GenreItems: [Components.Schemas.NameGuidPair]? = nil,
                ParentLogoItemId: Swift.String? = nil,
                ParentBackdropItemId: Swift.String? = nil,
                ParentBackdropImageTags: [Swift.String]? = nil,
                LocalTrailerCount: Swift.Int32? = nil,
                UserData: Components.Schemas.BaseItemDto.UserDataPayload? = nil,
                RecursiveItemCount: Swift.Int32? = nil,
                ChildCount: Swift.Int32? = nil,
                SeriesName: Swift.String? = nil,
                SeriesId: Swift.String? = nil,
                SeasonId: Swift.String? = nil,
                SpecialFeatureCount: Swift.Int32? = nil,
                DisplayPreferencesId: Swift.String? = nil,
                Status: Swift.String? = nil,
                AirTime: Swift.String? = nil,
                AirDays: [Components.Schemas.DayOfWeek]? = nil,
                Tags: [Swift.String]? = nil,
                PrimaryImageAspectRatio: Swift.Double? = nil,
                Artists: [Swift.String]? = nil,
                ArtistItems: [Components.Schemas.NameGuidPair]? = nil,
                Album: Swift.String? = nil,
                CollectionType: Components.Schemas.BaseItemDto.CollectionTypePayload? = nil,
                DisplayOrder: Swift.String? = nil,
                AlbumId: Swift.String? = nil,
                AlbumPrimaryImageTag: Swift.String? = nil,
                SeriesPrimaryImageTag: Swift.String? = nil,
                AlbumArtist: Swift.String? = nil,
                AlbumArtists: [Components.Schemas.NameGuidPair]? = nil,
                SeasonName: Swift.String? = nil,
                MediaStreams: [Components.Schemas.MediaStream]? = nil,
                VideoType: Components.Schemas.BaseItemDto.VideoTypePayload? = nil,
                PartCount: Swift.Int32? = nil,
                MediaSourceCount: Swift.Int32? = nil,
                ImageTags: Components.Schemas.BaseItemDto.ImageTagsPayload? = nil,
                BackdropImageTags: [Swift.String]? = nil,
                ScreenshotImageTags: [Swift.String]? = nil,
                ParentLogoImageTag: Swift.String? = nil,
                ParentArtItemId: Swift.String? = nil,
                ParentArtImageTag: Swift.String? = nil,
                SeriesThumbImageTag: Swift.String? = nil,
                ImageBlurHashes: Components.Schemas.BaseItemDto.ImageBlurHashesPayload? = nil,
                SeriesStudio: Swift.String? = nil,
                ParentThumbItemId: Swift.String? = nil,
                ParentThumbImageTag: Swift.String? = nil,
                ParentPrimaryImageItemId: Swift.String? = nil,
                ParentPrimaryImageTag: Swift.String? = nil,
                Chapters: [Components.Schemas.ChapterInfo]? = nil,
                Trickplay: Components.Schemas.BaseItemDto.TrickplayPayload? = nil,
                LocationType: Components.Schemas.BaseItemDto.LocationTypePayload? = nil,
                IsoType: Components.Schemas.BaseItemDto.IsoTypePayload? = nil,
                MediaType: Components.Schemas.BaseItemDto.MediaTypePayload? = nil,
                EndDate: Foundation.Date? = nil,
                LockedFields: [Components.Schemas.MetadataField]? = nil,
                TrailerCount: Swift.Int32? = nil,
                MovieCount: Swift.Int32? = nil,
                SeriesCount: Swift.Int32? = nil,
                ProgramCount: Swift.Int32? = nil,
                EpisodeCount: Swift.Int32? = nil,
                SongCount: Swift.Int32? = nil,
                AlbumCount: Swift.Int32? = nil,
                ArtistCount: Swift.Int32? = nil,
                MusicVideoCount: Swift.Int32? = nil,
                LockData: Swift.Bool? = nil,
                Width: Swift.Int32? = nil,
                Height: Swift.Int32? = nil,
                CameraMake: Swift.String? = nil,
                CameraModel: Swift.String? = nil,
                Software: Swift.String? = nil,
                ExposureTime: Swift.Double? = nil,
                FocalLength: Swift.Double? = nil,
                ImageOrientation: Components.Schemas.BaseItemDto.ImageOrientationPayload? = nil,
                Aperture: Swift.Double? = nil,
                ShutterSpeed: Swift.Double? = nil,
                Latitude: Swift.Double? = nil,
                Longitude: Swift.Double? = nil,
                Altitude: Swift.Double? = nil,
                IsoSpeedRating: Swift.Int32? = nil,
                SeriesTimerId: Swift.String? = nil,
                ProgramId: Swift.String? = nil,
                ChannelPrimaryImageTag: Swift.String? = nil,
                StartDate: Foundation.Date? = nil,
                CompletionPercentage: Swift.Double? = nil,
                IsRepeat: Swift.Bool? = nil,
                EpisodeTitle: Swift.String? = nil,
                ChannelType: Components.Schemas.BaseItemDto.ChannelTypePayload? = nil,
                Audio: Components.Schemas.BaseItemDto.AudioPayload? = nil,
                IsMovie: Swift.Bool? = nil,
                IsSports: Swift.Bool? = nil,
                IsSeries: Swift.Bool? = nil,
                IsLive: Swift.Bool? = nil,
                IsNews: Swift.Bool? = nil,
                IsKids: Swift.Bool? = nil,
                IsPremiere: Swift.Bool? = nil,
                TimerId: Swift.String? = nil,
                NormalizationGain: Swift.Float? = nil,
                CurrentProgram: Components.Schemas.BaseItemDto.CurrentProgramPayload? = nil
            ) {
                storage = .init(value: .init(
                    Name: Name,
                    OriginalTitle: OriginalTitle,
                    ServerId: ServerId,
                    Id: Id,
                    Etag: Etag,
                    SourceType: SourceType,
                    PlaylistItemId: PlaylistItemId,
                    DateCreated: DateCreated,
                    DateLastMediaAdded: DateLastMediaAdded,
                    ExtraType: ExtraType,
                    AirsBeforeSeasonNumber: AirsBeforeSeasonNumber,
                    AirsAfterSeasonNumber: AirsAfterSeasonNumber,
                    AirsBeforeEpisodeNumber: AirsBeforeEpisodeNumber,
                    CanDelete: CanDelete,
                    CanDownload: CanDownload,
                    HasLyrics: HasLyrics,
                    HasSubtitles: HasSubtitles,
                    PreferredMetadataLanguage: PreferredMetadataLanguage,
                    PreferredMetadataCountryCode: PreferredMetadataCountryCode,
                    Container: Container,
                    SortName: SortName,
                    ForcedSortName: ForcedSortName,
                    Video3DFormat: Video3DFormat,
                    PremiereDate: PremiereDate,
                    ExternalUrls: ExternalUrls,
                    MediaSources: MediaSources,
                    CriticRating: CriticRating,
                    ProductionLocations: ProductionLocations,
                    Path: Path,
                    EnableMediaSourceDisplay: EnableMediaSourceDisplay,
                    OfficialRating: OfficialRating,
                    CustomRating: CustomRating,
                    ChannelId: ChannelId,
                    ChannelName: ChannelName,
                    Overview: Overview,
                    Taglines: Taglines,
                    Genres: Genres,
                    CommunityRating: CommunityRating,
                    CumulativeRunTimeTicks: CumulativeRunTimeTicks,
                    RunTimeTicks: RunTimeTicks,
                    PlayAccess: PlayAccess,
                    AspectRatio: AspectRatio,
                    ProductionYear: ProductionYear,
                    IsPlaceHolder: IsPlaceHolder,
                    Number: Number,
                    ChannelNumber: ChannelNumber,
                    IndexNumber: IndexNumber,
                    IndexNumberEnd: IndexNumberEnd,
                    ParentIndexNumber: ParentIndexNumber,
                    RemoteTrailers: RemoteTrailers,
                    ProviderIds: ProviderIds,
                    IsHD: IsHD,
                    IsFolder: IsFolder,
                    ParentId: ParentId,
                    _Type: _Type,
                    People: People,
                    Studios: Studios,
                    GenreItems: GenreItems,
                    ParentLogoItemId: ParentLogoItemId,
                    ParentBackdropItemId: ParentBackdropItemId,
                    ParentBackdropImageTags: ParentBackdropImageTags,
                    LocalTrailerCount: LocalTrailerCount,
                    UserData: UserData,
                    RecursiveItemCount: RecursiveItemCount,
                    ChildCount: ChildCount,
                    SeriesName: SeriesName,
                    SeriesId: SeriesId,
                    SeasonId: SeasonId,
                    SpecialFeatureCount: SpecialFeatureCount,
                    DisplayPreferencesId: DisplayPreferencesId,
                    Status: Status,
                    AirTime: AirTime,
                    AirDays: AirDays,
                    Tags: Tags,
                    PrimaryImageAspectRatio: PrimaryImageAspectRatio,
                    Artists: Artists,
                    ArtistItems: ArtistItems,
                    Album: Album,
                    CollectionType: CollectionType,
                    DisplayOrder: DisplayOrder,
                    AlbumId: AlbumId,
                    AlbumPrimaryImageTag: AlbumPrimaryImageTag,
                    SeriesPrimaryImageTag: SeriesPrimaryImageTag,
                    AlbumArtist: AlbumArtist,
                    AlbumArtists: AlbumArtists,
                    SeasonName: SeasonName,
                    MediaStreams: MediaStreams,
                    VideoType: VideoType,
                    PartCount: PartCount,
                    MediaSourceCount: MediaSourceCount,
                    ImageTags: ImageTags,
                    BackdropImageTags: BackdropImageTags,
                    ScreenshotImageTags: ScreenshotImageTags,
                    ParentLogoImageTag: ParentLogoImageTag,
                    ParentArtItemId: ParentArtItemId,
                    ParentArtImageTag: ParentArtImageTag,
                    SeriesThumbImageTag: SeriesThumbImageTag,
                    ImageBlurHashes: ImageBlurHashes,
                    SeriesStudio: SeriesStudio,
                    ParentThumbItemId: ParentThumbItemId,
                    ParentThumbImageTag: ParentThumbImageTag,
                    ParentPrimaryImageItemId: ParentPrimaryImageItemId,
                    ParentPrimaryImageTag: ParentPrimaryImageTag,
                    Chapters: Chapters,
                    Trickplay: Trickplay,
                    LocationType: LocationType,
                    IsoType: IsoType,
                    MediaType: MediaType,
                    EndDate: EndDate,
                    LockedFields: LockedFields,
                    TrailerCount: TrailerCount,
                    MovieCount: MovieCount,
                    SeriesCount: SeriesCount,
                    ProgramCount: ProgramCount,
                    EpisodeCount: EpisodeCount,
                    SongCount: SongCount,
                    AlbumCount: AlbumCount,
                    ArtistCount: ArtistCount,
                    MusicVideoCount: MusicVideoCount,
                    LockData: LockData,
                    Width: Width,
                    Height: Height,
                    CameraMake: CameraMake,
                    CameraModel: CameraModel,
                    Software: Software,
                    ExposureTime: ExposureTime,
                    FocalLength: FocalLength,
                    ImageOrientation: ImageOrientation,
                    Aperture: Aperture,
                    ShutterSpeed: ShutterSpeed,
                    Latitude: Latitude,
                    Longitude: Longitude,
                    Altitude: Altitude,
                    IsoSpeedRating: IsoSpeedRating,
                    SeriesTimerId: SeriesTimerId,
                    ProgramId: ProgramId,
                    ChannelPrimaryImageTag: ChannelPrimaryImageTag,
                    StartDate: StartDate,
                    CompletionPercentage: CompletionPercentage,
                    IsRepeat: IsRepeat,
                    EpisodeTitle: EpisodeTitle,
                    ChannelType: ChannelType,
                    Audio: Audio,
                    IsMovie: IsMovie,
                    IsSports: IsSports,
                    IsSeries: IsSeries,
                    IsLive: IsLive,
                    IsNews: IsNews,
                    IsKids: IsKids,
                    IsPremiere: IsPremiere,
                    TimerId: TimerId,
                    NormalizationGain: NormalizationGain,
                    CurrentProgram: CurrentProgram
                ))
            }
            public enum CodingKeys: String, CodingKey {
                case Name
                case OriginalTitle
                case ServerId
                case Id
                case Etag
                case SourceType
                case PlaylistItemId
                case DateCreated
                case DateLastMediaAdded
                case ExtraType
                case AirsBeforeSeasonNumber
                case AirsAfterSeasonNumber
                case AirsBeforeEpisodeNumber
                case CanDelete
                case CanDownload
                case HasLyrics
                case HasSubtitles
                case PreferredMetadataLanguage
                case PreferredMetadataCountryCode
                case Container
                case SortName
                case ForcedSortName
                case Video3DFormat
                case PremiereDate
                case ExternalUrls
                case MediaSources
                case CriticRating
                case ProductionLocations
                case Path
                case EnableMediaSourceDisplay
                case OfficialRating
                case CustomRating
                case ChannelId
                case ChannelName
                case Overview
                case Taglines
                case Genres
                case CommunityRating
                case CumulativeRunTimeTicks
                case RunTimeTicks
                case PlayAccess
                case AspectRatio
                case ProductionYear
                case IsPlaceHolder
                case Number
                case ChannelNumber
                case IndexNumber
                case IndexNumberEnd
                case ParentIndexNumber
                case RemoteTrailers
                case ProviderIds
                case IsHD
                case IsFolder
                case ParentId
                case _Type = "Type"
                case People
                case Studios
                case GenreItems
                case ParentLogoItemId
                case ParentBackdropItemId
                case ParentBackdropImageTags
                case LocalTrailerCount
                case UserData
                case RecursiveItemCount
                case ChildCount
                case SeriesName
                case SeriesId
                case SeasonId
                case SpecialFeatureCount
                case DisplayPreferencesId
                case Status
                case AirTime
                case AirDays
                case Tags
                case PrimaryImageAspectRatio
                case Artists
                case ArtistItems
                case Album
                case CollectionType
                case DisplayOrder
                case AlbumId
                case AlbumPrimaryImageTag
                case SeriesPrimaryImageTag
                case AlbumArtist
                case AlbumArtists
                case SeasonName
                case MediaStreams
                case VideoType
                case PartCount
                case MediaSourceCount
                case ImageTags
                case BackdropImageTags
                case ScreenshotImageTags
                case ParentLogoImageTag
                case ParentArtItemId
                case ParentArtImageTag
                case SeriesThumbImageTag
                case ImageBlurHashes
                case SeriesStudio
                case ParentThumbItemId
                case ParentThumbImageTag
                case ParentPrimaryImageItemId
                case ParentPrimaryImageTag
                case Chapters
                case Trickplay
                case LocationType
                case IsoType
                case MediaType
                case EndDate
                case LockedFields
                case TrailerCount
                case MovieCount
                case SeriesCount
                case ProgramCount
                case EpisodeCount
                case SongCount
                case AlbumCount
                case ArtistCount
                case MusicVideoCount
                case LockData
                case Width
                case Height
                case CameraMake
                case CameraModel
                case Software
                case ExposureTime
                case FocalLength
                case ImageOrientation
                case Aperture
                case ShutterSpeed
                case Latitude
                case Longitude
                case Altitude
                case IsoSpeedRating
                case SeriesTimerId
                case ProgramId
                case ChannelPrimaryImageTag
                case StartDate
                case CompletionPercentage
                case IsRepeat
                case EpisodeTitle
                case ChannelType
                case Audio
                case IsMovie
                case IsSports
                case IsSeries
                case IsLive
                case IsNews
                case IsKids
                case IsPremiere
                case TimerId
                case NormalizationGain
                case CurrentProgram
            }
            public init(from decoder: any Decoder) throws {
                storage = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try storage.encode(to: encoder)
            }
            /// Internal reference storage to allow type recursion.
            private var storage: OpenAPIRuntime.CopyOnWriteBox<Storage>
            private struct Storage: Codable, Hashable, Sendable {
                /// Gets or sets the name.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Name`.
                var Name: Swift.String?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/OriginalTitle`.
                var OriginalTitle: Swift.String?
                /// Gets or sets the server identifier.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ServerId`.
                var ServerId: Swift.String?
                /// Gets or sets the id.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Id`.
                var Id: Swift.String?
                /// Gets or sets the etag.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Etag`.
                var Etag: Swift.String?
                /// Gets or sets the type of the source.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/SourceType`.
                var SourceType: Swift.String?
                /// Gets or sets the playlist item identifier.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/PlaylistItemId`.
                var PlaylistItemId: Swift.String?
                /// Gets or sets the date created.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/DateCreated`.
                var DateCreated: Foundation.Date?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/DateLastMediaAdded`.
                var DateLastMediaAdded: Foundation.Date?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ExtraType`.
                struct ExtraTypePayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ExtraType/value1`.
                    public var value1: Components.Schemas.ExtraType
                    /// Creates a new `ExtraTypePayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.ExtraType) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try decoder.decodeFromSingleValueContainer()
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeToSingleValueContainer(value1)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ExtraType`.
                var ExtraType: Components.Schemas.BaseItemDto.ExtraTypePayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/AirsBeforeSeasonNumber`.
                var AirsBeforeSeasonNumber: Swift.Int32?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/AirsAfterSeasonNumber`.
                var AirsAfterSeasonNumber: Swift.Int32?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/AirsBeforeEpisodeNumber`.
                var AirsBeforeEpisodeNumber: Swift.Int32?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/CanDelete`.
                var CanDelete: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/CanDownload`.
                var CanDownload: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/HasLyrics`.
                var HasLyrics: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/HasSubtitles`.
                var HasSubtitles: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/PreferredMetadataLanguage`.
                var PreferredMetadataLanguage: Swift.String?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/PreferredMetadataCountryCode`.
                var PreferredMetadataCountryCode: Swift.String?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Container`.
                var Container: Swift.String?
                /// Gets or sets the name of the sort.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/SortName`.
                var SortName: Swift.String?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ForcedSortName`.
                var ForcedSortName: Swift.String?
                /// Gets or sets the video3 D format.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Video3DFormat`.
                struct Video3DFormatPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/Video3DFormat/value1`.
                    public var value1: Components.Schemas.Video3DFormat
                    /// Creates a new `Video3DFormatPayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.Video3DFormat) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try decoder.decodeFromSingleValueContainer()
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeToSingleValueContainer(value1)
                    }
                }
                /// Gets or sets the video3 D format.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Video3DFormat`.
                var Video3DFormat: Components.Schemas.BaseItemDto.Video3DFormatPayload?
                /// Gets or sets the premiere date.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/PremiereDate`.
                var PremiereDate: Foundation.Date?
                /// Gets or sets the external urls.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ExternalUrls`.
                var ExternalUrls: [Components.Schemas.ExternalUrl]?
                /// Gets or sets the media versions.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/MediaSources`.
                var MediaSources: [Components.Schemas.MediaSourceInfo]?
                /// Gets or sets the critic rating.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/CriticRating`.
                var CriticRating: Swift.Float?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ProductionLocations`.
                var ProductionLocations: [Swift.String]?
                /// Gets or sets the path.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Path`.
                var Path: Swift.String?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/EnableMediaSourceDisplay`.
                var EnableMediaSourceDisplay: Swift.Bool?
                /// Gets or sets the official rating.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/OfficialRating`.
                var OfficialRating: Swift.String?
                /// Gets or sets the custom rating.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/CustomRating`.
                var CustomRating: Swift.String?
                /// Gets or sets the channel identifier.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ChannelId`.
                var ChannelId: Swift.String?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ChannelName`.
                var ChannelName: Swift.String?
                /// Gets or sets the overview.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Overview`.
                var Overview: Swift.String?
                /// Gets or sets the taglines.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Taglines`.
                var Taglines: [Swift.String]?
                /// Gets or sets the genres.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Genres`.
                var Genres: [Swift.String]?
                /// Gets or sets the community rating.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/CommunityRating`.
                var CommunityRating: Swift.Float?
                /// Gets or sets the cumulative run time ticks.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/CumulativeRunTimeTicks`.
                var CumulativeRunTimeTicks: Swift.Int64?
                /// Gets or sets the run time ticks.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/RunTimeTicks`.
                var RunTimeTicks: Swift.Int64?
                /// Gets or sets the play access.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/PlayAccess`.
                struct PlayAccessPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/PlayAccess/value1`.
                    public var value1: Components.Schemas.PlayAccess
                    /// Creates a new `PlayAccessPayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.PlayAccess) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try decoder.decodeFromSingleValueContainer()
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeToSingleValueContainer(value1)
                    }
                }
                /// Gets or sets the play access.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/PlayAccess`.
                var PlayAccess: Components.Schemas.BaseItemDto.PlayAccessPayload?
                /// Gets or sets the aspect ratio.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/AspectRatio`.
                var AspectRatio: Swift.String?
                /// Gets or sets the production year.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ProductionYear`.
                var ProductionYear: Swift.Int32?
                /// Gets or sets a value indicating whether this instance is place holder.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsPlaceHolder`.
                var IsPlaceHolder: Swift.Bool?
                /// Gets or sets the number.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Number`.
                var Number: Swift.String?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ChannelNumber`.
                var ChannelNumber: Swift.String?
                /// Gets or sets the index number.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IndexNumber`.
                var IndexNumber: Swift.Int32?
                /// Gets or sets the index number end.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IndexNumberEnd`.
                var IndexNumberEnd: Swift.Int32?
                /// Gets or sets the parent index number.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentIndexNumber`.
                var ParentIndexNumber: Swift.Int32?
                /// Gets or sets the trailer urls.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/RemoteTrailers`.
                var RemoteTrailers: [Components.Schemas.MediaUrl]?
                /// Gets or sets the provider ids.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ProviderIds`.
                struct ProviderIdsPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String?]
                    /// Creates a new `ProviderIdsPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String?] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// Gets or sets the provider ids.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ProviderIds`.
                var ProviderIds: Components.Schemas.BaseItemDto.ProviderIdsPayload?
                /// Gets or sets a value indicating whether this instance is HD.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsHD`.
                var IsHD: Swift.Bool?
                /// Gets or sets a value indicating whether this instance is folder.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsFolder`.
                var IsFolder: Swift.Bool?
                /// Gets or sets the parent id.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentId`.
                var ParentId: Swift.String?
                /// The base item kind.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Type`.
                struct _TypePayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/Type/value1`.
                    public var value1: Components.Schemas.BaseItemKind
                    /// Creates a new `_TypePayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.BaseItemKind) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try decoder.decodeFromSingleValueContainer()
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeToSingleValueContainer(value1)
                    }
                }
                /// The base item kind.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Type`.
                var _Type: Components.Schemas.BaseItemDto._TypePayload?
                /// Gets or sets the people.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/People`.
                var People: [Components.Schemas.BaseItemPerson]?
                /// Gets or sets the studios.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Studios`.
                var Studios: [Components.Schemas.NameGuidPair]?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/GenreItems`.
                var GenreItems: [Components.Schemas.NameGuidPair]?
                /// Gets or sets whether the item has a logo, this will hold the Id of the Parent that has one.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentLogoItemId`.
                var ParentLogoItemId: Swift.String?
                /// Gets or sets whether the item has any backdrops, this will hold the Id of the Parent that has one.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentBackdropItemId`.
                var ParentBackdropItemId: Swift.String?
                /// Gets or sets the parent backdrop image tags.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentBackdropImageTags`.
                var ParentBackdropImageTags: [Swift.String]?
                /// Gets or sets the local trailer count.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/LocalTrailerCount`.
                var LocalTrailerCount: Swift.Int32?
                /// Gets or sets the user data for this item based on the user it's being requested for.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/UserData`.
                struct UserDataPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/UserData/value1`.
                    public var value1: Components.Schemas.UserItemDataDto
                    /// Creates a new `UserDataPayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.UserItemDataDto) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try .init(from: decoder)
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try value1.encode(to: encoder)
                    }
                }
                /// Gets or sets the user data for this item based on the user it's being requested for.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/UserData`.
                var UserData: Components.Schemas.BaseItemDto.UserDataPayload?
                /// Gets or sets the recursive item count.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/RecursiveItemCount`.
                var RecursiveItemCount: Swift.Int32?
                /// Gets or sets the child count.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ChildCount`.
                var ChildCount: Swift.Int32?
                /// Gets or sets the name of the series.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeriesName`.
                var SeriesName: Swift.String?
                /// Gets or sets the series id.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeriesId`.
                var SeriesId: Swift.String?
                /// Gets or sets the season identifier.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeasonId`.
                var SeasonId: Swift.String?
                /// Gets or sets the special feature count.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/SpecialFeatureCount`.
                var SpecialFeatureCount: Swift.Int32?
                /// Gets or sets the display preferences id.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/DisplayPreferencesId`.
                var DisplayPreferencesId: Swift.String?
                /// Gets or sets the status.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Status`.
                var Status: Swift.String?
                /// Gets or sets the air time.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/AirTime`.
                var AirTime: Swift.String?
                /// Gets or sets the air days.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/AirDays`.
                var AirDays: [Components.Schemas.DayOfWeek]?
                /// Gets or sets the tags.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Tags`.
                var Tags: [Swift.String]?
                /// Gets or sets the primary image aspect ratio, after image enhancements.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/PrimaryImageAspectRatio`.
                var PrimaryImageAspectRatio: Swift.Double?
                /// Gets or sets the artists.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Artists`.
                var Artists: [Swift.String]?
                /// Gets or sets the artist items.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ArtistItems`.
                var ArtistItems: [Components.Schemas.NameGuidPair]?
                /// Gets or sets the album.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Album`.
                var Album: Swift.String?
                /// Gets or sets the type of the collection.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/CollectionType`.
                struct CollectionTypePayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/CollectionType/value1`.
                    public var value1: Components.Schemas.CollectionType
                    /// Creates a new `CollectionTypePayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.CollectionType) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try decoder.decodeFromSingleValueContainer()
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeToSingleValueContainer(value1)
                    }
                }
                /// Gets or sets the type of the collection.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/CollectionType`.
                var CollectionType: Components.Schemas.BaseItemDto.CollectionTypePayload?
                /// Gets or sets the display order.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/DisplayOrder`.
                var DisplayOrder: Swift.String?
                /// Gets or sets the album id.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/AlbumId`.
                var AlbumId: Swift.String?
                /// Gets or sets the album image tag.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/AlbumPrimaryImageTag`.
                var AlbumPrimaryImageTag: Swift.String?
                /// Gets or sets the series primary image tag.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeriesPrimaryImageTag`.
                var SeriesPrimaryImageTag: Swift.String?
                /// Gets or sets the album artist.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/AlbumArtist`.
                var AlbumArtist: Swift.String?
                /// Gets or sets the album artists.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/AlbumArtists`.
                var AlbumArtists: [Components.Schemas.NameGuidPair]?
                /// Gets or sets the name of the season.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeasonName`.
                var SeasonName: Swift.String?
                /// Gets or sets the media streams.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/MediaStreams`.
                var MediaStreams: [Components.Schemas.MediaStream]?
                /// Gets or sets the type of the video.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/VideoType`.
                struct VideoTypePayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/VideoType/value1`.
                    public var value1: Components.Schemas.VideoType
                    /// Creates a new `VideoTypePayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.VideoType) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try decoder.decodeFromSingleValueContainer()
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeToSingleValueContainer(value1)
                    }
                }
                /// Gets or sets the type of the video.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/VideoType`.
                var VideoType: Components.Schemas.BaseItemDto.VideoTypePayload?
                /// Gets or sets the part count.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/PartCount`.
                var PartCount: Swift.Int32?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/MediaSourceCount`.
                var MediaSourceCount: Swift.Int32?
                /// Gets or sets the image tags.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageTags`.
                struct ImageTagsPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `ImageTagsPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// Gets or sets the image tags.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageTags`.
                var ImageTags: Components.Schemas.BaseItemDto.ImageTagsPayload?
                /// Gets or sets the backdrop image tags.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/BackdropImageTags`.
                var BackdropImageTags: [Swift.String]?
                /// Gets or sets the screenshot image tags.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ScreenshotImageTags`.
                var ScreenshotImageTags: [Swift.String]?
                /// Gets or sets the parent logo image tag.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentLogoImageTag`.
                var ParentLogoImageTag: Swift.String?
                /// Gets or sets whether the item has fan art, this will hold the Id of the Parent that has one.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentArtItemId`.
                var ParentArtItemId: Swift.String?
                /// Gets or sets the parent art image tag.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentArtImageTag`.
                var ParentArtImageTag: Swift.String?
                /// Gets or sets the series thumb image tag.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeriesThumbImageTag`.
                var SeriesThumbImageTag: Swift.String?
                /// Gets or sets the blurhashes for the image tags.
                /// Maps image type to dictionary mapping image tag to blurhash value.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes`.
                struct ImageBlurHashesPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Primary`.
                    public struct PrimaryPayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: [String: Swift.String]
                        /// Creates a new `PrimaryPayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: [String: Swift.String] = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Primary`.
                    public var Primary: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.PrimaryPayload?
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Art`.
                    public struct ArtPayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: [String: Swift.String]
                        /// Creates a new `ArtPayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: [String: Swift.String] = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Art`.
                    public var Art: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ArtPayload?
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Backdrop`.
                    public struct BackdropPayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: [String: Swift.String]
                        /// Creates a new `BackdropPayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: [String: Swift.String] = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Backdrop`.
                    public var Backdrop: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.BackdropPayload?
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Banner`.
                    public struct BannerPayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: [String: Swift.String]
                        /// Creates a new `BannerPayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: [String: Swift.String] = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Banner`.
                    public var Banner: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.BannerPayload?
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Logo`.
                    public struct LogoPayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: [String: Swift.String]
                        /// Creates a new `LogoPayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: [String: Swift.String] = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Logo`.
                    public var Logo: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.LogoPayload?
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Thumb`.
                    public struct ThumbPayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: [String: Swift.String]
                        /// Creates a new `ThumbPayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: [String: Swift.String] = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Thumb`.
                    public var Thumb: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ThumbPayload?
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Disc`.
                    public struct DiscPayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: [String: Swift.String]
                        /// Creates a new `DiscPayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: [String: Swift.String] = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Disc`.
                    public var Disc: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.DiscPayload?
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Box`.
                    public struct BoxPayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: [String: Swift.String]
                        /// Creates a new `BoxPayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: [String: Swift.String] = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Box`.
                    public var Box: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.BoxPayload?
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Screenshot`.
                    public struct ScreenshotPayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: [String: Swift.String]
                        /// Creates a new `ScreenshotPayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: [String: Swift.String] = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Screenshot`.
                    public var Screenshot: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ScreenshotPayload?
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Menu`.
                    public struct MenuPayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: [String: Swift.String]
                        /// Creates a new `MenuPayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: [String: Swift.String] = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Menu`.
                    public var Menu: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.MenuPayload?
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Chapter`.
                    public struct ChapterPayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: [String: Swift.String]
                        /// Creates a new `ChapterPayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: [String: Swift.String] = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Chapter`.
                    public var Chapter: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ChapterPayload?
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/BoxRear`.
                    public struct BoxRearPayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: [String: Swift.String]
                        /// Creates a new `BoxRearPayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: [String: Swift.String] = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/BoxRear`.
                    public var BoxRear: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.BoxRearPayload?
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Profile`.
                    public struct ProfilePayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: [String: Swift.String]
                        /// Creates a new `ProfilePayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: [String: Swift.String] = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes/Profile`.
                    public var Profile: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ProfilePayload?
                    /// Creates a new `ImageBlurHashesPayload`.
                    ///
                    /// - Parameters:
                    ///   - Primary:
                    ///   - Art:
                    ///   - Backdrop:
                    ///   - Banner:
                    ///   - Logo:
                    ///   - Thumb:
                    ///   - Disc:
                    ///   - Box:
                    ///   - Screenshot:
                    ///   - Menu:
                    ///   - Chapter:
                    ///   - BoxRear:
                    ///   - Profile:
                    public init(
                        Primary: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.PrimaryPayload? = nil,
                        Art: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ArtPayload? = nil,
                        Backdrop: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.BackdropPayload? = nil,
                        Banner: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.BannerPayload? = nil,
                        Logo: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.LogoPayload? = nil,
                        Thumb: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ThumbPayload? = nil,
                        Disc: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.DiscPayload? = nil,
                        Box: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.BoxPayload? = nil,
                        Screenshot: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ScreenshotPayload? = nil,
                        Menu: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.MenuPayload? = nil,
                        Chapter: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ChapterPayload? = nil,
                        BoxRear: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.BoxRearPayload? = nil,
                        Profile: Components.Schemas.BaseItemDto.ImageBlurHashesPayload.ProfilePayload? = nil
                    ) {
                        self.Primary = Primary
                        self.Art = Art
                        self.Backdrop = Backdrop
                        self.Banner = Banner
                        self.Logo = Logo
                        self.Thumb = Thumb
                        self.Disc = Disc
                        self.Box = Box
                        self.Screenshot = Screenshot
                        self.Menu = Menu
                        self.Chapter = Chapter
                        self.BoxRear = BoxRear
                        self.Profile = Profile
                    }
                    public enum CodingKeys: String, CodingKey {
                        case Primary
                        case Art
                        case Backdrop
                        case Banner
                        case Logo
                        case Thumb
                        case Disc
                        case Box
                        case Screenshot
                        case Menu
                        case Chapter
                        case BoxRear
                        case Profile
                    }
                }
                /// Gets or sets the blurhashes for the image tags.
                /// Maps image type to dictionary mapping image tag to blurhash value.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageBlurHashes`.
                var ImageBlurHashes: Components.Schemas.BaseItemDto.ImageBlurHashesPayload?
                /// Gets or sets the series studio.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeriesStudio`.
                var SeriesStudio: Swift.String?
                /// Gets or sets the parent thumb item id.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentThumbItemId`.
                var ParentThumbItemId: Swift.String?
                /// Gets or sets the parent thumb image tag.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentThumbImageTag`.
                var ParentThumbImageTag: Swift.String?
                /// Gets or sets the parent primary image item identifier.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentPrimaryImageItemId`.
                var ParentPrimaryImageItemId: Swift.String?
                /// Gets or sets the parent primary image tag.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ParentPrimaryImageTag`.
                var ParentPrimaryImageTag: Swift.String?
                /// Gets or sets the chapters.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Chapters`.
                var Chapters: [Components.Schemas.ChapterInfo]?
                /// Gets or sets the trickplay manifest.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Trickplay`.
                struct TrickplayPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/Trickplay/additionalProperties`.
                    public struct additionalPropertiesPayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: [String: Components.Schemas.TrickplayInfo]
                        /// Creates a new `additionalPropertiesPayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: [String: Components.Schemas.TrickplayInfo] = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Components.Schemas.BaseItemDto.TrickplayPayload.additionalPropertiesPayload]
                    /// Creates a new `TrickplayPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Components.Schemas.BaseItemDto.TrickplayPayload.additionalPropertiesPayload] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// Gets or sets the trickplay manifest.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Trickplay`.
                var Trickplay: Components.Schemas.BaseItemDto.TrickplayPayload?
                /// Gets or sets the type of the location.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/LocationType`.
                struct LocationTypePayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/LocationType/value1`.
                    public var value1: Components.Schemas.LocationType
                    /// Creates a new `LocationTypePayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.LocationType) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try decoder.decodeFromSingleValueContainer()
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeToSingleValueContainer(value1)
                    }
                }
                /// Gets or sets the type of the location.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/LocationType`.
                var LocationType: Components.Schemas.BaseItemDto.LocationTypePayload?
                /// Gets or sets the type of the iso.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsoType`.
                struct IsoTypePayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsoType/value1`.
                    public var value1: Components.Schemas.IsoType
                    /// Creates a new `IsoTypePayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.IsoType) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try decoder.decodeFromSingleValueContainer()
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeToSingleValueContainer(value1)
                    }
                }
                /// Gets or sets the type of the iso.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsoType`.
                var IsoType: Components.Schemas.BaseItemDto.IsoTypePayload?
                /// Media types.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/MediaType`.
                struct MediaTypePayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/MediaType/value1`.
                    public var value1: Components.Schemas.MediaType
                    /// Creates a new `MediaTypePayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.MediaType) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try decoder.decodeFromSingleValueContainer()
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeToSingleValueContainer(value1)
                    }
                }
                /// Media types.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/MediaType`.
                var MediaType: Components.Schemas.BaseItemDto.MediaTypePayload?
                /// Gets or sets the end date.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/EndDate`.
                var EndDate: Foundation.Date?
                /// Gets or sets the locked fields.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/LockedFields`.
                var LockedFields: [Components.Schemas.MetadataField]?
                /// Gets or sets the trailer count.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/TrailerCount`.
                var TrailerCount: Swift.Int32?
                /// Gets or sets the movie count.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/MovieCount`.
                var MovieCount: Swift.Int32?
                /// Gets or sets the series count.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeriesCount`.
                var SeriesCount: Swift.Int32?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ProgramCount`.
                var ProgramCount: Swift.Int32?
                /// Gets or sets the episode count.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/EpisodeCount`.
                var EpisodeCount: Swift.Int32?
                /// Gets or sets the song count.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/SongCount`.
                var SongCount: Swift.Int32?
                /// Gets or sets the album count.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/AlbumCount`.
                var AlbumCount: Swift.Int32?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ArtistCount`.
                var ArtistCount: Swift.Int32?
                /// Gets or sets the music video count.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/MusicVideoCount`.
                var MusicVideoCount: Swift.Int32?
                /// Gets or sets a value indicating whether [enable internet providers].
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/LockData`.
                var LockData: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Width`.
                var Width: Swift.Int32?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Height`.
                var Height: Swift.Int32?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/CameraMake`.
                var CameraMake: Swift.String?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/CameraModel`.
                var CameraModel: Swift.String?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Software`.
                var Software: Swift.String?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ExposureTime`.
                var ExposureTime: Swift.Double?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/FocalLength`.
                var FocalLength: Swift.Double?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageOrientation`.
                struct ImageOrientationPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageOrientation/value1`.
                    public var value1: Components.Schemas.ImageOrientation
                    /// Creates a new `ImageOrientationPayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.ImageOrientation) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try decoder.decodeFromSingleValueContainer()
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeToSingleValueContainer(value1)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ImageOrientation`.
                var ImageOrientation: Components.Schemas.BaseItemDto.ImageOrientationPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Aperture`.
                var Aperture: Swift.Double?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ShutterSpeed`.
                var ShutterSpeed: Swift.Double?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Latitude`.
                var Latitude: Swift.Double?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Longitude`.
                var Longitude: Swift.Double?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Altitude`.
                var Altitude: Swift.Double?
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsoSpeedRating`.
                var IsoSpeedRating: Swift.Int32?
                /// Gets or sets the series timer identifier.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/SeriesTimerId`.
                var SeriesTimerId: Swift.String?
                /// Gets or sets the program identifier.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ProgramId`.
                var ProgramId: Swift.String?
                /// Gets or sets the channel primary image tag.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ChannelPrimaryImageTag`.
                var ChannelPrimaryImageTag: Swift.String?
                /// Gets or sets the start date of the recording, in UTC.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/StartDate`.
                var StartDate: Foundation.Date?
                /// Gets or sets the completion percentage.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/CompletionPercentage`.
                var CompletionPercentage: Swift.Double?
                /// Gets or sets a value indicating whether this instance is repeat.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsRepeat`.
                var IsRepeat: Swift.Bool?
                /// Gets or sets the episode title.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/EpisodeTitle`.
                var EpisodeTitle: Swift.String?
                /// Gets or sets the type of the channel.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ChannelType`.
                struct ChannelTypePayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/ChannelType/value1`.
                    public var value1: Components.Schemas.ChannelType
                    /// Creates a new `ChannelTypePayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.ChannelType) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try decoder.decodeFromSingleValueContainer()
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeToSingleValueContainer(value1)
                    }
                }
                /// Gets or sets the type of the channel.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/ChannelType`.
                var ChannelType: Components.Schemas.BaseItemDto.ChannelTypePayload?
                /// Gets or sets the audio.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Audio`.
                struct AudioPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/Audio/value1`.
                    public var value1: Components.Schemas.ProgramAudio
                    /// Creates a new `AudioPayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.ProgramAudio) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try decoder.decodeFromSingleValueContainer()
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeToSingleValueContainer(value1)
                    }
                }
                /// Gets or sets the audio.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/Audio`.
                var Audio: Components.Schemas.BaseItemDto.AudioPayload?
                /// Gets or sets a value indicating whether this instance is movie.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsMovie`.
                var IsMovie: Swift.Bool?
                /// Gets or sets a value indicating whether this instance is sports.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsSports`.
                var IsSports: Swift.Bool?
                /// Gets or sets a value indicating whether this instance is series.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsSeries`.
                var IsSeries: Swift.Bool?
                /// Gets or sets a value indicating whether this instance is live.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsLive`.
                var IsLive: Swift.Bool?
                /// Gets or sets a value indicating whether this instance is news.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsNews`.
                var IsNews: Swift.Bool?
                /// Gets or sets a value indicating whether this instance is kids.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsKids`.
                var IsKids: Swift.Bool?
                /// Gets or sets a value indicating whether this instance is premiere.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/IsPremiere`.
                var IsPremiere: Swift.Bool?
                /// Gets or sets the timer identifier.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/TimerId`.
                var TimerId: Swift.String?
                /// Gets or sets the gain required for audio normalization.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/NormalizationGain`.
                var NormalizationGain: Swift.Float?
                /// Gets or sets the current program.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/CurrentProgram`.
                struct CurrentProgramPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/BaseItemDto/CurrentProgram/value1`.
                    public var value1: Components.Schemas.BaseItemDto
                    /// Creates a new `CurrentProgramPayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.BaseItemDto) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try .init(from: decoder)
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try value1.encode(to: encoder)
                    }
                }
                /// Gets or sets the current program.
                ///
                /// - Remark: Generated from `#/components/schemas/BaseItemDto/CurrentProgram`.
                var CurrentProgram: Components.Schemas.BaseItemDto.CurrentProgramPayload?
                init(
                    Name: Swift.String? = nil,
                    OriginalTitle: Swift.String? = nil,
                    ServerId: Swift.String? = nil,
                    Id: Swift.String? = nil,
                    Etag: Swift.String? = nil,
                    SourceType: Swift.String? = nil,
                    PlaylistItemId: Swift.String? = nil,
                    DateCreated: Foundation.Date? = nil,
                    DateLastMediaAdded: Foundation.Date? = nil,
                    ExtraType: Components.Schemas.BaseItemDto.ExtraTypePayload? = nil,
                    AirsBeforeSeasonNumber: Swift.Int32? = nil,
                    AirsAfterSeasonNumber: Swift.Int32? = nil,
                    AirsBeforeEpisodeNumber: Swift.Int32? = nil,
                    CanDelete: Swift.Bool? = nil,
                    CanDownload: Swift.Bool? = nil,
                    HasLyrics: Swift.Bool? = nil,
                    HasSubtitles: Swift.Bool? = nil,
                    PreferredMetadataLanguage: Swift.String? = nil,
                    PreferredMetadataCountryCode: Swift.String? = nil,
                    Container: Swift.String? = nil,
                    SortName: Swift.String? = nil,
                    ForcedSortName: Swift.String? = nil,
                    Video3DFormat: Components.Schemas.BaseItemDto.Video3DFormatPayload? = nil,
                    PremiereDate: Foundation.Date? = nil,
                    ExternalUrls: [Components.Schemas.ExternalUrl]? = nil,
                    MediaSources: [Components.Schemas.MediaSourceInfo]? = nil,
                    CriticRating: Swift.Float? = nil,
                    ProductionLocations: [Swift.String]? = nil,
                    Path: Swift.String? = nil,
                    EnableMediaSourceDisplay: Swift.Bool? = nil,
                    OfficialRating: Swift.String? = nil,
                    CustomRating: Swift.String? = nil,
                    ChannelId: Swift.String? = nil,
                    ChannelName: Swift.String? = nil,
                    Overview: Swift.String? = nil,
                    Taglines: [Swift.String]? = nil,
                    Genres: [Swift.String]? = nil,
                    CommunityRating: Swift.Float? = nil,
                    CumulativeRunTimeTicks: Swift.Int64? = nil,
                    RunTimeTicks: Swift.Int64? = nil,
                    PlayAccess: Components.Schemas.BaseItemDto.PlayAccessPayload? = nil,
                    AspectRatio: Swift.String? = nil,
                    ProductionYear: Swift.Int32? = nil,
                    IsPlaceHolder: Swift.Bool? = nil,
                    Number: Swift.String? = nil,
                    ChannelNumber: Swift.String? = nil,
                    IndexNumber: Swift.Int32? = nil,
                    IndexNumberEnd: Swift.Int32? = nil,
                    ParentIndexNumber: Swift.Int32? = nil,
                    RemoteTrailers: [Components.Schemas.MediaUrl]? = nil,
                    ProviderIds: Components.Schemas.BaseItemDto.ProviderIdsPayload? = nil,
                    IsHD: Swift.Bool? = nil,
                    IsFolder: Swift.Bool? = nil,
                    ParentId: Swift.String? = nil,
                    _Type: Components.Schemas.BaseItemDto._TypePayload? = nil,
                    People: [Components.Schemas.BaseItemPerson]? = nil,
                    Studios: [Components.Schemas.NameGuidPair]? = nil,
                    GenreItems: [Components.Schemas.NameGuidPair]? = nil,
                    ParentLogoItemId: Swift.String? = nil,
                    ParentBackdropItemId: Swift.String? = nil,
                    ParentBackdropImageTags: [Swift.String]? = nil,
                    LocalTrailerCount: Swift.Int32? = nil,
                    UserData: Components.Schemas.BaseItemDto.UserDataPayload? = nil,
                    RecursiveItemCount: Swift.Int32? = nil,
                    ChildCount: Swift.Int32? = nil,
                    SeriesName: Swift.String? = nil,
                    SeriesId: Swift.String? = nil,
                    SeasonId: Swift.String? = nil,
                    SpecialFeatureCount: Swift.Int32? = nil,
                    DisplayPreferencesId: Swift.String? = nil,
                    Status: Swift.String? = nil,
                    AirTime: Swift.String? = nil,
                    AirDays: [Components.Schemas.DayOfWeek]? = nil,
                    Tags: [Swift.String]? = nil,
                    PrimaryImageAspectRatio: Swift.Double? = nil,
                    Artists: [Swift.String]? = nil,
                    ArtistItems: [Components.Schemas.NameGuidPair]? = nil,
                    Album: Swift.String? = nil,
                    CollectionType: Components.Schemas.BaseItemDto.CollectionTypePayload? = nil,
                    DisplayOrder: Swift.String? = nil,
                    AlbumId: Swift.String? = nil,
                    AlbumPrimaryImageTag: Swift.String? = nil,
                    SeriesPrimaryImageTag: Swift.String? = nil,
                    AlbumArtist: Swift.String? = nil,
                    AlbumArtists: [Components.Schemas.NameGuidPair]? = nil,
                    SeasonName: Swift.String? = nil,
                    MediaStreams: [Components.Schemas.MediaStream]? = nil,
                    VideoType: Components.Schemas.BaseItemDto.VideoTypePayload? = nil,
                    PartCount: Swift.Int32? = nil,
                    MediaSourceCount: Swift.Int32? = nil,
                    ImageTags: Components.Schemas.BaseItemDto.ImageTagsPayload? = nil,
                    BackdropImageTags: [Swift.String]? = nil,
                    ScreenshotImageTags: [Swift.String]? = nil,
                    ParentLogoImageTag: Swift.String? = nil,
                    ParentArtItemId: Swift.String? = nil,
                    ParentArtImageTag: Swift.String? = nil,
                    SeriesThumbImageTag: Swift.String? = nil,
                    ImageBlurHashes: Components.Schemas.BaseItemDto.ImageBlurHashesPayload? = nil,
                    SeriesStudio: Swift.String? = nil,
                    ParentThumbItemId: Swift.String? = nil,
                    ParentThumbImageTag: Swift.String? = nil,
                    ParentPrimaryImageItemId: Swift.String? = nil,
                    ParentPrimaryImageTag: Swift.String? = nil,
                    Chapters: [Components.Schemas.ChapterInfo]? = nil,
                    Trickplay: Components.Schemas.BaseItemDto.TrickplayPayload? = nil,
                    LocationType: Components.Schemas.BaseItemDto.LocationTypePayload? = nil,
                    IsoType: Components.Schemas.BaseItemDto.IsoTypePayload? = nil,
                    MediaType: Components.Schemas.BaseItemDto.MediaTypePayload? = nil,
                    EndDate: Foundation.Date? = nil,
                    LockedFields: [Components.Schemas.MetadataField]? = nil,
                    TrailerCount: Swift.Int32? = nil,
                    MovieCount: Swift.Int32? = nil,
                    SeriesCount: Swift.Int32? = nil,
                    ProgramCount: Swift.Int32? = nil,
                    EpisodeCount: Swift.Int32? = nil,
                    SongCount: Swift.Int32? = nil,
                    AlbumCount: Swift.Int32? = nil,
                    ArtistCount: Swift.Int32? = nil,
                    MusicVideoCount: Swift.Int32? = nil,
                    LockData: Swift.Bool? = nil,
                    Width: Swift.Int32? = nil,
                    Height: Swift.Int32? = nil,
                    CameraMake: Swift.String? = nil,
                    CameraModel: Swift.String? = nil,
                    Software: Swift.String? = nil,
                    ExposureTime: Swift.Double? = nil,
                    FocalLength: Swift.Double? = nil,
                    ImageOrientation: Components.Schemas.BaseItemDto.ImageOrientationPayload? = nil,
                    Aperture: Swift.Double? = nil,
                    ShutterSpeed: Swift.Double? = nil,
                    Latitude: Swift.Double? = nil,
                    Longitude: Swift.Double? = nil,
                    Altitude: Swift.Double? = nil,
                    IsoSpeedRating: Swift.Int32? = nil,
                    SeriesTimerId: Swift.String? = nil,
                    ProgramId: Swift.String? = nil,
                    ChannelPrimaryImageTag: Swift.String? = nil,
                    StartDate: Foundation.Date? = nil,
                    CompletionPercentage: Swift.Double? = nil,
                    IsRepeat: Swift.Bool? = nil,
                    EpisodeTitle: Swift.String? = nil,
                    ChannelType: Components.Schemas.BaseItemDto.ChannelTypePayload? = nil,
                    Audio: Components.Schemas.BaseItemDto.AudioPayload? = nil,
                    IsMovie: Swift.Bool? = nil,
                    IsSports: Swift.Bool? = nil,
                    IsSeries: Swift.Bool? = nil,
                    IsLive: Swift.Bool? = nil,
                    IsNews: Swift.Bool? = nil,
                    IsKids: Swift.Bool? = nil,
                    IsPremiere: Swift.Bool? = nil,
                    TimerId: Swift.String? = nil,
                    NormalizationGain: Swift.Float? = nil,
                    CurrentProgram: Components.Schemas.BaseItemDto.CurrentProgramPayload? = nil
                ) {
                    self.Name = Name
                    self.OriginalTitle = OriginalTitle
                    self.ServerId = ServerId
                    self.Id = Id
                    self.Etag = Etag
                    self.SourceType = SourceType
                    self.PlaylistItemId = PlaylistItemId
                    self.DateCreated = DateCreated
                    self.DateLastMediaAdded = DateLastMediaAdded
                    self.ExtraType = ExtraType
                    self.AirsBeforeSeasonNumber = AirsBeforeSeasonNumber
                    self.AirsAfterSeasonNumber = AirsAfterSeasonNumber
                    self.AirsBeforeEpisodeNumber = AirsBeforeEpisodeNumber
                    self.CanDelete = CanDelete
                    self.CanDownload = CanDownload
                    self.HasLyrics = HasLyrics
                    self.HasSubtitles = HasSubtitles
                    self.PreferredMetadataLanguage = PreferredMetadataLanguage
                    self.PreferredMetadataCountryCode = PreferredMetadataCountryCode
                    self.Container = Container
                    self.SortName = SortName
                    self.ForcedSortName = ForcedSortName
                    self.Video3DFormat = Video3DFormat
                    self.PremiereDate = PremiereDate
                    self.ExternalUrls = ExternalUrls
                    self.MediaSources = MediaSources
                    self.CriticRating = CriticRating
                    self.ProductionLocations = ProductionLocations
                    self.Path = Path
                    self.EnableMediaSourceDisplay = EnableMediaSourceDisplay
                    self.OfficialRating = OfficialRating
                    self.CustomRating = CustomRating
                    self.ChannelId = ChannelId
                    self.ChannelName = ChannelName
                    self.Overview = Overview
                    self.Taglines = Taglines
                    self.Genres = Genres
                    self.CommunityRating = CommunityRating
                    self.CumulativeRunTimeTicks = CumulativeRunTimeTicks
                    self.RunTimeTicks = RunTimeTicks
                    self.PlayAccess = PlayAccess
                    self.AspectRatio = AspectRatio
                    self.ProductionYear = ProductionYear
                    self.IsPlaceHolder = IsPlaceHolder
                    self.Number = Number
                    self.ChannelNumber = ChannelNumber
                    self.IndexNumber = IndexNumber
                    self.IndexNumberEnd = IndexNumberEnd
                    self.ParentIndexNumber = ParentIndexNumber
                    self.RemoteTrailers = RemoteTrailers
                    self.ProviderIds = ProviderIds
                    self.IsHD = IsHD
                    self.IsFolder = IsFolder
                    self.ParentId = ParentId
                    self._Type = _Type
                    self.People = People
                    self.Studios = Studios
                    self.GenreItems = GenreItems
                    self.ParentLogoItemId = ParentLogoItemId
                    self.ParentBackdropItemId = ParentBackdropItemId
                    self.ParentBackdropImageTags = ParentBackdropImageTags
                    self.LocalTrailerCount = LocalTrailerCount
                    self.UserData = UserData
                    self.RecursiveItemCount = RecursiveItemCount
                    self.ChildCount = ChildCount
                    self.SeriesName = SeriesName
                    self.SeriesId = SeriesId
                    self.SeasonId = SeasonId
                    self.SpecialFeatureCount = SpecialFeatureCount
                    self.DisplayPreferencesId = DisplayPreferencesId
                    self.Status = Status
                    self.AirTime = AirTime
                    self.AirDays = AirDays
                    self.Tags = Tags
                    self.PrimaryImageAspectRatio = PrimaryImageAspectRatio
                    self.Artists = Artists
                    self.ArtistItems = ArtistItems
                    self.Album = Album
                    self.CollectionType = CollectionType
                    self.DisplayOrder = DisplayOrder
                    self.AlbumId = AlbumId
                    self.AlbumPrimaryImageTag = AlbumPrimaryImageTag
                    self.SeriesPrimaryImageTag = SeriesPrimaryImageTag
                    self.AlbumArtist = AlbumArtist
                    self.AlbumArtists = AlbumArtists
                    self.SeasonName = SeasonName
                    self.MediaStreams = MediaStreams
                    self.VideoType = VideoType
                    self.PartCount = PartCount
                    self.MediaSourceCount = MediaSourceCount
                    self.ImageTags = ImageTags
                    self.BackdropImageTags = BackdropImageTags
                    self.ScreenshotImageTags = ScreenshotImageTags
                    self.ParentLogoImageTag = ParentLogoImageTag
                    self.ParentArtItemId = ParentArtItemId
                    self.ParentArtImageTag = ParentArtImageTag
                    self.SeriesThumbImageTag = SeriesThumbImageTag
                    self.ImageBlurHashes = ImageBlurHashes
                    self.SeriesStudio = SeriesStudio
                    self.ParentThumbItemId = ParentThumbItemId
                    self.ParentThumbImageTag = ParentThumbImageTag
                    self.ParentPrimaryImageItemId = ParentPrimaryImageItemId
                    self.ParentPrimaryImageTag = ParentPrimaryImageTag
                    self.Chapters = Chapters
                    self.Trickplay = Trickplay
                    self.LocationType = LocationType
                    self.IsoType = IsoType
                    self.MediaType = MediaType
                    self.EndDate = EndDate
                    self.LockedFields = LockedFields
                    self.TrailerCount = TrailerCount
                    self.MovieCount = MovieCount
                    self.SeriesCount = SeriesCount
                    self.ProgramCount = ProgramCount
                    self.EpisodeCount = EpisodeCount
                    self.SongCount = SongCount
                    self.AlbumCount = AlbumCount
                    self.ArtistCount = ArtistCount
                    self.MusicVideoCount = MusicVideoCount
                    self.LockData = LockData
                    self.Width = Width
                    self.Height = Height
                    self.CameraMake = CameraMake
                    self.CameraModel = CameraModel
                    self.Software = Software
                    self.ExposureTime = ExposureTime
                    self.FocalLength = FocalLength
                    self.ImageOrientation = ImageOrientation
                    self.Aperture = Aperture
                    self.ShutterSpeed = ShutterSpeed
                    self.Latitude = Latitude
                    self.Longitude = Longitude
                    self.Altitude = Altitude
                    self.IsoSpeedRating = IsoSpeedRating
                    self.SeriesTimerId = SeriesTimerId
                    self.ProgramId = ProgramId
                    self.ChannelPrimaryImageTag = ChannelPrimaryImageTag
                    self.StartDate = StartDate
                    self.CompletionPercentage = CompletionPercentage
                    self.IsRepeat = IsRepeat
                    self.EpisodeTitle = EpisodeTitle
                    self.ChannelType = ChannelType
                    self.Audio = Audio
                    self.IsMovie = IsMovie
                    self.IsSports = IsSports
                    self.IsSeries = IsSeries
                    self.IsLive = IsLive
                    self.IsNews = IsNews
                    self.IsKids = IsKids
                    self.IsPremiere = IsPremiere
                    self.TimerId = TimerId
                    self.NormalizationGain = NormalizationGain
                    self.CurrentProgram = CurrentProgram
                }
                typealias CodingKeys = Components.Schemas.BaseItemDto.CodingKeys
                init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    Name = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .Name
                    )
                    OriginalTitle = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .OriginalTitle
                    )
                    ServerId = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ServerId
                    )
                    Id = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .Id
                    )
                    Etag = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .Etag
                    )
                    SourceType = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .SourceType
                    )
                    PlaylistItemId = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .PlaylistItemId
                    )
                    DateCreated = try container.decodeIfPresent(
                        Foundation.Date.self,
                        forKey: .DateCreated
                    )
                    DateLastMediaAdded = try container.decodeIfPresent(
                        Foundation.Date.self,
                        forKey: .DateLastMediaAdded
                    )
                    ExtraType = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.ExtraTypePayload.self,
                        forKey: .ExtraType
                    )
                    AirsBeforeSeasonNumber = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .AirsBeforeSeasonNumber
                    )
                    AirsAfterSeasonNumber = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .AirsAfterSeasonNumber
                    )
                    AirsBeforeEpisodeNumber = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .AirsBeforeEpisodeNumber
                    )
                    CanDelete = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .CanDelete
                    )
                    CanDownload = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .CanDownload
                    )
                    HasLyrics = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .HasLyrics
                    )
                    HasSubtitles = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .HasSubtitles
                    )
                    PreferredMetadataLanguage = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .PreferredMetadataLanguage
                    )
                    PreferredMetadataCountryCode = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .PreferredMetadataCountryCode
                    )
                    Container = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .Container
                    )
                    SortName = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .SortName
                    )
                    ForcedSortName = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ForcedSortName
                    )
                    Video3DFormat = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.Video3DFormatPayload.self,
                        forKey: .Video3DFormat
                    )
                    PremiereDate = try container.decodeIfPresent(
                        Foundation.Date.self,
                        forKey: .PremiereDate
                    )
                    ExternalUrls = try container.decodeIfPresent(
                        [Components.Schemas.ExternalUrl].self,
                        forKey: .ExternalUrls
                    )
                    MediaSources = try container.decodeIfPresent(
                        [Components.Schemas.MediaSourceInfo].self,
                        forKey: .MediaSources
                    )
                    CriticRating = try container.decodeIfPresent(
                        Swift.Float.self,
                        forKey: .CriticRating
                    )
                    ProductionLocations = try container.decodeIfPresent(
                        [Swift.String].self,
                        forKey: .ProductionLocations
                    )
                    Path = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .Path
                    )
                    EnableMediaSourceDisplay = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .EnableMediaSourceDisplay
                    )
                    OfficialRating = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .OfficialRating
                    )
                    CustomRating = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .CustomRating
                    )
                    ChannelId = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ChannelId
                    )
                    ChannelName = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ChannelName
                    )
                    Overview = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .Overview
                    )
                    Taglines = try container.decodeIfPresent(
                        [Swift.String].self,
                        forKey: .Taglines
                    )
                    Genres = try container.decodeIfPresent(
                        [Swift.String].self,
                        forKey: .Genres
                    )
                    CommunityRating = try container.decodeIfPresent(
                        Swift.Float.self,
                        forKey: .CommunityRating
                    )
                    CumulativeRunTimeTicks = try container.decodeIfPresent(
                        Swift.Int64.self,
                        forKey: .CumulativeRunTimeTicks
                    )
                    RunTimeTicks = try container.decodeIfPresent(
                        Swift.Int64.self,
                        forKey: .RunTimeTicks
                    )
                    PlayAccess = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.PlayAccessPayload.self,
                        forKey: .PlayAccess
                    )
                    AspectRatio = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .AspectRatio
                    )
                    ProductionYear = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .ProductionYear
                    )
                    IsPlaceHolder = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .IsPlaceHolder
                    )
                    Number = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .Number
                    )
                    ChannelNumber = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ChannelNumber
                    )
                    IndexNumber = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .IndexNumber
                    )
                    IndexNumberEnd = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .IndexNumberEnd
                    )
                    ParentIndexNumber = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .ParentIndexNumber
                    )
                    RemoteTrailers = try container.decodeIfPresent(
                        [Components.Schemas.MediaUrl].self,
                        forKey: .RemoteTrailers
                    )
                    ProviderIds = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.ProviderIdsPayload.self,
                        forKey: .ProviderIds
                    )
                    IsHD = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .IsHD
                    )
                    IsFolder = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .IsFolder
                    )
                    ParentId = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ParentId
                    )
                    _Type = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto._TypePayload.self,
                        forKey: ._Type
                    )
                    People = try container.decodeIfPresent(
                        [Components.Schemas.BaseItemPerson].self,
                        forKey: .People
                    )
                    Studios = try container.decodeIfPresent(
                        [Components.Schemas.NameGuidPair].self,
                        forKey: .Studios
                    )
                    GenreItems = try container.decodeIfPresent(
                        [Components.Schemas.NameGuidPair].self,
                        forKey: .GenreItems
                    )
                    ParentLogoItemId = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ParentLogoItemId
                    )
                    ParentBackdropItemId = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ParentBackdropItemId
                    )
                    ParentBackdropImageTags = try container.decodeIfPresent(
                        [Swift.String].self,
                        forKey: .ParentBackdropImageTags
                    )
                    LocalTrailerCount = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .LocalTrailerCount
                    )
                    UserData = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.UserDataPayload.self,
                        forKey: .UserData
                    )
                    RecursiveItemCount = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .RecursiveItemCount
                    )
                    ChildCount = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .ChildCount
                    )
                    SeriesName = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .SeriesName
                    )
                    SeriesId = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .SeriesId
                    )
                    SeasonId = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .SeasonId
                    )
                    SpecialFeatureCount = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .SpecialFeatureCount
                    )
                    DisplayPreferencesId = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .DisplayPreferencesId
                    )
                    Status = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .Status
                    )
                    AirTime = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .AirTime
                    )
                    AirDays = try container.decodeIfPresent(
                        [Components.Schemas.DayOfWeek].self,
                        forKey: .AirDays
                    )
                    Tags = try container.decodeIfPresent(
                        [Swift.String].self,
                        forKey: .Tags
                    )
                    PrimaryImageAspectRatio = try container.decodeIfPresent(
                        Swift.Double.self,
                        forKey: .PrimaryImageAspectRatio
                    )
                    Artists = try container.decodeIfPresent(
                        [Swift.String].self,
                        forKey: .Artists
                    )
                    ArtistItems = try container.decodeIfPresent(
                        [Components.Schemas.NameGuidPair].self,
                        forKey: .ArtistItems
                    )
                    Album = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .Album
                    )
                    CollectionType = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.CollectionTypePayload.self,
                        forKey: .CollectionType
                    )
                    DisplayOrder = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .DisplayOrder
                    )
                    AlbumId = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .AlbumId
                    )
                    AlbumPrimaryImageTag = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .AlbumPrimaryImageTag
                    )
                    SeriesPrimaryImageTag = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .SeriesPrimaryImageTag
                    )
                    AlbumArtist = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .AlbumArtist
                    )
                    AlbumArtists = try container.decodeIfPresent(
                        [Components.Schemas.NameGuidPair].self,
                        forKey: .AlbumArtists
                    )
                    SeasonName = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .SeasonName
                    )
                    MediaStreams = try container.decodeIfPresent(
                        [Components.Schemas.MediaStream].self,
                        forKey: .MediaStreams
                    )
                    VideoType = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.VideoTypePayload.self,
                        forKey: .VideoType
                    )
                    PartCount = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .PartCount
                    )
                    MediaSourceCount = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .MediaSourceCount
                    )
                    ImageTags = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.ImageTagsPayload.self,
                        forKey: .ImageTags
                    )
                    BackdropImageTags = try container.decodeIfPresent(
                        [Swift.String].self,
                        forKey: .BackdropImageTags
                    )
                    ScreenshotImageTags = try container.decodeIfPresent(
                        [Swift.String].self,
                        forKey: .ScreenshotImageTags
                    )
                    ParentLogoImageTag = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ParentLogoImageTag
                    )
                    ParentArtItemId = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ParentArtItemId
                    )
                    ParentArtImageTag = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ParentArtImageTag
                    )
                    SeriesThumbImageTag = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .SeriesThumbImageTag
                    )
                    ImageBlurHashes = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.ImageBlurHashesPayload.self,
                        forKey: .ImageBlurHashes
                    )
                    SeriesStudio = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .SeriesStudio
                    )
                    ParentThumbItemId = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ParentThumbItemId
                    )
                    ParentThumbImageTag = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ParentThumbImageTag
                    )
                    ParentPrimaryImageItemId = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ParentPrimaryImageItemId
                    )
                    ParentPrimaryImageTag = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ParentPrimaryImageTag
                    )
                    Chapters = try container.decodeIfPresent(
                        [Components.Schemas.ChapterInfo].self,
                        forKey: .Chapters
                    )
                    Trickplay = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.TrickplayPayload.self,
                        forKey: .Trickplay
                    )
                    LocationType = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.LocationTypePayload.self,
                        forKey: .LocationType
                    )
                    IsoType = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.IsoTypePayload.self,
                        forKey: .IsoType
                    )
                    MediaType = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.MediaTypePayload.self,
                        forKey: .MediaType
                    )
                    EndDate = try container.decodeIfPresent(
                        Foundation.Date.self,
                        forKey: .EndDate
                    )
                    LockedFields = try container.decodeIfPresent(
                        [Components.Schemas.MetadataField].self,
                        forKey: .LockedFields
                    )
                    TrailerCount = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .TrailerCount
                    )
                    MovieCount = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .MovieCount
                    )
                    SeriesCount = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .SeriesCount
                    )
                    ProgramCount = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .ProgramCount
                    )
                    EpisodeCount = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .EpisodeCount
                    )
                    SongCount = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .SongCount
                    )
                    AlbumCount = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .AlbumCount
                    )
                    ArtistCount = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .ArtistCount
                    )
                    MusicVideoCount = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .MusicVideoCount
                    )
                    LockData = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .LockData
                    )
                    Width = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .Width
                    )
                    Height = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .Height
                    )
                    CameraMake = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .CameraMake
                    )
                    CameraModel = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .CameraModel
                    )
                    Software = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .Software
                    )
                    ExposureTime = try container.decodeIfPresent(
                        Swift.Double.self,
                        forKey: .ExposureTime
                    )
                    FocalLength = try container.decodeIfPresent(
                        Swift.Double.self,
                        forKey: .FocalLength
                    )
                    ImageOrientation = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.ImageOrientationPayload.self,
                        forKey: .ImageOrientation
                    )
                    Aperture = try container.decodeIfPresent(
                        Swift.Double.self,
                        forKey: .Aperture
                    )
                    ShutterSpeed = try container.decodeIfPresent(
                        Swift.Double.self,
                        forKey: .ShutterSpeed
                    )
                    Latitude = try container.decodeIfPresent(
                        Swift.Double.self,
                        forKey: .Latitude
                    )
                    Longitude = try container.decodeIfPresent(
                        Swift.Double.self,
                        forKey: .Longitude
                    )
                    Altitude = try container.decodeIfPresent(
                        Swift.Double.self,
                        forKey: .Altitude
                    )
                    IsoSpeedRating = try container.decodeIfPresent(
                        Swift.Int32.self,
                        forKey: .IsoSpeedRating
                    )
                    SeriesTimerId = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .SeriesTimerId
                    )
                    ProgramId = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ProgramId
                    )
                    ChannelPrimaryImageTag = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .ChannelPrimaryImageTag
                    )
                    StartDate = try container.decodeIfPresent(
                        Foundation.Date.self,
                        forKey: .StartDate
                    )
                    CompletionPercentage = try container.decodeIfPresent(
                        Swift.Double.self,
                        forKey: .CompletionPercentage
                    )
                    IsRepeat = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .IsRepeat
                    )
                    EpisodeTitle = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .EpisodeTitle
                    )
                    ChannelType = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.ChannelTypePayload.self,
                        forKey: .ChannelType
                    )
                    Audio = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.AudioPayload.self,
                        forKey: .Audio
                    )
                    IsMovie = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .IsMovie
                    )
                    IsSports = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .IsSports
                    )
                    IsSeries = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .IsSeries
                    )
                    IsLive = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .IsLive
                    )
                    IsNews = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .IsNews
                    )
                    IsKids = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .IsKids
                    )
                    IsPremiere = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .IsPremiere
                    )
                    TimerId = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .TimerId
                    )
                    NormalizationGain = try container.decodeIfPresent(
                        Swift.Float.self,
                        forKey: .NormalizationGain
                    )
                    CurrentProgram = try container.decodeIfPresent(
                        Components.Schemas.BaseItemDto.CurrentProgramPayload.self,
                        forKey: .CurrentProgram
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "Name",
                        "OriginalTitle",
                        "ServerId",
                        "Id",
                        "Etag",
                        "SourceType",
                        "PlaylistItemId",
                        "DateCreated",
                        "DateLastMediaAdded",
                        "ExtraType",
                        "AirsBeforeSeasonNumber",
                        "AirsAfterSeasonNumber",
                        "AirsBeforeEpisodeNumber",
                        "CanDelete",
                        "CanDownload",
                        "HasLyrics",
                        "HasSubtitles",
                        "PreferredMetadataLanguage",
                        "PreferredMetadataCountryCode",
                        "Container",
                        "SortName",
                        "ForcedSortName",
                        "Video3DFormat",
                        "PremiereDate",
                        "ExternalUrls",
                        "MediaSources",
                        "CriticRating",
                        "ProductionLocations",
                        "Path",
                        "EnableMediaSourceDisplay",
                        "OfficialRating",
                        "CustomRating",
                        "ChannelId",
                        "ChannelName",
                        "Overview",
                        "Taglines",
                        "Genres",
                        "CommunityRating",
                        "CumulativeRunTimeTicks",
                        "RunTimeTicks",
                        "PlayAccess",
                        "AspectRatio",
                        "ProductionYear",
                        "IsPlaceHolder",
                        "Number",
                        "ChannelNumber",
                        "IndexNumber",
                        "IndexNumberEnd",
                        "ParentIndexNumber",
                        "RemoteTrailers",
                        "ProviderIds",
                        "IsHD",
                        "IsFolder",
                        "ParentId",
                        "Type",
                        "People",
                        "Studios",
                        "GenreItems",
                        "ParentLogoItemId",
                        "ParentBackdropItemId",
                        "ParentBackdropImageTags",
                        "LocalTrailerCount",
                        "UserData",
                        "RecursiveItemCount",
                        "ChildCount",
                        "SeriesName",
                        "SeriesId",
                        "SeasonId",
                        "SpecialFeatureCount",
                        "DisplayPreferencesId",
                        "Status",
                        "AirTime",
                        "AirDays",
                        "Tags",
                        "PrimaryImageAspectRatio",
                        "Artists",
                        "ArtistItems",
                        "Album",
                        "CollectionType",
                        "DisplayOrder",
                        "AlbumId",
                        "AlbumPrimaryImageTag",
                        "SeriesPrimaryImageTag",
                        "AlbumArtist",
                        "AlbumArtists",
                        "SeasonName",
                        "MediaStreams",
                        "VideoType",
                        "PartCount",
                        "MediaSourceCount",
                        "ImageTags",
                        "BackdropImageTags",
                        "ScreenshotImageTags",
                        "ParentLogoImageTag",
                        "ParentArtItemId",
                        "ParentArtImageTag",
                        "SeriesThumbImageTag",
                        "ImageBlurHashes",
                        "SeriesStudio",
                        "ParentThumbItemId",
                        "ParentThumbImageTag",
                        "ParentPrimaryImageItemId",
                        "ParentPrimaryImageTag",
                        "Chapters",
                        "Trickplay",
                        "LocationType",
                        "IsoType",
                        "MediaType",
                        "EndDate",
                        "LockedFields",
                        "TrailerCount",
                        "MovieCount",
                        "SeriesCount",
                        "ProgramCount",
                        "EpisodeCount",
                        "SongCount",
                        "AlbumCount",
                        "ArtistCount",
                        "MusicVideoCount",
                        "LockData",
                        "Width",
                        "Height",
                        "CameraMake",
                        "CameraModel",
                        "Software",
                        "ExposureTime",
                        "FocalLength",
                        "ImageOrientation",
                        "Aperture",
                        "ShutterSpeed",
                        "Latitude",
                        "Longitude",
                        "Altitude",
                        "IsoSpeedRating",
                        "SeriesTimerId",
                        "ProgramId",
                        "ChannelPrimaryImageTag",
                        "StartDate",
                        "CompletionPercentage",
                        "IsRepeat",
                        "EpisodeTitle",
                        "ChannelType",
                        "Audio",
                        "IsMovie",
                        "IsSports",
                        "IsSeries",
                        "IsLive",
                        "IsNews",
                        "IsKids",
                        "IsPremiere",
                        "TimerId",
                        "NormalizationGain",
                        "CurrentProgram"
                    ])
                }
            }
        }
        /// Query result container.
        ///
        /// - Remark: Generated from `#/components/schemas/BaseItemDtoQueryResult`.
        public struct BaseItemDtoQueryResult: Codable, Hashable, Sendable {
            /// Gets or sets the items.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDtoQueryResult/Items`.
            public var Items: [Components.Schemas.BaseItemDto]?
            /// Gets or sets the total number of records available.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDtoQueryResult/TotalRecordCount`.
            public var TotalRecordCount: Swift.Int32?
            /// Gets or sets the index of the first record in Items.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemDtoQueryResult/StartIndex`.
            public var StartIndex: Swift.Int32?
            /// Creates a new `BaseItemDtoQueryResult`.
            ///
            /// - Parameters:
            ///   - Items: Gets or sets the items.
            ///   - TotalRecordCount: Gets or sets the total number of records available.
            ///   - StartIndex: Gets or sets the index of the first record in Items.
            public init(
                Items: [Components.Schemas.BaseItemDto]? = nil,
                TotalRecordCount: Swift.Int32? = nil,
                StartIndex: Swift.Int32? = nil
            ) {
                self.Items = Items
                self.TotalRecordCount = TotalRecordCount
                self.StartIndex = StartIndex
            }
            public enum CodingKeys: String, CodingKey {
                case Items
                case TotalRecordCount
                case StartIndex
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Items = try container.decodeIfPresent(
                    [Components.Schemas.BaseItemDto].self,
                    forKey: .Items
                )
                TotalRecordCount = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .TotalRecordCount
                )
                StartIndex = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .StartIndex
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Items",
                    "TotalRecordCount",
                    "StartIndex"
                ])
            }
        }
        /// The base item kind.
        ///
        /// - Remark: Generated from `#/components/schemas/BaseItemKind`.
        @frozen public enum BaseItemKind: String, Codable, Hashable, Sendable, CaseIterable {
            case AggregateFolder = "AggregateFolder"
            case Audio = "Audio"
            case AudioBook = "AudioBook"
            case BasePluginFolder = "BasePluginFolder"
            case Book = "Book"
            case BoxSet = "BoxSet"
            case Channel = "Channel"
            case ChannelFolderItem = "ChannelFolderItem"
            case CollectionFolder = "CollectionFolder"
            case Episode = "Episode"
            case Folder = "Folder"
            case Genre = "Genre"
            case ManualPlaylistsFolder = "ManualPlaylistsFolder"
            case Movie = "Movie"
            case LiveTvChannel = "LiveTvChannel"
            case LiveTvProgram = "LiveTvProgram"
            case MusicAlbum = "MusicAlbum"
            case MusicArtist = "MusicArtist"
            case MusicGenre = "MusicGenre"
            case MusicVideo = "MusicVideo"
            case Person = "Person"
            case Photo = "Photo"
            case PhotoAlbum = "PhotoAlbum"
            case Playlist = "Playlist"
            case PlaylistsFolder = "PlaylistsFolder"
            case Program = "Program"
            case Recording = "Recording"
            case Season = "Season"
            case Series = "Series"
            case Studio = "Studio"
            case Trailer = "Trailer"
            case TvChannel = "TvChannel"
            case TvProgram = "TvProgram"
            case UserRootFolder = "UserRootFolder"
            case UserView = "UserView"
            case Video = "Video"
            case Year = "Year"
        }
        /// This is used by the api to get information about a Person within a BaseItem.
        ///
        /// - Remark: Generated from `#/components/schemas/BaseItemPerson`.
        public struct BaseItemPerson: Codable, Hashable, Sendable {
            /// Gets or sets the name.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemPerson/Name`.
            public var Name: Swift.String?
            /// Gets or sets the identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemPerson/Id`.
            public var Id: Swift.String?
            /// Gets or sets the role.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemPerson/Role`.
            public var Role: Swift.String?
            /// The person kind.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemPerson/Type`.
            public struct _TypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/Type/value1`.
                public var value1: Components.Schemas.PersonKind
                /// Creates a new `_TypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.PersonKind) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// The person kind.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemPerson/Type`.
            public var _Type: Components.Schemas.BaseItemPerson._TypePayload?
            /// Gets or sets the primary image tag.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemPerson/PrimaryImageTag`.
            public var PrimaryImageTag: Swift.String?
            /// Gets or sets the primary image blurhash.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes`.
            public struct ImageBlurHashesPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Primary`.
                public struct PrimaryPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `PrimaryPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Primary`.
                public var Primary: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.PrimaryPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Art`.
                public struct ArtPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `ArtPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Art`.
                public var Art: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.ArtPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Backdrop`.
                public struct BackdropPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `BackdropPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Backdrop`.
                public var Backdrop: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.BackdropPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Banner`.
                public struct BannerPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `BannerPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Banner`.
                public var Banner: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.BannerPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Logo`.
                public struct LogoPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `LogoPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Logo`.
                public var Logo: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.LogoPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Thumb`.
                public struct ThumbPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `ThumbPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Thumb`.
                public var Thumb: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.ThumbPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Disc`.
                public struct DiscPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `DiscPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Disc`.
                public var Disc: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.DiscPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Box`.
                public struct BoxPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `BoxPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Box`.
                public var Box: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.BoxPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Screenshot`.
                public struct ScreenshotPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `ScreenshotPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Screenshot`.
                public var Screenshot: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.ScreenshotPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Menu`.
                public struct MenuPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `MenuPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Menu`.
                public var Menu: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.MenuPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Chapter`.
                public struct ChapterPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `ChapterPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Chapter`.
                public var Chapter: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.ChapterPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/BoxRear`.
                public struct BoxRearPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `BoxRearPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/BoxRear`.
                public var BoxRear: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.BoxRearPayload?
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Profile`.
                public struct ProfilePayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: [String: Swift.String]
                    /// Creates a new `ProfilePayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: [String: Swift.String] = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes/Profile`.
                public var Profile: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.ProfilePayload?
                /// Creates a new `ImageBlurHashesPayload`.
                ///
                /// - Parameters:
                ///   - Primary:
                ///   - Art:
                ///   - Backdrop:
                ///   - Banner:
                ///   - Logo:
                ///   - Thumb:
                ///   - Disc:
                ///   - Box:
                ///   - Screenshot:
                ///   - Menu:
                ///   - Chapter:
                ///   - BoxRear:
                ///   - Profile:
                public init(
                    Primary: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.PrimaryPayload? = nil,
                    Art: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.ArtPayload? = nil,
                    Backdrop: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.BackdropPayload? = nil,
                    Banner: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.BannerPayload? = nil,
                    Logo: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.LogoPayload? = nil,
                    Thumb: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.ThumbPayload? = nil,
                    Disc: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.DiscPayload? = nil,
                    Box: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.BoxPayload? = nil,
                    Screenshot: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.ScreenshotPayload? = nil,
                    Menu: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.MenuPayload? = nil,
                    Chapter: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.ChapterPayload? = nil,
                    BoxRear: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.BoxRearPayload? = nil,
                    Profile: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.ProfilePayload? = nil
                ) {
                    self.Primary = Primary
                    self.Art = Art
                    self.Backdrop = Backdrop
                    self.Banner = Banner
                    self.Logo = Logo
                    self.Thumb = Thumb
                    self.Disc = Disc
                    self.Box = Box
                    self.Screenshot = Screenshot
                    self.Menu = Menu
                    self.Chapter = Chapter
                    self.BoxRear = BoxRear
                    self.Profile = Profile
                }
                public enum CodingKeys: String, CodingKey {
                    case Primary
                    case Art
                    case Backdrop
                    case Banner
                    case Logo
                    case Thumb
                    case Disc
                    case Box
                    case Screenshot
                    case Menu
                    case Chapter
                    case BoxRear
                    case Profile
                }
            }
            /// Gets or sets the primary image blurhash.
            ///
            /// - Remark: Generated from `#/components/schemas/BaseItemPerson/ImageBlurHashes`.
            public var ImageBlurHashes: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload?
            /// Creates a new `BaseItemPerson`.
            ///
            /// - Parameters:
            ///   - Name: Gets or sets the name.
            ///   - Id: Gets or sets the identifier.
            ///   - Role: Gets or sets the role.
            ///   - _Type: The person kind.
            ///   - PrimaryImageTag: Gets or sets the primary image tag.
            ///   - ImageBlurHashes: Gets or sets the primary image blurhash.
            public init(
                Name: Swift.String? = nil,
                Id: Swift.String? = nil,
                Role: Swift.String? = nil,
                _Type: Components.Schemas.BaseItemPerson._TypePayload? = nil,
                PrimaryImageTag: Swift.String? = nil,
                ImageBlurHashes: Components.Schemas.BaseItemPerson.ImageBlurHashesPayload? = nil
            ) {
                self.Name = Name
                self.Id = Id
                self.Role = Role
                self._Type = _Type
                self.PrimaryImageTag = PrimaryImageTag
                self.ImageBlurHashes = ImageBlurHashes
            }
            public enum CodingKeys: String, CodingKey {
                case Name
                case Id
                case Role
                case _Type = "Type"
                case PrimaryImageTag
                case ImageBlurHashes
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Name = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Name
                )
                Id = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Id
                )
                Role = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Role
                )
                _Type = try container.decodeIfPresent(
                    Components.Schemas.BaseItemPerson._TypePayload.self,
                    forKey: ._Type
                )
                PrimaryImageTag = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .PrimaryImageTag
                )
                ImageBlurHashes = try container.decodeIfPresent(
                    Components.Schemas.BaseItemPerson.ImageBlurHashesPayload.self,
                    forKey: .ImageBlurHashes
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Name",
                    "Id",
                    "Role",
                    "Type",
                    "PrimaryImageTag",
                    "ImageBlurHashes"
                ])
            }
        }
        /// Enum ChannelType.
        ///
        /// - Remark: Generated from `#/components/schemas/ChannelType`.
        @frozen public enum ChannelType: String, Codable, Hashable, Sendable, CaseIterable {
            case TV = "TV"
            case Radio = "Radio"
        }
        /// Class ChapterInfo.
        ///
        /// - Remark: Generated from `#/components/schemas/ChapterInfo`.
        public struct ChapterInfo: Codable, Hashable, Sendable {
            /// Gets or sets the start position ticks.
            ///
            /// - Remark: Generated from `#/components/schemas/ChapterInfo/StartPositionTicks`.
            public var StartPositionTicks: Swift.Int64?
            /// Gets or sets the name.
            ///
            /// - Remark: Generated from `#/components/schemas/ChapterInfo/Name`.
            public var Name: Swift.String?
            /// Gets or sets the image path.
            ///
            /// - Remark: Generated from `#/components/schemas/ChapterInfo/ImagePath`.
            public var ImagePath: Swift.String?
            /// - Remark: Generated from `#/components/schemas/ChapterInfo/ImageDateModified`.
            public var ImageDateModified: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/ChapterInfo/ImageTag`.
            public var ImageTag: Swift.String?
            /// Creates a new `ChapterInfo`.
            ///
            /// - Parameters:
            ///   - StartPositionTicks: Gets or sets the start position ticks.
            ///   - Name: Gets or sets the name.
            ///   - ImagePath: Gets or sets the image path.
            ///   - ImageDateModified:
            ///   - ImageTag:
            public init(
                StartPositionTicks: Swift.Int64? = nil,
                Name: Swift.String? = nil,
                ImagePath: Swift.String? = nil,
                ImageDateModified: Foundation.Date? = nil,
                ImageTag: Swift.String? = nil
            ) {
                self.StartPositionTicks = StartPositionTicks
                self.Name = Name
                self.ImagePath = ImagePath
                self.ImageDateModified = ImageDateModified
                self.ImageTag = ImageTag
            }
            public enum CodingKeys: String, CodingKey {
                case StartPositionTicks
                case Name
                case ImagePath
                case ImageDateModified
                case ImageTag
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                StartPositionTicks = try container.decodeIfPresent(
                    Swift.Int64.self,
                    forKey: .StartPositionTicks
                )
                Name = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Name
                )
                ImagePath = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ImagePath
                )
                ImageDateModified = try container.decodeIfPresent(
                    Foundation.Date.self,
                    forKey: .ImageDateModified
                )
                ImageTag = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ImageTag
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "StartPositionTicks",
                    "Name",
                    "ImagePath",
                    "ImageDateModified",
                    "ImageTag"
                ])
            }
        }
        /// Client capabilities dto.
        ///
        /// - Remark: Generated from `#/components/schemas/ClientCapabilitiesDto`.
        public struct ClientCapabilitiesDto: Codable, Hashable, Sendable {
            /// Gets or sets the list of playable media types.
            ///
            /// - Remark: Generated from `#/components/schemas/ClientCapabilitiesDto/PlayableMediaTypes`.
            public var PlayableMediaTypes: [Components.Schemas.MediaType]?
            /// Gets or sets the list of supported commands.
            ///
            /// - Remark: Generated from `#/components/schemas/ClientCapabilitiesDto/SupportedCommands`.
            public var SupportedCommands: [Components.Schemas.GeneralCommandType]?
            /// Gets or sets a value indicating whether session supports media control.
            ///
            /// - Remark: Generated from `#/components/schemas/ClientCapabilitiesDto/SupportsMediaControl`.
            public var SupportsMediaControl: Swift.Bool?
            /// Gets or sets a value indicating whether session supports a persistent identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/ClientCapabilitiesDto/SupportsPersistentIdentifier`.
            public var SupportsPersistentIdentifier: Swift.Bool?
            /// Gets or sets the device profile.
            ///
            /// - Remark: Generated from `#/components/schemas/ClientCapabilitiesDto/DeviceProfile`.
            public struct DeviceProfilePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/ClientCapabilitiesDto/DeviceProfile/value1`.
                public var value1: Components.Schemas.DeviceProfile
                /// Creates a new `DeviceProfilePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.DeviceProfile) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try value1.encode(to: encoder)
                }
            }
            /// Gets or sets the device profile.
            ///
            /// - Remark: Generated from `#/components/schemas/ClientCapabilitiesDto/DeviceProfile`.
            public var DeviceProfile: Components.Schemas.ClientCapabilitiesDto.DeviceProfilePayload?
            /// Gets or sets the app store url.
            ///
            /// - Remark: Generated from `#/components/schemas/ClientCapabilitiesDto/AppStoreUrl`.
            public var AppStoreUrl: Swift.String?
            /// Gets or sets the icon url.
            ///
            /// - Remark: Generated from `#/components/schemas/ClientCapabilitiesDto/IconUrl`.
            public var IconUrl: Swift.String?
            /// Creates a new `ClientCapabilitiesDto`.
            ///
            /// - Parameters:
            ///   - PlayableMediaTypes: Gets or sets the list of playable media types.
            ///   - SupportedCommands: Gets or sets the list of supported commands.
            ///   - SupportsMediaControl: Gets or sets a value indicating whether session supports media control.
            ///   - SupportsPersistentIdentifier: Gets or sets a value indicating whether session supports a persistent identifier.
            ///   - DeviceProfile: Gets or sets the device profile.
            ///   - AppStoreUrl: Gets or sets the app store url.
            ///   - IconUrl: Gets or sets the icon url.
            public init(
                PlayableMediaTypes: [Components.Schemas.MediaType]? = nil,
                SupportedCommands: [Components.Schemas.GeneralCommandType]? = nil,
                SupportsMediaControl: Swift.Bool? = nil,
                SupportsPersistentIdentifier: Swift.Bool? = nil,
                DeviceProfile: Components.Schemas.ClientCapabilitiesDto.DeviceProfilePayload? = nil,
                AppStoreUrl: Swift.String? = nil,
                IconUrl: Swift.String? = nil
            ) {
                self.PlayableMediaTypes = PlayableMediaTypes
                self.SupportedCommands = SupportedCommands
                self.SupportsMediaControl = SupportsMediaControl
                self.SupportsPersistentIdentifier = SupportsPersistentIdentifier
                self.DeviceProfile = DeviceProfile
                self.AppStoreUrl = AppStoreUrl
                self.IconUrl = IconUrl
            }
            public enum CodingKeys: String, CodingKey {
                case PlayableMediaTypes
                case SupportedCommands
                case SupportsMediaControl
                case SupportsPersistentIdentifier
                case DeviceProfile
                case AppStoreUrl
                case IconUrl
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                PlayableMediaTypes = try container.decodeIfPresent(
                    [Components.Schemas.MediaType].self,
                    forKey: .PlayableMediaTypes
                )
                SupportedCommands = try container.decodeIfPresent(
                    [Components.Schemas.GeneralCommandType].self,
                    forKey: .SupportedCommands
                )
                SupportsMediaControl = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .SupportsMediaControl
                )
                SupportsPersistentIdentifier = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .SupportsPersistentIdentifier
                )
                DeviceProfile = try container.decodeIfPresent(
                    Components.Schemas.ClientCapabilitiesDto.DeviceProfilePayload.self,
                    forKey: .DeviceProfile
                )
                AppStoreUrl = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .AppStoreUrl
                )
                IconUrl = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .IconUrl
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "PlayableMediaTypes",
                    "SupportedCommands",
                    "SupportsMediaControl",
                    "SupportsPersistentIdentifier",
                    "DeviceProfile",
                    "AppStoreUrl",
                    "IconUrl"
                ])
            }
        }
        /// Defines the MediaBrowser.Model.Dlna.CodecProfile.
        ///
        /// - Remark: Generated from `#/components/schemas/CodecProfile`.
        public struct CodecProfile: Codable, Hashable, Sendable {
            /// Gets or sets the MediaBrowser.Model.Dlna.CodecType which this container must meet.
            ///
            /// - Remark: Generated from `#/components/schemas/CodecProfile/Type`.
            public struct _TypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/CodecProfile/Type/value1`.
                public var value1: Components.Schemas.CodecType
                /// Creates a new `_TypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.CodecType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the MediaBrowser.Model.Dlna.CodecType which this container must meet.
            ///
            /// - Remark: Generated from `#/components/schemas/CodecProfile/Type`.
            public var _Type: Components.Schemas.CodecProfile._TypePayload?
            /// Gets or sets the list of MediaBrowser.Model.Dlna.ProfileCondition which this profile must meet.
            ///
            /// - Remark: Generated from `#/components/schemas/CodecProfile/Conditions`.
            public var Conditions: [Components.Schemas.ProfileCondition]?
            /// Gets or sets the list of MediaBrowser.Model.Dlna.ProfileCondition to apply if this profile is met.
            ///
            /// - Remark: Generated from `#/components/schemas/CodecProfile/ApplyConditions`.
            public var ApplyConditions: [Components.Schemas.ProfileCondition]?
            /// Gets or sets the codec(s) that this profile applies to.
            ///
            /// - Remark: Generated from `#/components/schemas/CodecProfile/Codec`.
            public var Codec: Swift.String?
            /// Gets or sets the container(s) which this profile will be applied to.
            ///
            /// - Remark: Generated from `#/components/schemas/CodecProfile/Container`.
            public var Container: Swift.String?
            /// Gets or sets the sub-container(s) which this profile will be applied to.
            ///
            /// - Remark: Generated from `#/components/schemas/CodecProfile/SubContainer`.
            public var SubContainer: Swift.String?
            /// Creates a new `CodecProfile`.
            ///
            /// - Parameters:
            ///   - _Type: Gets or sets the MediaBrowser.Model.Dlna.CodecType which this container must meet.
            ///   - Conditions: Gets or sets the list of MediaBrowser.Model.Dlna.ProfileCondition which this profile must meet.
            ///   - ApplyConditions: Gets or sets the list of MediaBrowser.Model.Dlna.ProfileCondition to apply if this profile is met.
            ///   - Codec: Gets or sets the codec(s) that this profile applies to.
            ///   - Container: Gets or sets the container(s) which this profile will be applied to.
            ///   - SubContainer: Gets or sets the sub-container(s) which this profile will be applied to.
            public init(
                _Type: Components.Schemas.CodecProfile._TypePayload? = nil,
                Conditions: [Components.Schemas.ProfileCondition]? = nil,
                ApplyConditions: [Components.Schemas.ProfileCondition]? = nil,
                Codec: Swift.String? = nil,
                Container: Swift.String? = nil,
                SubContainer: Swift.String? = nil
            ) {
                self._Type = _Type
                self.Conditions = Conditions
                self.ApplyConditions = ApplyConditions
                self.Codec = Codec
                self.Container = Container
                self.SubContainer = SubContainer
            }
            public enum CodingKeys: String, CodingKey {
                case _Type = "Type"
                case Conditions
                case ApplyConditions
                case Codec
                case Container
                case SubContainer
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                _Type = try container.decodeIfPresent(
                    Components.Schemas.CodecProfile._TypePayload.self,
                    forKey: ._Type
                )
                Conditions = try container.decodeIfPresent(
                    [Components.Schemas.ProfileCondition].self,
                    forKey: .Conditions
                )
                ApplyConditions = try container.decodeIfPresent(
                    [Components.Schemas.ProfileCondition].self,
                    forKey: .ApplyConditions
                )
                Codec = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Codec
                )
                Container = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Container
                )
                SubContainer = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .SubContainer
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Type",
                    "Conditions",
                    "ApplyConditions",
                    "Codec",
                    "Container",
                    "SubContainer"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/CodecType`.
        @frozen public enum CodecType: String, Codable, Hashable, Sendable, CaseIterable {
            case Video = "Video"
            case VideoAudio = "VideoAudio"
            case Audio = "Audio"
        }
        /// Collection type.
        ///
        /// - Remark: Generated from `#/components/schemas/CollectionType`.
        @frozen public enum CollectionType: String, Codable, Hashable, Sendable, CaseIterable {
            case unknown = "unknown"
            case movies = "movies"
            case tvshows = "tvshows"
            case music = "music"
            case musicvideos = "musicvideos"
            case trailers = "trailers"
            case homevideos = "homevideos"
            case boxsets = "boxsets"
            case books = "books"
            case photos = "photos"
            case livetv = "livetv"
            case playlists = "playlists"
            case folders = "folders"
        }
        /// Defines the MediaBrowser.Model.Dlna.ContainerProfile.
        ///
        /// - Remark: Generated from `#/components/schemas/ContainerProfile`.
        public struct ContainerProfile: Codable, Hashable, Sendable {
            /// Gets or sets the MediaBrowser.Model.Dlna.DlnaProfileType which this container must meet.
            ///
            /// - Remark: Generated from `#/components/schemas/ContainerProfile/Type`.
            public struct _TypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/ContainerProfile/Type/value1`.
                public var value1: Components.Schemas.DlnaProfileType
                /// Creates a new `_TypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.DlnaProfileType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the MediaBrowser.Model.Dlna.DlnaProfileType which this container must meet.
            ///
            /// - Remark: Generated from `#/components/schemas/ContainerProfile/Type`.
            public var _Type: Components.Schemas.ContainerProfile._TypePayload?
            /// Gets or sets the list of MediaBrowser.Model.Dlna.ProfileCondition which this container will be applied to.
            ///
            /// - Remark: Generated from `#/components/schemas/ContainerProfile/Conditions`.
            public var Conditions: [Components.Schemas.ProfileCondition]?
            /// Gets or sets the container(s) which this container must meet.
            ///
            /// - Remark: Generated from `#/components/schemas/ContainerProfile/Container`.
            public var Container: Swift.String?
            /// Gets or sets the sub container(s) which this container must meet.
            ///
            /// - Remark: Generated from `#/components/schemas/ContainerProfile/SubContainer`.
            public var SubContainer: Swift.String?
            /// Creates a new `ContainerProfile`.
            ///
            /// - Parameters:
            ///   - _Type: Gets or sets the MediaBrowser.Model.Dlna.DlnaProfileType which this container must meet.
            ///   - Conditions: Gets or sets the list of MediaBrowser.Model.Dlna.ProfileCondition which this container will be applied to.
            ///   - Container: Gets or sets the container(s) which this container must meet.
            ///   - SubContainer: Gets or sets the sub container(s) which this container must meet.
            public init(
                _Type: Components.Schemas.ContainerProfile._TypePayload? = nil,
                Conditions: [Components.Schemas.ProfileCondition]? = nil,
                Container: Swift.String? = nil,
                SubContainer: Swift.String? = nil
            ) {
                self._Type = _Type
                self.Conditions = Conditions
                self.Container = Container
                self.SubContainer = SubContainer
            }
            public enum CodingKeys: String, CodingKey {
                case _Type = "Type"
                case Conditions
                case Container
                case SubContainer
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                _Type = try container.decodeIfPresent(
                    Components.Schemas.ContainerProfile._TypePayload.self,
                    forKey: ._Type
                )
                Conditions = try container.decodeIfPresent(
                    [Components.Schemas.ProfileCondition].self,
                    forKey: .Conditions
                )
                Container = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Container
                )
                SubContainer = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .SubContainer
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Type",
                    "Conditions",
                    "Container",
                    "SubContainer"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/DayOfWeek`.
        @frozen public enum DayOfWeek: String, Codable, Hashable, Sendable, CaseIterable {
            case Sunday = "Sunday"
            case Monday = "Monday"
            case Tuesday = "Tuesday"
            case Wednesday = "Wednesday"
            case Thursday = "Thursday"
            case Friday = "Friday"
            case Saturday = "Saturday"
        }
        /// A MediaBrowser.Model.Dlna.DeviceProfile represents a set of metadata which determines which content a certain device is able to play.
        /// <br />
        /// Specifically, it defines the supported <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.ContainerProfiles">containers</see> and
        /// <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.CodecProfiles">codecs</see> (video and/or audio, including codec profiles and levels)
        /// the device is able to direct play (without transcoding or remuxing),
        /// as well as which <see cref="P:MediaBrowser.Model.Dlna.DeviceProfile.TranscodingProfiles">containers/codecs to transcode to</see> in case it isn't.
        ///
        /// - Remark: Generated from `#/components/schemas/DeviceProfile`.
        public struct DeviceProfile: Codable, Hashable, Sendable {
            /// Gets or sets the name of this device profile. User profiles must have a unique name.
            ///
            /// - Remark: Generated from `#/components/schemas/DeviceProfile/Name`.
            public var Name: Swift.String?
            /// Gets or sets the unique internal identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/DeviceProfile/Id`.
            public var Id: Swift.String?
            /// Gets or sets the maximum allowed bitrate for all streamed content.
            ///
            /// - Remark: Generated from `#/components/schemas/DeviceProfile/MaxStreamingBitrate`.
            public var MaxStreamingBitrate: Swift.Int32?
            /// Gets or sets the maximum allowed bitrate for statically streamed content (= direct played files).
            ///
            /// - Remark: Generated from `#/components/schemas/DeviceProfile/MaxStaticBitrate`.
            public var MaxStaticBitrate: Swift.Int32?
            /// Gets or sets the maximum allowed bitrate for transcoded music streams.
            ///
            /// - Remark: Generated from `#/components/schemas/DeviceProfile/MusicStreamingTranscodingBitrate`.
            public var MusicStreamingTranscodingBitrate: Swift.Int32?
            /// Gets or sets the maximum allowed bitrate for statically streamed (= direct played) music files.
            ///
            /// - Remark: Generated from `#/components/schemas/DeviceProfile/MaxStaticMusicBitrate`.
            public var MaxStaticMusicBitrate: Swift.Int32?
            /// Gets or sets the direct play profiles.
            ///
            /// - Remark: Generated from `#/components/schemas/DeviceProfile/DirectPlayProfiles`.
            public var DirectPlayProfiles: [Components.Schemas.DirectPlayProfile]?
            /// Gets or sets the transcoding profiles.
            ///
            /// - Remark: Generated from `#/components/schemas/DeviceProfile/TranscodingProfiles`.
            public var TranscodingProfiles: [Components.Schemas.TranscodingProfile]?
            /// Gets or sets the container profiles. Failing to meet these optional conditions causes transcoding to occur.
            ///
            /// - Remark: Generated from `#/components/schemas/DeviceProfile/ContainerProfiles`.
            public var ContainerProfiles: [Components.Schemas.ContainerProfile]?
            /// Gets or sets the codec profiles.
            ///
            /// - Remark: Generated from `#/components/schemas/DeviceProfile/CodecProfiles`.
            public var CodecProfiles: [Components.Schemas.CodecProfile]?
            /// Gets or sets the subtitle profiles.
            ///
            /// - Remark: Generated from `#/components/schemas/DeviceProfile/SubtitleProfiles`.
            public var SubtitleProfiles: [Components.Schemas.SubtitleProfile]?
            /// Creates a new `DeviceProfile`.
            ///
            /// - Parameters:
            ///   - Name: Gets or sets the name of this device profile. User profiles must have a unique name.
            ///   - Id: Gets or sets the unique internal identifier.
            ///   - MaxStreamingBitrate: Gets or sets the maximum allowed bitrate for all streamed content.
            ///   - MaxStaticBitrate: Gets or sets the maximum allowed bitrate for statically streamed content (= direct played files).
            ///   - MusicStreamingTranscodingBitrate: Gets or sets the maximum allowed bitrate for transcoded music streams.
            ///   - MaxStaticMusicBitrate: Gets or sets the maximum allowed bitrate for statically streamed (= direct played) music files.
            ///   - DirectPlayProfiles: Gets or sets the direct play profiles.
            ///   - TranscodingProfiles: Gets or sets the transcoding profiles.
            ///   - ContainerProfiles: Gets or sets the container profiles. Failing to meet these optional conditions causes transcoding to occur.
            ///   - CodecProfiles: Gets or sets the codec profiles.
            ///   - SubtitleProfiles: Gets or sets the subtitle profiles.
            public init(
                Name: Swift.String? = nil,
                Id: Swift.String? = nil,
                MaxStreamingBitrate: Swift.Int32? = nil,
                MaxStaticBitrate: Swift.Int32? = nil,
                MusicStreamingTranscodingBitrate: Swift.Int32? = nil,
                MaxStaticMusicBitrate: Swift.Int32? = nil,
                DirectPlayProfiles: [Components.Schemas.DirectPlayProfile]? = nil,
                TranscodingProfiles: [Components.Schemas.TranscodingProfile]? = nil,
                ContainerProfiles: [Components.Schemas.ContainerProfile]? = nil,
                CodecProfiles: [Components.Schemas.CodecProfile]? = nil,
                SubtitleProfiles: [Components.Schemas.SubtitleProfile]? = nil
            ) {
                self.Name = Name
                self.Id = Id
                self.MaxStreamingBitrate = MaxStreamingBitrate
                self.MaxStaticBitrate = MaxStaticBitrate
                self.MusicStreamingTranscodingBitrate = MusicStreamingTranscodingBitrate
                self.MaxStaticMusicBitrate = MaxStaticMusicBitrate
                self.DirectPlayProfiles = DirectPlayProfiles
                self.TranscodingProfiles = TranscodingProfiles
                self.ContainerProfiles = ContainerProfiles
                self.CodecProfiles = CodecProfiles
                self.SubtitleProfiles = SubtitleProfiles
            }
            public enum CodingKeys: String, CodingKey {
                case Name
                case Id
                case MaxStreamingBitrate
                case MaxStaticBitrate
                case MusicStreamingTranscodingBitrate
                case MaxStaticMusicBitrate
                case DirectPlayProfiles
                case TranscodingProfiles
                case ContainerProfiles
                case CodecProfiles
                case SubtitleProfiles
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Name = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Name
                )
                Id = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Id
                )
                MaxStreamingBitrate = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .MaxStreamingBitrate
                )
                MaxStaticBitrate = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .MaxStaticBitrate
                )
                MusicStreamingTranscodingBitrate = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .MusicStreamingTranscodingBitrate
                )
                MaxStaticMusicBitrate = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .MaxStaticMusicBitrate
                )
                DirectPlayProfiles = try container.decodeIfPresent(
                    [Components.Schemas.DirectPlayProfile].self,
                    forKey: .DirectPlayProfiles
                )
                TranscodingProfiles = try container.decodeIfPresent(
                    [Components.Schemas.TranscodingProfile].self,
                    forKey: .TranscodingProfiles
                )
                ContainerProfiles = try container.decodeIfPresent(
                    [Components.Schemas.ContainerProfile].self,
                    forKey: .ContainerProfiles
                )
                CodecProfiles = try container.decodeIfPresent(
                    [Components.Schemas.CodecProfile].self,
                    forKey: .CodecProfiles
                )
                SubtitleProfiles = try container.decodeIfPresent(
                    [Components.Schemas.SubtitleProfile].self,
                    forKey: .SubtitleProfiles
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Name",
                    "Id",
                    "MaxStreamingBitrate",
                    "MaxStaticBitrate",
                    "MusicStreamingTranscodingBitrate",
                    "MaxStaticMusicBitrate",
                    "DirectPlayProfiles",
                    "TranscodingProfiles",
                    "ContainerProfiles",
                    "CodecProfiles",
                    "SubtitleProfiles"
                ])
            }
        }
        /// Defines the MediaBrowser.Model.Dlna.DirectPlayProfile.
        ///
        /// - Remark: Generated from `#/components/schemas/DirectPlayProfile`.
        public struct DirectPlayProfile: Codable, Hashable, Sendable {
            /// Gets or sets the container.
            ///
            /// - Remark: Generated from `#/components/schemas/DirectPlayProfile/Container`.
            public var Container: Swift.String?
            /// Gets or sets the audio codec.
            ///
            /// - Remark: Generated from `#/components/schemas/DirectPlayProfile/AudioCodec`.
            public var AudioCodec: Swift.String?
            /// Gets or sets the video codec.
            ///
            /// - Remark: Generated from `#/components/schemas/DirectPlayProfile/VideoCodec`.
            public var VideoCodec: Swift.String?
            /// Gets or sets the Dlna profile type.
            ///
            /// - Remark: Generated from `#/components/schemas/DirectPlayProfile/Type`.
            public struct _TypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/DirectPlayProfile/Type/value1`.
                public var value1: Components.Schemas.DlnaProfileType
                /// Creates a new `_TypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.DlnaProfileType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the Dlna profile type.
            ///
            /// - Remark: Generated from `#/components/schemas/DirectPlayProfile/Type`.
            public var _Type: Components.Schemas.DirectPlayProfile._TypePayload?
            /// Creates a new `DirectPlayProfile`.
            ///
            /// - Parameters:
            ///   - Container: Gets or sets the container.
            ///   - AudioCodec: Gets or sets the audio codec.
            ///   - VideoCodec: Gets or sets the video codec.
            ///   - _Type: Gets or sets the Dlna profile type.
            public init(
                Container: Swift.String? = nil,
                AudioCodec: Swift.String? = nil,
                VideoCodec: Swift.String? = nil,
                _Type: Components.Schemas.DirectPlayProfile._TypePayload? = nil
            ) {
                self.Container = Container
                self.AudioCodec = AudioCodec
                self.VideoCodec = VideoCodec
                self._Type = _Type
            }
            public enum CodingKeys: String, CodingKey {
                case Container
                case AudioCodec
                case VideoCodec
                case _Type = "Type"
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Container = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Container
                )
                AudioCodec = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .AudioCodec
                )
                VideoCodec = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .VideoCodec
                )
                _Type = try container.decodeIfPresent(
                    Components.Schemas.DirectPlayProfile._TypePayload.self,
                    forKey: ._Type
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Container",
                    "AudioCodec",
                    "VideoCodec",
                    "Type"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/DlnaProfileType`.
        @frozen public enum DlnaProfileType: String, Codable, Hashable, Sendable, CaseIterable {
            case Audio = "Audio"
            case Video = "Video"
            case Photo = "Photo"
            case Subtitle = "Subtitle"
            case Lyric = "Lyric"
        }
        /// An enum that represents a day of the week, weekdays, weekends, or all days.
        ///
        /// - Remark: Generated from `#/components/schemas/DynamicDayOfWeek`.
        @frozen public enum DynamicDayOfWeek: String, Codable, Hashable, Sendable, CaseIterable {
            case Sunday = "Sunday"
            case Monday = "Monday"
            case Tuesday = "Tuesday"
            case Wednesday = "Wednesday"
            case Thursday = "Thursday"
            case Friday = "Friday"
            case Saturday = "Saturday"
            case Everyday = "Everyday"
            case Weekday = "Weekday"
            case Weekend = "Weekend"
        }
        /// - Remark: Generated from `#/components/schemas/EncodingContext`.
        @frozen public enum EncodingContext: String, Codable, Hashable, Sendable, CaseIterable {
            case Streaming = "Streaming"
            case Static = "Static"
        }
        /// - Remark: Generated from `#/components/schemas/ExternalUrl`.
        public struct ExternalUrl: Codable, Hashable, Sendable {
            /// Gets or sets the name.
            ///
            /// - Remark: Generated from `#/components/schemas/ExternalUrl/Name`.
            public var Name: Swift.String?
            /// Gets or sets the type of the item.
            ///
            /// - Remark: Generated from `#/components/schemas/ExternalUrl/Url`.
            public var Url: Swift.String?
            /// Creates a new `ExternalUrl`.
            ///
            /// - Parameters:
            ///   - Name: Gets or sets the name.
            ///   - Url: Gets or sets the type of the item.
            public init(
                Name: Swift.String? = nil,
                Url: Swift.String? = nil
            ) {
                self.Name = Name
                self.Url = Url
            }
            public enum CodingKeys: String, CodingKey {
                case Name
                case Url
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Name = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Name
                )
                Url = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Url
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Name",
                    "Url"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/ExtraType`.
        @frozen public enum ExtraType: String, Codable, Hashable, Sendable, CaseIterable {
            case Unknown = "Unknown"
            case Clip = "Clip"
            case Trailer = "Trailer"
            case BehindTheScenes = "BehindTheScenes"
            case DeletedScene = "DeletedScene"
            case Interview = "Interview"
            case Scene = "Scene"
            case Sample = "Sample"
            case ThemeSong = "ThemeSong"
            case ThemeVideo = "ThemeVideo"
            case Featurette = "Featurette"
            case Short = "Short"
        }
        /// This exists simply to identify a set of known commands.
        ///
        /// - Remark: Generated from `#/components/schemas/GeneralCommandType`.
        @frozen public enum GeneralCommandType: String, Codable, Hashable, Sendable, CaseIterable {
            case MoveUp = "MoveUp"
            case MoveDown = "MoveDown"
            case MoveLeft = "MoveLeft"
            case MoveRight = "MoveRight"
            case PageUp = "PageUp"
            case PageDown = "PageDown"
            case PreviousLetter = "PreviousLetter"
            case NextLetter = "NextLetter"
            case ToggleOsd = "ToggleOsd"
            case ToggleContextMenu = "ToggleContextMenu"
            case Select = "Select"
            case Back = "Back"
            case TakeScreenshot = "TakeScreenshot"
            case SendKey = "SendKey"
            case SendString = "SendString"
            case GoHome = "GoHome"
            case GoToSettings = "GoToSettings"
            case VolumeUp = "VolumeUp"
            case VolumeDown = "VolumeDown"
            case Mute = "Mute"
            case Unmute = "Unmute"
            case ToggleMute = "ToggleMute"
            case SetVolume = "SetVolume"
            case SetAudioStreamIndex = "SetAudioStreamIndex"
            case SetSubtitleStreamIndex = "SetSubtitleStreamIndex"
            case ToggleFullscreen = "ToggleFullscreen"
            case DisplayContent = "DisplayContent"
            case GoToSearch = "GoToSearch"
            case DisplayMessage = "DisplayMessage"
            case SetRepeatMode = "SetRepeatMode"
            case ChannelUp = "ChannelUp"
            case ChannelDown = "ChannelDown"
            case Guide = "Guide"
            case ToggleStats = "ToggleStats"
            case PlayMediaSource = "PlayMediaSource"
            case PlayTrailers = "PlayTrailers"
            case SetShuffleQueue = "SetShuffleQueue"
            case PlayState = "PlayState"
            case PlayNext = "PlayNext"
            case ToggleOsdMenu = "ToggleOsdMenu"
            case Play = "Play"
            case SetMaxStreamingBitrate = "SetMaxStreamingBitrate"
            case SetPlaybackOrder = "SetPlaybackOrder"
        }
        /// Enum containing hardware acceleration types.
        ///
        /// - Remark: Generated from `#/components/schemas/HardwareAccelerationType`.
        @frozen public enum HardwareAccelerationType: String, Codable, Hashable, Sendable, CaseIterable {
            case none = "none"
            case amf = "amf"
            case qsv = "qsv"
            case nvenc = "nvenc"
            case v4l2m2m = "v4l2m2m"
            case vaapi = "vaapi"
            case videotoolbox = "videotoolbox"
            case rkmpp = "rkmpp"
        }
        /// - Remark: Generated from `#/components/schemas/ImageOrientation`.
        @frozen public enum ImageOrientation: String, Codable, Hashable, Sendable, CaseIterable {
            case TopLeft = "TopLeft"
            case TopRight = "TopRight"
            case BottomRight = "BottomRight"
            case BottomLeft = "BottomLeft"
            case LeftTop = "LeftTop"
            case RightTop = "RightTop"
            case RightBottom = "RightBottom"
            case LeftBottom = "LeftBottom"
        }
        /// Enum ImageType.
        ///
        /// - Remark: Generated from `#/components/schemas/ImageType`.
        @frozen public enum ImageType: String, Codable, Hashable, Sendable, CaseIterable {
            case Primary = "Primary"
            case Art = "Art"
            case Backdrop = "Backdrop"
            case Banner = "Banner"
            case Logo = "Logo"
            case Thumb = "Thumb"
            case Disc = "Disc"
            case Box = "Box"
            case Screenshot = "Screenshot"
            case Menu = "Menu"
            case Chapter = "Chapter"
            case BoxRear = "BoxRear"
            case Profile = "Profile"
        }
        /// Enum IsoType.
        ///
        /// - Remark: Generated from `#/components/schemas/IsoType`.
        @frozen public enum IsoType: String, Codable, Hashable, Sendable, CaseIterable {
            case Dvd = "Dvd"
            case BluRay = "BluRay"
        }
        /// Used to control the data that gets attached to DtoBaseItems.
        ///
        /// - Remark: Generated from `#/components/schemas/ItemFields`.
        @frozen public enum ItemFields: String, Codable, Hashable, Sendable, CaseIterable {
            case AirTime = "AirTime"
            case CanDelete = "CanDelete"
            case CanDownload = "CanDownload"
            case ChannelInfo = "ChannelInfo"
            case Chapters = "Chapters"
            case Trickplay = "Trickplay"
            case ChildCount = "ChildCount"
            case CumulativeRunTimeTicks = "CumulativeRunTimeTicks"
            case CustomRating = "CustomRating"
            case DateCreated = "DateCreated"
            case DateLastMediaAdded = "DateLastMediaAdded"
            case DisplayPreferencesId = "DisplayPreferencesId"
            case Etag = "Etag"
            case ExternalUrls = "ExternalUrls"
            case Genres = "Genres"
            case HomePageUrl = "HomePageUrl"
            case ItemCounts = "ItemCounts"
            case MediaSourceCount = "MediaSourceCount"
            case MediaSources = "MediaSources"
            case OriginalTitle = "OriginalTitle"
            case Overview = "Overview"
            case ParentId = "ParentId"
            case Path = "Path"
            case People = "People"
            case PlayAccess = "PlayAccess"
            case ProductionLocations = "ProductionLocations"
            case ProviderIds = "ProviderIds"
            case PrimaryImageAspectRatio = "PrimaryImageAspectRatio"
            case RecursiveItemCount = "RecursiveItemCount"
            case Settings = "Settings"
            case ScreenshotImageTags = "ScreenshotImageTags"
            case SeriesPrimaryImage = "SeriesPrimaryImage"
            case SeriesStudio = "SeriesStudio"
            case SortName = "SortName"
            case SpecialEpisodeNumbers = "SpecialEpisodeNumbers"
            case Studios = "Studios"
            case Taglines = "Taglines"
            case Tags = "Tags"
            case RemoteTrailers = "RemoteTrailers"
            case MediaStreams = "MediaStreams"
            case SeasonUserData = "SeasonUserData"
            case ServiceName = "ServiceName"
            case ThemeSongIds = "ThemeSongIds"
            case ThemeVideoIds = "ThemeVideoIds"
            case ExternalEtag = "ExternalEtag"
            case PresentationUniqueKey = "PresentationUniqueKey"
            case InheritedParentalRatingValue = "InheritedParentalRatingValue"
            case ExternalSeriesId = "ExternalSeriesId"
            case SeriesPresentationUniqueKey = "SeriesPresentationUniqueKey"
            case DateLastRefreshed = "DateLastRefreshed"
            case DateLastSaved = "DateLastSaved"
            case RefreshState = "RefreshState"
            case ChannelImage = "ChannelImage"
            case EnableMediaSourceDisplay = "EnableMediaSourceDisplay"
            case Width = "Width"
            case Height = "Height"
            case ExtraIds = "ExtraIds"
            case LocalTrailerCount = "LocalTrailerCount"
            case IsHD = "IsHD"
            case SpecialFeatureCount = "SpecialFeatureCount"
        }
        /// Enum ItemFilter.
        ///
        /// - Remark: Generated from `#/components/schemas/ItemFilter`.
        @frozen public enum ItemFilter: String, Codable, Hashable, Sendable, CaseIterable {
            case IsFolder = "IsFolder"
            case IsNotFolder = "IsNotFolder"
            case IsUnplayed = "IsUnplayed"
            case IsPlayed = "IsPlayed"
            case IsFavorite = "IsFavorite"
            case IsResumable = "IsResumable"
            case Likes = "Likes"
            case Dislikes = "Dislikes"
            case IsFavoriteOrLikes = "IsFavoriteOrLikes"
        }
        /// These represent sort orders.
        ///
        /// - Remark: Generated from `#/components/schemas/ItemSortBy`.
        @frozen public enum ItemSortBy: String, Codable, Hashable, Sendable, CaseIterable {
            case Default = "Default"
            case AiredEpisodeOrder = "AiredEpisodeOrder"
            case Album = "Album"
            case AlbumArtist = "AlbumArtist"
            case Artist = "Artist"
            case DateCreated = "DateCreated"
            case OfficialRating = "OfficialRating"
            case DatePlayed = "DatePlayed"
            case PremiereDate = "PremiereDate"
            case StartDate = "StartDate"
            case SortName = "SortName"
            case Name = "Name"
            case Random = "Random"
            case Runtime = "Runtime"
            case CommunityRating = "CommunityRating"
            case ProductionYear = "ProductionYear"
            case PlayCount = "PlayCount"
            case CriticRating = "CriticRating"
            case IsFolder = "IsFolder"
            case IsUnplayed = "IsUnplayed"
            case IsPlayed = "IsPlayed"
            case SeriesSortName = "SeriesSortName"
            case VideoBitRate = "VideoBitRate"
            case AirTime = "AirTime"
            case Studio = "Studio"
            case IsFavoriteOrLiked = "IsFavoriteOrLiked"
            case DateLastContentAdded = "DateLastContentAdded"
            case SeriesDatePlayed = "SeriesDatePlayed"
            case ParentIndexNumber = "ParentIndexNumber"
            case IndexNumber = "IndexNumber"
            case SimilarityScore = "SimilarityScore"
            case SearchScore = "SearchScore"
        }
        /// Enum LocationType.
        ///
        /// - Remark: Generated from `#/components/schemas/LocationType`.
        @frozen public enum LocationType: String, Codable, Hashable, Sendable, CaseIterable {
            case FileSystem = "FileSystem"
            case Remote = "Remote"
            case Virtual = "Virtual"
            case Offline = "Offline"
        }
        /// Class MediaAttachment.
        ///
        /// - Remark: Generated from `#/components/schemas/MediaAttachment`.
        public struct MediaAttachment: Codable, Hashable, Sendable {
            /// Gets or sets the codec.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaAttachment/Codec`.
            public var Codec: Swift.String?
            /// Gets or sets the codec tag.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaAttachment/CodecTag`.
            public var CodecTag: Swift.String?
            /// Gets or sets the comment.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaAttachment/Comment`.
            public var Comment: Swift.String?
            /// Gets or sets the index.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaAttachment/Index`.
            public var Index: Swift.Int32?
            /// Gets or sets the filename.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaAttachment/FileName`.
            public var FileName: Swift.String?
            /// Gets or sets the MIME type.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaAttachment/MimeType`.
            public var MimeType: Swift.String?
            /// Gets or sets the delivery URL.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaAttachment/DeliveryUrl`.
            public var DeliveryUrl: Swift.String?
            /// Creates a new `MediaAttachment`.
            ///
            /// - Parameters:
            ///   - Codec: Gets or sets the codec.
            ///   - CodecTag: Gets or sets the codec tag.
            ///   - Comment: Gets or sets the comment.
            ///   - Index: Gets or sets the index.
            ///   - FileName: Gets or sets the filename.
            ///   - MimeType: Gets or sets the MIME type.
            ///   - DeliveryUrl: Gets or sets the delivery URL.
            public init(
                Codec: Swift.String? = nil,
                CodecTag: Swift.String? = nil,
                Comment: Swift.String? = nil,
                Index: Swift.Int32? = nil,
                FileName: Swift.String? = nil,
                MimeType: Swift.String? = nil,
                DeliveryUrl: Swift.String? = nil
            ) {
                self.Codec = Codec
                self.CodecTag = CodecTag
                self.Comment = Comment
                self.Index = Index
                self.FileName = FileName
                self.MimeType = MimeType
                self.DeliveryUrl = DeliveryUrl
            }
            public enum CodingKeys: String, CodingKey {
                case Codec
                case CodecTag
                case Comment
                case Index
                case FileName
                case MimeType
                case DeliveryUrl
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Codec = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Codec
                )
                CodecTag = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .CodecTag
                )
                Comment = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Comment
                )
                Index = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .Index
                )
                FileName = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .FileName
                )
                MimeType = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .MimeType
                )
                DeliveryUrl = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .DeliveryUrl
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Codec",
                    "CodecTag",
                    "Comment",
                    "Index",
                    "FileName",
                    "MimeType",
                    "DeliveryUrl"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/MediaProtocol`.
        @frozen public enum MediaProtocol: String, Codable, Hashable, Sendable, CaseIterable {
            case File = "File"
            case Http = "Http"
            case Rtmp = "Rtmp"
            case Rtsp = "Rtsp"
            case Udp = "Udp"
            case Rtp = "Rtp"
            case Ftp = "Ftp"
        }
        /// - Remark: Generated from `#/components/schemas/MediaSourceInfo`.
        public struct MediaSourceInfo: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Protocol`.
            public struct _ProtocolPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Protocol/value1`.
                public var value1: Components.Schemas.MediaProtocol
                /// Creates a new `_ProtocolPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.MediaProtocol) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Protocol`.
            public var _Protocol: Components.Schemas.MediaSourceInfo._ProtocolPayload?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Id`.
            public var Id: Swift.String?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Path`.
            public var Path: Swift.String?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/EncoderPath`.
            public var EncoderPath: Swift.String?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/EncoderProtocol`.
            public struct EncoderProtocolPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/EncoderProtocol/value1`.
                public var value1: Components.Schemas.MediaProtocol
                /// Creates a new `EncoderProtocolPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.MediaProtocol) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/EncoderProtocol`.
            public var EncoderProtocol: Components.Schemas.MediaSourceInfo.EncoderProtocolPayload?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Type`.
            public struct _TypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Type/value1`.
                public var value1: Components.Schemas.MediaSourceType
                /// Creates a new `_TypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.MediaSourceType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Type`.
            public var _Type: Components.Schemas.MediaSourceInfo._TypePayload?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Container`.
            public var Container: Swift.String?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Size`.
            public var Size: Swift.Int64?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Name`.
            public var Name: Swift.String?
            /// Gets or sets a value indicating whether the media is remote.
            /// Differentiate internet url vs local network.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/IsRemote`.
            public var IsRemote: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/ETag`.
            public var ETag: Swift.String?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/RunTimeTicks`.
            public var RunTimeTicks: Swift.Int64?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/ReadAtNativeFramerate`.
            public var ReadAtNativeFramerate: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/IgnoreDts`.
            public var IgnoreDts: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/IgnoreIndex`.
            public var IgnoreIndex: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/GenPtsInput`.
            public var GenPtsInput: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/SupportsTranscoding`.
            public var SupportsTranscoding: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/SupportsDirectStream`.
            public var SupportsDirectStream: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/SupportsDirectPlay`.
            public var SupportsDirectPlay: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/IsInfiniteStream`.
            public var IsInfiniteStream: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/UseMostCompatibleTranscodingProfile`.
            public var UseMostCompatibleTranscodingProfile: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/RequiresOpening`.
            public var RequiresOpening: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/OpenToken`.
            public var OpenToken: Swift.String?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/RequiresClosing`.
            public var RequiresClosing: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/LiveStreamId`.
            public var LiveStreamId: Swift.String?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/BufferMs`.
            public var BufferMs: Swift.Int32?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/RequiresLooping`.
            public var RequiresLooping: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/SupportsProbing`.
            public var SupportsProbing: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/VideoType`.
            public struct VideoTypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/VideoType/value1`.
                public var value1: Components.Schemas.VideoType
                /// Creates a new `VideoTypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.VideoType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/VideoType`.
            public var VideoType: Components.Schemas.MediaSourceInfo.VideoTypePayload?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/IsoType`.
            public struct IsoTypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/IsoType/value1`.
                public var value1: Components.Schemas.IsoType
                /// Creates a new `IsoTypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.IsoType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/IsoType`.
            public var IsoType: Components.Schemas.MediaSourceInfo.IsoTypePayload?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Video3DFormat`.
            public struct Video3DFormatPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Video3DFormat/value1`.
                public var value1: Components.Schemas.Video3DFormat
                /// Creates a new `Video3DFormatPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.Video3DFormat) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Video3DFormat`.
            public var Video3DFormat: Components.Schemas.MediaSourceInfo.Video3DFormatPayload?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/MediaStreams`.
            public var MediaStreams: [Components.Schemas.MediaStream]?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/MediaAttachments`.
            public var MediaAttachments: [Components.Schemas.MediaAttachment]?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Formats`.
            public var Formats: [Swift.String]?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Bitrate`.
            public var Bitrate: Swift.Int32?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/FallbackMaxStreamingBitrate`.
            public var FallbackMaxStreamingBitrate: Swift.Int32?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Timestamp`.
            public struct TimestampPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Timestamp/value1`.
                public var value1: Components.Schemas.TransportStreamTimestamp
                /// Creates a new `TimestampPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.TransportStreamTimestamp) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/Timestamp`.
            public var Timestamp: Components.Schemas.MediaSourceInfo.TimestampPayload?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/RequiredHttpHeaders`.
            public struct RequiredHttpHeadersPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.String?]
                /// Creates a new `RequiredHttpHeadersPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: [String: Swift.String?] = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/RequiredHttpHeaders`.
            public var RequiredHttpHeaders: Components.Schemas.MediaSourceInfo.RequiredHttpHeadersPayload?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/TranscodingUrl`.
            public var TranscodingUrl: Swift.String?
            /// Media streaming protocol.
            /// Lowercase for backwards compatibility.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/TranscodingSubProtocol`.
            public struct TranscodingSubProtocolPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/TranscodingSubProtocol/value1`.
                public var value1: Components.Schemas.MediaStreamProtocol
                /// Creates a new `TranscodingSubProtocolPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.MediaStreamProtocol) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Media streaming protocol.
            /// Lowercase for backwards compatibility.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/TranscodingSubProtocol`.
            public var TranscodingSubProtocol: Components.Schemas.MediaSourceInfo.TranscodingSubProtocolPayload?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/TranscodingContainer`.
            public var TranscodingContainer: Swift.String?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/AnalyzeDurationMs`.
            public var AnalyzeDurationMs: Swift.Int32?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/DefaultAudioStreamIndex`.
            public var DefaultAudioStreamIndex: Swift.Int32?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/DefaultSubtitleStreamIndex`.
            public var DefaultSubtitleStreamIndex: Swift.Int32?
            /// - Remark: Generated from `#/components/schemas/MediaSourceInfo/HasSegments`.
            public var HasSegments: Swift.Bool?
            /// Creates a new `MediaSourceInfo`.
            ///
            /// - Parameters:
            ///   - _Protocol:
            ///   - Id:
            ///   - Path:
            ///   - EncoderPath:
            ///   - EncoderProtocol:
            ///   - _Type:
            ///   - Container:
            ///   - Size:
            ///   - Name:
            ///   - IsRemote: Gets or sets a value indicating whether the media is remote.
            /// Differentiate internet url vs local network.
            ///   - ETag:
            ///   - RunTimeTicks:
            ///   - ReadAtNativeFramerate:
            ///   - IgnoreDts:
            ///   - IgnoreIndex:
            ///   - GenPtsInput:
            ///   - SupportsTranscoding:
            ///   - SupportsDirectStream:
            ///   - SupportsDirectPlay:
            ///   - IsInfiniteStream:
            ///   - UseMostCompatibleTranscodingProfile:
            ///   - RequiresOpening:
            ///   - OpenToken:
            ///   - RequiresClosing:
            ///   - LiveStreamId:
            ///   - BufferMs:
            ///   - RequiresLooping:
            ///   - SupportsProbing:
            ///   - VideoType:
            ///   - IsoType:
            ///   - Video3DFormat:
            ///   - MediaStreams:
            ///   - MediaAttachments:
            ///   - Formats:
            ///   - Bitrate:
            ///   - FallbackMaxStreamingBitrate:
            ///   - Timestamp:
            ///   - RequiredHttpHeaders:
            ///   - TranscodingUrl:
            ///   - TranscodingSubProtocol: Media streaming protocol.
            /// Lowercase for backwards compatibility.
            ///   - TranscodingContainer:
            ///   - AnalyzeDurationMs:
            ///   - DefaultAudioStreamIndex:
            ///   - DefaultSubtitleStreamIndex:
            ///   - HasSegments:
            public init(
                _Protocol: Components.Schemas.MediaSourceInfo._ProtocolPayload? = nil,
                Id: Swift.String? = nil,
                Path: Swift.String? = nil,
                EncoderPath: Swift.String? = nil,
                EncoderProtocol: Components.Schemas.MediaSourceInfo.EncoderProtocolPayload? = nil,
                _Type: Components.Schemas.MediaSourceInfo._TypePayload? = nil,
                Container: Swift.String? = nil,
                Size: Swift.Int64? = nil,
                Name: Swift.String? = nil,
                IsRemote: Swift.Bool? = nil,
                ETag: Swift.String? = nil,
                RunTimeTicks: Swift.Int64? = nil,
                ReadAtNativeFramerate: Swift.Bool? = nil,
                IgnoreDts: Swift.Bool? = nil,
                IgnoreIndex: Swift.Bool? = nil,
                GenPtsInput: Swift.Bool? = nil,
                SupportsTranscoding: Swift.Bool? = nil,
                SupportsDirectStream: Swift.Bool? = nil,
                SupportsDirectPlay: Swift.Bool? = nil,
                IsInfiniteStream: Swift.Bool? = nil,
                UseMostCompatibleTranscodingProfile: Swift.Bool? = nil,
                RequiresOpening: Swift.Bool? = nil,
                OpenToken: Swift.String? = nil,
                RequiresClosing: Swift.Bool? = nil,
                LiveStreamId: Swift.String? = nil,
                BufferMs: Swift.Int32? = nil,
                RequiresLooping: Swift.Bool? = nil,
                SupportsProbing: Swift.Bool? = nil,
                VideoType: Components.Schemas.MediaSourceInfo.VideoTypePayload? = nil,
                IsoType: Components.Schemas.MediaSourceInfo.IsoTypePayload? = nil,
                Video3DFormat: Components.Schemas.MediaSourceInfo.Video3DFormatPayload? = nil,
                MediaStreams: [Components.Schemas.MediaStream]? = nil,
                MediaAttachments: [Components.Schemas.MediaAttachment]? = nil,
                Formats: [Swift.String]? = nil,
                Bitrate: Swift.Int32? = nil,
                FallbackMaxStreamingBitrate: Swift.Int32? = nil,
                Timestamp: Components.Schemas.MediaSourceInfo.TimestampPayload? = nil,
                RequiredHttpHeaders: Components.Schemas.MediaSourceInfo.RequiredHttpHeadersPayload? = nil,
                TranscodingUrl: Swift.String? = nil,
                TranscodingSubProtocol: Components.Schemas.MediaSourceInfo.TranscodingSubProtocolPayload? = nil,
                TranscodingContainer: Swift.String? = nil,
                AnalyzeDurationMs: Swift.Int32? = nil,
                DefaultAudioStreamIndex: Swift.Int32? = nil,
                DefaultSubtitleStreamIndex: Swift.Int32? = nil,
                HasSegments: Swift.Bool? = nil
            ) {
                self._Protocol = _Protocol
                self.Id = Id
                self.Path = Path
                self.EncoderPath = EncoderPath
                self.EncoderProtocol = EncoderProtocol
                self._Type = _Type
                self.Container = Container
                self.Size = Size
                self.Name = Name
                self.IsRemote = IsRemote
                self.ETag = ETag
                self.RunTimeTicks = RunTimeTicks
                self.ReadAtNativeFramerate = ReadAtNativeFramerate
                self.IgnoreDts = IgnoreDts
                self.IgnoreIndex = IgnoreIndex
                self.GenPtsInput = GenPtsInput
                self.SupportsTranscoding = SupportsTranscoding
                self.SupportsDirectStream = SupportsDirectStream
                self.SupportsDirectPlay = SupportsDirectPlay
                self.IsInfiniteStream = IsInfiniteStream
                self.UseMostCompatibleTranscodingProfile = UseMostCompatibleTranscodingProfile
                self.RequiresOpening = RequiresOpening
                self.OpenToken = OpenToken
                self.RequiresClosing = RequiresClosing
                self.LiveStreamId = LiveStreamId
                self.BufferMs = BufferMs
                self.RequiresLooping = RequiresLooping
                self.SupportsProbing = SupportsProbing
                self.VideoType = VideoType
                self.IsoType = IsoType
                self.Video3DFormat = Video3DFormat
                self.MediaStreams = MediaStreams
                self.MediaAttachments = MediaAttachments
                self.Formats = Formats
                self.Bitrate = Bitrate
                self.FallbackMaxStreamingBitrate = FallbackMaxStreamingBitrate
                self.Timestamp = Timestamp
                self.RequiredHttpHeaders = RequiredHttpHeaders
                self.TranscodingUrl = TranscodingUrl
                self.TranscodingSubProtocol = TranscodingSubProtocol
                self.TranscodingContainer = TranscodingContainer
                self.AnalyzeDurationMs = AnalyzeDurationMs
                self.DefaultAudioStreamIndex = DefaultAudioStreamIndex
                self.DefaultSubtitleStreamIndex = DefaultSubtitleStreamIndex
                self.HasSegments = HasSegments
            }
            public enum CodingKeys: String, CodingKey {
                case _Protocol = "Protocol"
                case Id
                case Path
                case EncoderPath
                case EncoderProtocol
                case _Type = "Type"
                case Container
                case Size
                case Name
                case IsRemote
                case ETag
                case RunTimeTicks
                case ReadAtNativeFramerate
                case IgnoreDts
                case IgnoreIndex
                case GenPtsInput
                case SupportsTranscoding
                case SupportsDirectStream
                case SupportsDirectPlay
                case IsInfiniteStream
                case UseMostCompatibleTranscodingProfile
                case RequiresOpening
                case OpenToken
                case RequiresClosing
                case LiveStreamId
                case BufferMs
                case RequiresLooping
                case SupportsProbing
                case VideoType
                case IsoType
                case Video3DFormat
                case MediaStreams
                case MediaAttachments
                case Formats
                case Bitrate
                case FallbackMaxStreamingBitrate
                case Timestamp
                case RequiredHttpHeaders
                case TranscodingUrl
                case TranscodingSubProtocol
                case TranscodingContainer
                case AnalyzeDurationMs
                case DefaultAudioStreamIndex
                case DefaultSubtitleStreamIndex
                case HasSegments
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                _Protocol = try container.decodeIfPresent(
                    Components.Schemas.MediaSourceInfo._ProtocolPayload.self,
                    forKey: ._Protocol
                )
                Id = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Id
                )
                Path = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Path
                )
                EncoderPath = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .EncoderPath
                )
                EncoderProtocol = try container.decodeIfPresent(
                    Components.Schemas.MediaSourceInfo.EncoderProtocolPayload.self,
                    forKey: .EncoderProtocol
                )
                _Type = try container.decodeIfPresent(
                    Components.Schemas.MediaSourceInfo._TypePayload.self,
                    forKey: ._Type
                )
                Container = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Container
                )
                Size = try container.decodeIfPresent(
                    Swift.Int64.self,
                    forKey: .Size
                )
                Name = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Name
                )
                IsRemote = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsRemote
                )
                ETag = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ETag
                )
                RunTimeTicks = try container.decodeIfPresent(
                    Swift.Int64.self,
                    forKey: .RunTimeTicks
                )
                ReadAtNativeFramerate = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .ReadAtNativeFramerate
                )
                IgnoreDts = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IgnoreDts
                )
                IgnoreIndex = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IgnoreIndex
                )
                GenPtsInput = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .GenPtsInput
                )
                SupportsTranscoding = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .SupportsTranscoding
                )
                SupportsDirectStream = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .SupportsDirectStream
                )
                SupportsDirectPlay = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .SupportsDirectPlay
                )
                IsInfiniteStream = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsInfiniteStream
                )
                UseMostCompatibleTranscodingProfile = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .UseMostCompatibleTranscodingProfile
                )
                RequiresOpening = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .RequiresOpening
                )
                OpenToken = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .OpenToken
                )
                RequiresClosing = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .RequiresClosing
                )
                LiveStreamId = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .LiveStreamId
                )
                BufferMs = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .BufferMs
                )
                RequiresLooping = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .RequiresLooping
                )
                SupportsProbing = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .SupportsProbing
                )
                VideoType = try container.decodeIfPresent(
                    Components.Schemas.MediaSourceInfo.VideoTypePayload.self,
                    forKey: .VideoType
                )
                IsoType = try container.decodeIfPresent(
                    Components.Schemas.MediaSourceInfo.IsoTypePayload.self,
                    forKey: .IsoType
                )
                Video3DFormat = try container.decodeIfPresent(
                    Components.Schemas.MediaSourceInfo.Video3DFormatPayload.self,
                    forKey: .Video3DFormat
                )
                MediaStreams = try container.decodeIfPresent(
                    [Components.Schemas.MediaStream].self,
                    forKey: .MediaStreams
                )
                MediaAttachments = try container.decodeIfPresent(
                    [Components.Schemas.MediaAttachment].self,
                    forKey: .MediaAttachments
                )
                Formats = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .Formats
                )
                Bitrate = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .Bitrate
                )
                FallbackMaxStreamingBitrate = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .FallbackMaxStreamingBitrate
                )
                Timestamp = try container.decodeIfPresent(
                    Components.Schemas.MediaSourceInfo.TimestampPayload.self,
                    forKey: .Timestamp
                )
                RequiredHttpHeaders = try container.decodeIfPresent(
                    Components.Schemas.MediaSourceInfo.RequiredHttpHeadersPayload.self,
                    forKey: .RequiredHttpHeaders
                )
                TranscodingUrl = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .TranscodingUrl
                )
                TranscodingSubProtocol = try container.decodeIfPresent(
                    Components.Schemas.MediaSourceInfo.TranscodingSubProtocolPayload.self,
                    forKey: .TranscodingSubProtocol
                )
                TranscodingContainer = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .TranscodingContainer
                )
                AnalyzeDurationMs = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .AnalyzeDurationMs
                )
                DefaultAudioStreamIndex = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .DefaultAudioStreamIndex
                )
                DefaultSubtitleStreamIndex = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .DefaultSubtitleStreamIndex
                )
                HasSegments = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .HasSegments
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Protocol",
                    "Id",
                    "Path",
                    "EncoderPath",
                    "EncoderProtocol",
                    "Type",
                    "Container",
                    "Size",
                    "Name",
                    "IsRemote",
                    "ETag",
                    "RunTimeTicks",
                    "ReadAtNativeFramerate",
                    "IgnoreDts",
                    "IgnoreIndex",
                    "GenPtsInput",
                    "SupportsTranscoding",
                    "SupportsDirectStream",
                    "SupportsDirectPlay",
                    "IsInfiniteStream",
                    "UseMostCompatibleTranscodingProfile",
                    "RequiresOpening",
                    "OpenToken",
                    "RequiresClosing",
                    "LiveStreamId",
                    "BufferMs",
                    "RequiresLooping",
                    "SupportsProbing",
                    "VideoType",
                    "IsoType",
                    "Video3DFormat",
                    "MediaStreams",
                    "MediaAttachments",
                    "Formats",
                    "Bitrate",
                    "FallbackMaxStreamingBitrate",
                    "Timestamp",
                    "RequiredHttpHeaders",
                    "TranscodingUrl",
                    "TranscodingSubProtocol",
                    "TranscodingContainer",
                    "AnalyzeDurationMs",
                    "DefaultAudioStreamIndex",
                    "DefaultSubtitleStreamIndex",
                    "HasSegments"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/MediaSourceType`.
        @frozen public enum MediaSourceType: String, Codable, Hashable, Sendable, CaseIterable {
            case Default = "Default"
            case Grouping = "Grouping"
            case Placeholder = "Placeholder"
        }
        /// Class MediaStream.
        ///
        /// - Remark: Generated from `#/components/schemas/MediaStream`.
        public struct MediaStream: Codable, Hashable, Sendable {
            /// Gets or sets the codec.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/Codec`.
            public var Codec: Swift.String?
            /// Gets or sets the codec tag.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/CodecTag`.
            public var CodecTag: Swift.String?
            /// Gets or sets the language.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/Language`.
            public var Language: Swift.String?
            /// Gets or sets the color range.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/ColorRange`.
            public var ColorRange: Swift.String?
            /// Gets or sets the color space.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/ColorSpace`.
            public var ColorSpace: Swift.String?
            /// Gets or sets the color transfer.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/ColorTransfer`.
            public var ColorTransfer: Swift.String?
            /// Gets or sets the color primaries.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/ColorPrimaries`.
            public var ColorPrimaries: Swift.String?
            /// Gets or sets the Dolby Vision version major.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/DvVersionMajor`.
            public var DvVersionMajor: Swift.Int32?
            /// Gets or sets the Dolby Vision version minor.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/DvVersionMinor`.
            public var DvVersionMinor: Swift.Int32?
            /// Gets or sets the Dolby Vision profile.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/DvProfile`.
            public var DvProfile: Swift.Int32?
            /// Gets or sets the Dolby Vision level.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/DvLevel`.
            public var DvLevel: Swift.Int32?
            /// Gets or sets the Dolby Vision rpu present flag.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/RpuPresentFlag`.
            public var RpuPresentFlag: Swift.Int32?
            /// Gets or sets the Dolby Vision el present flag.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/ElPresentFlag`.
            public var ElPresentFlag: Swift.Int32?
            /// Gets or sets the Dolby Vision bl present flag.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/BlPresentFlag`.
            public var BlPresentFlag: Swift.Int32?
            /// Gets or sets the Dolby Vision bl signal compatibility id.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/DvBlSignalCompatibilityId`.
            public var DvBlSignalCompatibilityId: Swift.Int32?
            /// Gets or sets the Rotation in degrees.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/Rotation`.
            public var Rotation: Swift.Int32?
            /// Gets or sets the comment.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/Comment`.
            public var Comment: Swift.String?
            /// Gets or sets the time base.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/TimeBase`.
            public var TimeBase: Swift.String?
            /// Gets or sets the codec time base.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/CodecTimeBase`.
            public var CodecTimeBase: Swift.String?
            /// Gets or sets the title.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/Title`.
            public var Title: Swift.String?
            /// An enum representing video ranges.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/VideoRange`.
            public struct VideoRangePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/MediaStream/VideoRange/value1`.
                public var value1: Components.Schemas.VideoRange
                /// Creates a new `VideoRangePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.VideoRange) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// An enum representing video ranges.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/VideoRange`.
            public var VideoRange: Components.Schemas.MediaStream.VideoRangePayload?
            /// An enum representing types of video ranges.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/VideoRangeType`.
            public struct VideoRangeTypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/MediaStream/VideoRangeType/value1`.
                public var value1: Components.Schemas.VideoRangeType
                /// Creates a new `VideoRangeTypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.VideoRangeType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// An enum representing types of video ranges.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/VideoRangeType`.
            public var VideoRangeType: Components.Schemas.MediaStream.VideoRangeTypePayload?
            /// Gets the video dovi title.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/VideoDoViTitle`.
            public var VideoDoViTitle: Swift.String?
            /// An enum representing formats of spatial audio.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/AudioSpatialFormat`.
            public struct AudioSpatialFormatPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/MediaStream/AudioSpatialFormat/value1`.
                public var value1: Components.Schemas.AudioSpatialFormat
                /// Creates a new `AudioSpatialFormatPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.AudioSpatialFormat) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// An enum representing formats of spatial audio.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/AudioSpatialFormat`.
            public var AudioSpatialFormat: Components.Schemas.MediaStream.AudioSpatialFormatPayload?
            /// - Remark: Generated from `#/components/schemas/MediaStream/LocalizedUndefined`.
            public var LocalizedUndefined: Swift.String?
            /// - Remark: Generated from `#/components/schemas/MediaStream/LocalizedDefault`.
            public var LocalizedDefault: Swift.String?
            /// - Remark: Generated from `#/components/schemas/MediaStream/LocalizedForced`.
            public var LocalizedForced: Swift.String?
            /// - Remark: Generated from `#/components/schemas/MediaStream/LocalizedExternal`.
            public var LocalizedExternal: Swift.String?
            /// - Remark: Generated from `#/components/schemas/MediaStream/LocalizedHearingImpaired`.
            public var LocalizedHearingImpaired: Swift.String?
            /// - Remark: Generated from `#/components/schemas/MediaStream/DisplayTitle`.
            public var DisplayTitle: Swift.String?
            /// - Remark: Generated from `#/components/schemas/MediaStream/NalLengthSize`.
            public var NalLengthSize: Swift.String?
            /// Gets or sets a value indicating whether this instance is interlaced.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/IsInterlaced`.
            public var IsInterlaced: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/MediaStream/IsAVC`.
            public var IsAVC: Swift.Bool?
            /// Gets or sets the channel layout.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/ChannelLayout`.
            public var ChannelLayout: Swift.String?
            /// Gets or sets the bit rate.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/BitRate`.
            public var BitRate: Swift.Int32?
            /// Gets or sets the bit depth.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/BitDepth`.
            public var BitDepth: Swift.Int32?
            /// Gets or sets the reference frames.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/RefFrames`.
            public var RefFrames: Swift.Int32?
            /// Gets or sets the length of the packet.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/PacketLength`.
            public var PacketLength: Swift.Int32?
            /// Gets or sets the channels.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/Channels`.
            public var Channels: Swift.Int32?
            /// Gets or sets the sample rate.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/SampleRate`.
            public var SampleRate: Swift.Int32?
            /// Gets or sets a value indicating whether this instance is default.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/IsDefault`.
            public var IsDefault: Swift.Bool?
            /// Gets or sets a value indicating whether this instance is forced.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/IsForced`.
            public var IsForced: Swift.Bool?
            /// Gets or sets a value indicating whether this instance is for the hearing impaired.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/IsHearingImpaired`.
            public var IsHearingImpaired: Swift.Bool?
            /// Gets or sets the height.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/Height`.
            public var Height: Swift.Int32?
            /// Gets or sets the width.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/Width`.
            public var Width: Swift.Int32?
            /// Gets or sets the average frame rate.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/AverageFrameRate`.
            public var AverageFrameRate: Swift.Float?
            /// Gets or sets the real frame rate.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/RealFrameRate`.
            public var RealFrameRate: Swift.Float?
            /// Gets the framerate used as reference.
            /// Prefer AverageFrameRate, if that is null or an unrealistic value
            /// then fallback to RealFrameRate.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/ReferenceFrameRate`.
            public var ReferenceFrameRate: Swift.Float?
            /// Gets or sets the profile.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/Profile`.
            public var Profile: Swift.String?
            /// Gets or sets the type.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/Type`.
            public struct _TypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/MediaStream/Type/value1`.
                public var value1: Components.Schemas.MediaStreamType
                /// Creates a new `_TypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.MediaStreamType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the type.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/Type`.
            public var _Type: Components.Schemas.MediaStream._TypePayload?
            /// Gets or sets the aspect ratio.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/AspectRatio`.
            public var AspectRatio: Swift.String?
            /// Gets or sets the index.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/Index`.
            public var Index: Swift.Int32?
            /// Gets or sets the score.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/Score`.
            public var Score: Swift.Int32?
            /// Gets or sets a value indicating whether this instance is external.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/IsExternal`.
            public var IsExternal: Swift.Bool?
            /// Gets or sets the method.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/DeliveryMethod`.
            public struct DeliveryMethodPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/MediaStream/DeliveryMethod/value1`.
                public var value1: Components.Schemas.SubtitleDeliveryMethod
                /// Creates a new `DeliveryMethodPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.SubtitleDeliveryMethod) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the method.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/DeliveryMethod`.
            public var DeliveryMethod: Components.Schemas.MediaStream.DeliveryMethodPayload?
            /// Gets or sets the delivery URL.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/DeliveryUrl`.
            public var DeliveryUrl: Swift.String?
            /// Gets or sets a value indicating whether this instance is external URL.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/IsExternalUrl`.
            public var IsExternalUrl: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/MediaStream/IsTextSubtitleStream`.
            public var IsTextSubtitleStream: Swift.Bool?
            /// Gets or sets a value indicating whether [supports external stream].
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/SupportsExternalStream`.
            public var SupportsExternalStream: Swift.Bool?
            /// Gets or sets the filename.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/Path`.
            public var Path: Swift.String?
            /// Gets or sets the pixel format.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/PixelFormat`.
            public var PixelFormat: Swift.String?
            /// Gets or sets the level.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/Level`.
            public var Level: Swift.Double?
            /// Gets or sets whether this instance is anamorphic.
            ///
            /// - Remark: Generated from `#/components/schemas/MediaStream/IsAnamorphic`.
            public var IsAnamorphic: Swift.Bool?
            /// Creates a new `MediaStream`.
            ///
            /// - Parameters:
            ///   - Codec: Gets or sets the codec.
            ///   - CodecTag: Gets or sets the codec tag.
            ///   - Language: Gets or sets the language.
            ///   - ColorRange: Gets or sets the color range.
            ///   - ColorSpace: Gets or sets the color space.
            ///   - ColorTransfer: Gets or sets the color transfer.
            ///   - ColorPrimaries: Gets or sets the color primaries.
            ///   - DvVersionMajor: Gets or sets the Dolby Vision version major.
            ///   - DvVersionMinor: Gets or sets the Dolby Vision version minor.
            ///   - DvProfile: Gets or sets the Dolby Vision profile.
            ///   - DvLevel: Gets or sets the Dolby Vision level.
            ///   - RpuPresentFlag: Gets or sets the Dolby Vision rpu present flag.
            ///   - ElPresentFlag: Gets or sets the Dolby Vision el present flag.
            ///   - BlPresentFlag: Gets or sets the Dolby Vision bl present flag.
            ///   - DvBlSignalCompatibilityId: Gets or sets the Dolby Vision bl signal compatibility id.
            ///   - Rotation: Gets or sets the Rotation in degrees.
            ///   - Comment: Gets or sets the comment.
            ///   - TimeBase: Gets or sets the time base.
            ///   - CodecTimeBase: Gets or sets the codec time base.
            ///   - Title: Gets or sets the title.
            ///   - VideoRange: An enum representing video ranges.
            ///   - VideoRangeType: An enum representing types of video ranges.
            ///   - VideoDoViTitle: Gets the video dovi title.
            ///   - AudioSpatialFormat: An enum representing formats of spatial audio.
            ///   - LocalizedUndefined:
            ///   - LocalizedDefault:
            ///   - LocalizedForced:
            ///   - LocalizedExternal:
            ///   - LocalizedHearingImpaired:
            ///   - DisplayTitle:
            ///   - NalLengthSize:
            ///   - IsInterlaced: Gets or sets a value indicating whether this instance is interlaced.
            ///   - IsAVC:
            ///   - ChannelLayout: Gets or sets the channel layout.
            ///   - BitRate: Gets or sets the bit rate.
            ///   - BitDepth: Gets or sets the bit depth.
            ///   - RefFrames: Gets or sets the reference frames.
            ///   - PacketLength: Gets or sets the length of the packet.
            ///   - Channels: Gets or sets the channels.
            ///   - SampleRate: Gets or sets the sample rate.
            ///   - IsDefault: Gets or sets a value indicating whether this instance is default.
            ///   - IsForced: Gets or sets a value indicating whether this instance is forced.
            ///   - IsHearingImpaired: Gets or sets a value indicating whether this instance is for the hearing impaired.
            ///   - Height: Gets or sets the height.
            ///   - Width: Gets or sets the width.
            ///   - AverageFrameRate: Gets or sets the average frame rate.
            ///   - RealFrameRate: Gets or sets the real frame rate.
            ///   - ReferenceFrameRate: Gets the framerate used as reference.
            /// Prefer AverageFrameRate, if that is null or an unrealistic value
            /// then fallback to RealFrameRate.
            ///   - Profile: Gets or sets the profile.
            ///   - _Type: Gets or sets the type.
            ///   - AspectRatio: Gets or sets the aspect ratio.
            ///   - Index: Gets or sets the index.
            ///   - Score: Gets or sets the score.
            ///   - IsExternal: Gets or sets a value indicating whether this instance is external.
            ///   - DeliveryMethod: Gets or sets the method.
            ///   - DeliveryUrl: Gets or sets the delivery URL.
            ///   - IsExternalUrl: Gets or sets a value indicating whether this instance is external URL.
            ///   - IsTextSubtitleStream:
            ///   - SupportsExternalStream: Gets or sets a value indicating whether [supports external stream].
            ///   - Path: Gets or sets the filename.
            ///   - PixelFormat: Gets or sets the pixel format.
            ///   - Level: Gets or sets the level.
            ///   - IsAnamorphic: Gets or sets whether this instance is anamorphic.
            public init(
                Codec: Swift.String? = nil,
                CodecTag: Swift.String? = nil,
                Language: Swift.String? = nil,
                ColorRange: Swift.String? = nil,
                ColorSpace: Swift.String? = nil,
                ColorTransfer: Swift.String? = nil,
                ColorPrimaries: Swift.String? = nil,
                DvVersionMajor: Swift.Int32? = nil,
                DvVersionMinor: Swift.Int32? = nil,
                DvProfile: Swift.Int32? = nil,
                DvLevel: Swift.Int32? = nil,
                RpuPresentFlag: Swift.Int32? = nil,
                ElPresentFlag: Swift.Int32? = nil,
                BlPresentFlag: Swift.Int32? = nil,
                DvBlSignalCompatibilityId: Swift.Int32? = nil,
                Rotation: Swift.Int32? = nil,
                Comment: Swift.String? = nil,
                TimeBase: Swift.String? = nil,
                CodecTimeBase: Swift.String? = nil,
                Title: Swift.String? = nil,
                VideoRange: Components.Schemas.MediaStream.VideoRangePayload? = nil,
                VideoRangeType: Components.Schemas.MediaStream.VideoRangeTypePayload? = nil,
                VideoDoViTitle: Swift.String? = nil,
                AudioSpatialFormat: Components.Schemas.MediaStream.AudioSpatialFormatPayload? = nil,
                LocalizedUndefined: Swift.String? = nil,
                LocalizedDefault: Swift.String? = nil,
                LocalizedForced: Swift.String? = nil,
                LocalizedExternal: Swift.String? = nil,
                LocalizedHearingImpaired: Swift.String? = nil,
                DisplayTitle: Swift.String? = nil,
                NalLengthSize: Swift.String? = nil,
                IsInterlaced: Swift.Bool? = nil,
                IsAVC: Swift.Bool? = nil,
                ChannelLayout: Swift.String? = nil,
                BitRate: Swift.Int32? = nil,
                BitDepth: Swift.Int32? = nil,
                RefFrames: Swift.Int32? = nil,
                PacketLength: Swift.Int32? = nil,
                Channels: Swift.Int32? = nil,
                SampleRate: Swift.Int32? = nil,
                IsDefault: Swift.Bool? = nil,
                IsForced: Swift.Bool? = nil,
                IsHearingImpaired: Swift.Bool? = nil,
                Height: Swift.Int32? = nil,
                Width: Swift.Int32? = nil,
                AverageFrameRate: Swift.Float? = nil,
                RealFrameRate: Swift.Float? = nil,
                ReferenceFrameRate: Swift.Float? = nil,
                Profile: Swift.String? = nil,
                _Type: Components.Schemas.MediaStream._TypePayload? = nil,
                AspectRatio: Swift.String? = nil,
                Index: Swift.Int32? = nil,
                Score: Swift.Int32? = nil,
                IsExternal: Swift.Bool? = nil,
                DeliveryMethod: Components.Schemas.MediaStream.DeliveryMethodPayload? = nil,
                DeliveryUrl: Swift.String? = nil,
                IsExternalUrl: Swift.Bool? = nil,
                IsTextSubtitleStream: Swift.Bool? = nil,
                SupportsExternalStream: Swift.Bool? = nil,
                Path: Swift.String? = nil,
                PixelFormat: Swift.String? = nil,
                Level: Swift.Double? = nil,
                IsAnamorphic: Swift.Bool? = nil
            ) {
                self.Codec = Codec
                self.CodecTag = CodecTag
                self.Language = Language
                self.ColorRange = ColorRange
                self.ColorSpace = ColorSpace
                self.ColorTransfer = ColorTransfer
                self.ColorPrimaries = ColorPrimaries
                self.DvVersionMajor = DvVersionMajor
                self.DvVersionMinor = DvVersionMinor
                self.DvProfile = DvProfile
                self.DvLevel = DvLevel
                self.RpuPresentFlag = RpuPresentFlag
                self.ElPresentFlag = ElPresentFlag
                self.BlPresentFlag = BlPresentFlag
                self.DvBlSignalCompatibilityId = DvBlSignalCompatibilityId
                self.Rotation = Rotation
                self.Comment = Comment
                self.TimeBase = TimeBase
                self.CodecTimeBase = CodecTimeBase
                self.Title = Title
                self.VideoRange = VideoRange
                self.VideoRangeType = VideoRangeType
                self.VideoDoViTitle = VideoDoViTitle
                self.AudioSpatialFormat = AudioSpatialFormat
                self.LocalizedUndefined = LocalizedUndefined
                self.LocalizedDefault = LocalizedDefault
                self.LocalizedForced = LocalizedForced
                self.LocalizedExternal = LocalizedExternal
                self.LocalizedHearingImpaired = LocalizedHearingImpaired
                self.DisplayTitle = DisplayTitle
                self.NalLengthSize = NalLengthSize
                self.IsInterlaced = IsInterlaced
                self.IsAVC = IsAVC
                self.ChannelLayout = ChannelLayout
                self.BitRate = BitRate
                self.BitDepth = BitDepth
                self.RefFrames = RefFrames
                self.PacketLength = PacketLength
                self.Channels = Channels
                self.SampleRate = SampleRate
                self.IsDefault = IsDefault
                self.IsForced = IsForced
                self.IsHearingImpaired = IsHearingImpaired
                self.Height = Height
                self.Width = Width
                self.AverageFrameRate = AverageFrameRate
                self.RealFrameRate = RealFrameRate
                self.ReferenceFrameRate = ReferenceFrameRate
                self.Profile = Profile
                self._Type = _Type
                self.AspectRatio = AspectRatio
                self.Index = Index
                self.Score = Score
                self.IsExternal = IsExternal
                self.DeliveryMethod = DeliveryMethod
                self.DeliveryUrl = DeliveryUrl
                self.IsExternalUrl = IsExternalUrl
                self.IsTextSubtitleStream = IsTextSubtitleStream
                self.SupportsExternalStream = SupportsExternalStream
                self.Path = Path
                self.PixelFormat = PixelFormat
                self.Level = Level
                self.IsAnamorphic = IsAnamorphic
            }
            public enum CodingKeys: String, CodingKey {
                case Codec
                case CodecTag
                case Language
                case ColorRange
                case ColorSpace
                case ColorTransfer
                case ColorPrimaries
                case DvVersionMajor
                case DvVersionMinor
                case DvProfile
                case DvLevel
                case RpuPresentFlag
                case ElPresentFlag
                case BlPresentFlag
                case DvBlSignalCompatibilityId
                case Rotation
                case Comment
                case TimeBase
                case CodecTimeBase
                case Title
                case VideoRange
                case VideoRangeType
                case VideoDoViTitle
                case AudioSpatialFormat
                case LocalizedUndefined
                case LocalizedDefault
                case LocalizedForced
                case LocalizedExternal
                case LocalizedHearingImpaired
                case DisplayTitle
                case NalLengthSize
                case IsInterlaced
                case IsAVC
                case ChannelLayout
                case BitRate
                case BitDepth
                case RefFrames
                case PacketLength
                case Channels
                case SampleRate
                case IsDefault
                case IsForced
                case IsHearingImpaired
                case Height
                case Width
                case AverageFrameRate
                case RealFrameRate
                case ReferenceFrameRate
                case Profile
                case _Type = "Type"
                case AspectRatio
                case Index
                case Score
                case IsExternal
                case DeliveryMethod
                case DeliveryUrl
                case IsExternalUrl
                case IsTextSubtitleStream
                case SupportsExternalStream
                case Path
                case PixelFormat
                case Level
                case IsAnamorphic
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Codec = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Codec
                )
                CodecTag = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .CodecTag
                )
                Language = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Language
                )
                ColorRange = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ColorRange
                )
                ColorSpace = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ColorSpace
                )
                ColorTransfer = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ColorTransfer
                )
                ColorPrimaries = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ColorPrimaries
                )
                DvVersionMajor = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .DvVersionMajor
                )
                DvVersionMinor = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .DvVersionMinor
                )
                DvProfile = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .DvProfile
                )
                DvLevel = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .DvLevel
                )
                RpuPresentFlag = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .RpuPresentFlag
                )
                ElPresentFlag = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .ElPresentFlag
                )
                BlPresentFlag = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .BlPresentFlag
                )
                DvBlSignalCompatibilityId = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .DvBlSignalCompatibilityId
                )
                Rotation = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .Rotation
                )
                Comment = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Comment
                )
                TimeBase = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .TimeBase
                )
                CodecTimeBase = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .CodecTimeBase
                )
                Title = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Title
                )
                VideoRange = try container.decodeIfPresent(
                    Components.Schemas.MediaStream.VideoRangePayload.self,
                    forKey: .VideoRange
                )
                VideoRangeType = try container.decodeIfPresent(
                    Components.Schemas.MediaStream.VideoRangeTypePayload.self,
                    forKey: .VideoRangeType
                )
                VideoDoViTitle = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .VideoDoViTitle
                )
                AudioSpatialFormat = try container.decodeIfPresent(
                    Components.Schemas.MediaStream.AudioSpatialFormatPayload.self,
                    forKey: .AudioSpatialFormat
                )
                LocalizedUndefined = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .LocalizedUndefined
                )
                LocalizedDefault = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .LocalizedDefault
                )
                LocalizedForced = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .LocalizedForced
                )
                LocalizedExternal = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .LocalizedExternal
                )
                LocalizedHearingImpaired = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .LocalizedHearingImpaired
                )
                DisplayTitle = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .DisplayTitle
                )
                NalLengthSize = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .NalLengthSize
                )
                IsInterlaced = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsInterlaced
                )
                IsAVC = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsAVC
                )
                ChannelLayout = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ChannelLayout
                )
                BitRate = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .BitRate
                )
                BitDepth = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .BitDepth
                )
                RefFrames = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .RefFrames
                )
                PacketLength = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .PacketLength
                )
                Channels = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .Channels
                )
                SampleRate = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .SampleRate
                )
                IsDefault = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsDefault
                )
                IsForced = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsForced
                )
                IsHearingImpaired = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsHearingImpaired
                )
                Height = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .Height
                )
                Width = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .Width
                )
                AverageFrameRate = try container.decodeIfPresent(
                    Swift.Float.self,
                    forKey: .AverageFrameRate
                )
                RealFrameRate = try container.decodeIfPresent(
                    Swift.Float.self,
                    forKey: .RealFrameRate
                )
                ReferenceFrameRate = try container.decodeIfPresent(
                    Swift.Float.self,
                    forKey: .ReferenceFrameRate
                )
                Profile = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Profile
                )
                _Type = try container.decodeIfPresent(
                    Components.Schemas.MediaStream._TypePayload.self,
                    forKey: ._Type
                )
                AspectRatio = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .AspectRatio
                )
                Index = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .Index
                )
                Score = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .Score
                )
                IsExternal = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsExternal
                )
                DeliveryMethod = try container.decodeIfPresent(
                    Components.Schemas.MediaStream.DeliveryMethodPayload.self,
                    forKey: .DeliveryMethod
                )
                DeliveryUrl = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .DeliveryUrl
                )
                IsExternalUrl = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsExternalUrl
                )
                IsTextSubtitleStream = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsTextSubtitleStream
                )
                SupportsExternalStream = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .SupportsExternalStream
                )
                Path = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Path
                )
                PixelFormat = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .PixelFormat
                )
                Level = try container.decodeIfPresent(
                    Swift.Double.self,
                    forKey: .Level
                )
                IsAnamorphic = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsAnamorphic
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Codec",
                    "CodecTag",
                    "Language",
                    "ColorRange",
                    "ColorSpace",
                    "ColorTransfer",
                    "ColorPrimaries",
                    "DvVersionMajor",
                    "DvVersionMinor",
                    "DvProfile",
                    "DvLevel",
                    "RpuPresentFlag",
                    "ElPresentFlag",
                    "BlPresentFlag",
                    "DvBlSignalCompatibilityId",
                    "Rotation",
                    "Comment",
                    "TimeBase",
                    "CodecTimeBase",
                    "Title",
                    "VideoRange",
                    "VideoRangeType",
                    "VideoDoViTitle",
                    "AudioSpatialFormat",
                    "LocalizedUndefined",
                    "LocalizedDefault",
                    "LocalizedForced",
                    "LocalizedExternal",
                    "LocalizedHearingImpaired",
                    "DisplayTitle",
                    "NalLengthSize",
                    "IsInterlaced",
                    "IsAVC",
                    "ChannelLayout",
                    "BitRate",
                    "BitDepth",
                    "RefFrames",
                    "PacketLength",
                    "Channels",
                    "SampleRate",
                    "IsDefault",
                    "IsForced",
                    "IsHearingImpaired",
                    "Height",
                    "Width",
                    "AverageFrameRate",
                    "RealFrameRate",
                    "ReferenceFrameRate",
                    "Profile",
                    "Type",
                    "AspectRatio",
                    "Index",
                    "Score",
                    "IsExternal",
                    "DeliveryMethod",
                    "DeliveryUrl",
                    "IsExternalUrl",
                    "IsTextSubtitleStream",
                    "SupportsExternalStream",
                    "Path",
                    "PixelFormat",
                    "Level",
                    "IsAnamorphic"
                ])
            }
        }
        /// Media streaming protocol.
        /// Lowercase for backwards compatibility.
        ///
        /// - Remark: Generated from `#/components/schemas/MediaStreamProtocol`.
        @frozen public enum MediaStreamProtocol: String, Codable, Hashable, Sendable, CaseIterable {
            case http = "http"
            case hls = "hls"
        }
        /// Enum MediaStreamType.
        ///
        /// - Remark: Generated from `#/components/schemas/MediaStreamType`.
        @frozen public enum MediaStreamType: String, Codable, Hashable, Sendable, CaseIterable {
            case Audio = "Audio"
            case Video = "Video"
            case Subtitle = "Subtitle"
            case EmbeddedImage = "EmbeddedImage"
            case Data = "Data"
            case Lyric = "Lyric"
        }
        /// Media types.
        ///
        /// - Remark: Generated from `#/components/schemas/MediaType`.
        @frozen public enum MediaType: String, Codable, Hashable, Sendable, CaseIterable {
            case Unknown = "Unknown"
            case Video = "Video"
            case Audio = "Audio"
            case Photo = "Photo"
            case Book = "Book"
        }
        /// - Remark: Generated from `#/components/schemas/MediaUrl`.
        public struct MediaUrl: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/MediaUrl/Url`.
            public var Url: Swift.String?
            /// - Remark: Generated from `#/components/schemas/MediaUrl/Name`.
            public var Name: Swift.String?
            /// Creates a new `MediaUrl`.
            ///
            /// - Parameters:
            ///   - Url:
            ///   - Name:
            public init(
                Url: Swift.String? = nil,
                Name: Swift.String? = nil
            ) {
                self.Url = Url
                self.Name = Name
            }
            public enum CodingKeys: String, CodingKey {
                case Url
                case Name
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Url = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Url
                )
                Name = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Name
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Url",
                    "Name"
                ])
            }
        }
        /// Enum MetadataFields.
        ///
        /// - Remark: Generated from `#/components/schemas/MetadataField`.
        @frozen public enum MetadataField: String, Codable, Hashable, Sendable, CaseIterable {
            case Cast = "Cast"
            case Genres = "Genres"
            case ProductionLocations = "ProductionLocations"
            case Studios = "Studios"
            case Tags = "Tags"
            case Name = "Name"
            case Overview = "Overview"
            case Runtime = "Runtime"
            case OfficialRating = "OfficialRating"
        }
        /// - Remark: Generated from `#/components/schemas/NameGuidPair`.
        public struct NameGuidPair: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/NameGuidPair/Name`.
            public var Name: Swift.String?
            /// - Remark: Generated from `#/components/schemas/NameGuidPair/Id`.
            public var Id: Swift.String?
            /// Creates a new `NameGuidPair`.
            ///
            /// - Parameters:
            ///   - Name:
            ///   - Id:
            public init(
                Name: Swift.String? = nil,
                Id: Swift.String? = nil
            ) {
                self.Name = Name
                self.Id = Id
            }
            public enum CodingKeys: String, CodingKey {
                case Name
                case Id
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Name = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Name
                )
                Id = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Id
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Name",
                    "Id"
                ])
            }
        }
        /// The person kind.
        ///
        /// - Remark: Generated from `#/components/schemas/PersonKind`.
        @frozen public enum PersonKind: String, Codable, Hashable, Sendable, CaseIterable {
            case Unknown = "Unknown"
            case Actor = "Actor"
            case Director = "Director"
            case Composer = "Composer"
            case Writer = "Writer"
            case GuestStar = "GuestStar"
            case Producer = "Producer"
            case Conductor = "Conductor"
            case Lyricist = "Lyricist"
            case Arranger = "Arranger"
            case Engineer = "Engineer"
            case Mixer = "Mixer"
            case Remixer = "Remixer"
            case Creator = "Creator"
            case Artist = "Artist"
            case AlbumArtist = "AlbumArtist"
            case Author = "Author"
            case Illustrator = "Illustrator"
            case Penciller = "Penciller"
            case Inker = "Inker"
            case Colorist = "Colorist"
            case Letterer = "Letterer"
            case CoverArtist = "CoverArtist"
            case Editor = "Editor"
            case Translator = "Translator"
        }
        /// - Remark: Generated from `#/components/schemas/PlayAccess`.
        @frozen public enum PlayAccess: String, Codable, Hashable, Sendable, CaseIterable {
            case Full = "Full"
            case None = "None"
        }
        /// Enum PlaybackOrder.
        ///
        /// - Remark: Generated from `#/components/schemas/PlaybackOrder`.
        @frozen public enum PlaybackOrder: String, Codable, Hashable, Sendable, CaseIterable {
            case Default = "Default"
            case Shuffle = "Shuffle"
        }
        /// - Remark: Generated from `#/components/schemas/PlayerStateInfo`.
        public struct PlayerStateInfo: Codable, Hashable, Sendable {
            /// Gets or sets the now playing position ticks.
            ///
            /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/PositionTicks`.
            public var PositionTicks: Swift.Int64?
            /// Gets or sets a value indicating whether this instance can seek.
            ///
            /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/CanSeek`.
            public var CanSeek: Swift.Bool?
            /// Gets or sets a value indicating whether this instance is paused.
            ///
            /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/IsPaused`.
            public var IsPaused: Swift.Bool?
            /// Gets or sets a value indicating whether this instance is muted.
            ///
            /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/IsMuted`.
            public var IsMuted: Swift.Bool?
            /// Gets or sets the volume level.
            ///
            /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/VolumeLevel`.
            public var VolumeLevel: Swift.Int32?
            /// Gets or sets the index of the now playing audio stream.
            ///
            /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/AudioStreamIndex`.
            public var AudioStreamIndex: Swift.Int32?
            /// Gets or sets the index of the now playing subtitle stream.
            ///
            /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/SubtitleStreamIndex`.
            public var SubtitleStreamIndex: Swift.Int32?
            /// Gets or sets the now playing media version identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/MediaSourceId`.
            public var MediaSourceId: Swift.String?
            /// Gets or sets the play method.
            ///
            /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/PlayMethod`.
            public struct PlayMethodPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/PlayMethod/value1`.
                public var value1: Components.Schemas.PlayMethod
                /// Creates a new `PlayMethodPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.PlayMethod) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the play method.
            ///
            /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/PlayMethod`.
            public var PlayMethod: Components.Schemas.PlayerStateInfo.PlayMethodPayload?
            /// Gets or sets the repeat mode.
            ///
            /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/RepeatMode`.
            public struct RepeatModePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/RepeatMode/value1`.
                public var value1: Components.Schemas.RepeatMode
                /// Creates a new `RepeatModePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.RepeatMode) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the repeat mode.
            ///
            /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/RepeatMode`.
            public var RepeatMode: Components.Schemas.PlayerStateInfo.RepeatModePayload?
            /// Gets or sets the playback order.
            ///
            /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/PlaybackOrder`.
            public struct PlaybackOrderPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/PlaybackOrder/value1`.
                public var value1: Components.Schemas.PlaybackOrder
                /// Creates a new `PlaybackOrderPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.PlaybackOrder) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the playback order.
            ///
            /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/PlaybackOrder`.
            public var PlaybackOrder: Components.Schemas.PlayerStateInfo.PlaybackOrderPayload?
            /// Gets or sets the now playing live stream identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/PlayerStateInfo/LiveStreamId`.
            public var LiveStreamId: Swift.String?
            /// Creates a new `PlayerStateInfo`.
            ///
            /// - Parameters:
            ///   - PositionTicks: Gets or sets the now playing position ticks.
            ///   - CanSeek: Gets or sets a value indicating whether this instance can seek.
            ///   - IsPaused: Gets or sets a value indicating whether this instance is paused.
            ///   - IsMuted: Gets or sets a value indicating whether this instance is muted.
            ///   - VolumeLevel: Gets or sets the volume level.
            ///   - AudioStreamIndex: Gets or sets the index of the now playing audio stream.
            ///   - SubtitleStreamIndex: Gets or sets the index of the now playing subtitle stream.
            ///   - MediaSourceId: Gets or sets the now playing media version identifier.
            ///   - PlayMethod: Gets or sets the play method.
            ///   - RepeatMode: Gets or sets the repeat mode.
            ///   - PlaybackOrder: Gets or sets the playback order.
            ///   - LiveStreamId: Gets or sets the now playing live stream identifier.
            public init(
                PositionTicks: Swift.Int64? = nil,
                CanSeek: Swift.Bool? = nil,
                IsPaused: Swift.Bool? = nil,
                IsMuted: Swift.Bool? = nil,
                VolumeLevel: Swift.Int32? = nil,
                AudioStreamIndex: Swift.Int32? = nil,
                SubtitleStreamIndex: Swift.Int32? = nil,
                MediaSourceId: Swift.String? = nil,
                PlayMethod: Components.Schemas.PlayerStateInfo.PlayMethodPayload? = nil,
                RepeatMode: Components.Schemas.PlayerStateInfo.RepeatModePayload? = nil,
                PlaybackOrder: Components.Schemas.PlayerStateInfo.PlaybackOrderPayload? = nil,
                LiveStreamId: Swift.String? = nil
            ) {
                self.PositionTicks = PositionTicks
                self.CanSeek = CanSeek
                self.IsPaused = IsPaused
                self.IsMuted = IsMuted
                self.VolumeLevel = VolumeLevel
                self.AudioStreamIndex = AudioStreamIndex
                self.SubtitleStreamIndex = SubtitleStreamIndex
                self.MediaSourceId = MediaSourceId
                self.PlayMethod = PlayMethod
                self.RepeatMode = RepeatMode
                self.PlaybackOrder = PlaybackOrder
                self.LiveStreamId = LiveStreamId
            }
            public enum CodingKeys: String, CodingKey {
                case PositionTicks
                case CanSeek
                case IsPaused
                case IsMuted
                case VolumeLevel
                case AudioStreamIndex
                case SubtitleStreamIndex
                case MediaSourceId
                case PlayMethod
                case RepeatMode
                case PlaybackOrder
                case LiveStreamId
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                PositionTicks = try container.decodeIfPresent(
                    Swift.Int64.self,
                    forKey: .PositionTicks
                )
                CanSeek = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .CanSeek
                )
                IsPaused = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsPaused
                )
                IsMuted = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsMuted
                )
                VolumeLevel = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .VolumeLevel
                )
                AudioStreamIndex = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .AudioStreamIndex
                )
                SubtitleStreamIndex = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .SubtitleStreamIndex
                )
                MediaSourceId = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .MediaSourceId
                )
                PlayMethod = try container.decodeIfPresent(
                    Components.Schemas.PlayerStateInfo.PlayMethodPayload.self,
                    forKey: .PlayMethod
                )
                RepeatMode = try container.decodeIfPresent(
                    Components.Schemas.PlayerStateInfo.RepeatModePayload.self,
                    forKey: .RepeatMode
                )
                PlaybackOrder = try container.decodeIfPresent(
                    Components.Schemas.PlayerStateInfo.PlaybackOrderPayload.self,
                    forKey: .PlaybackOrder
                )
                LiveStreamId = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .LiveStreamId
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "PositionTicks",
                    "CanSeek",
                    "IsPaused",
                    "IsMuted",
                    "VolumeLevel",
                    "AudioStreamIndex",
                    "SubtitleStreamIndex",
                    "MediaSourceId",
                    "PlayMethod",
                    "RepeatMode",
                    "PlaybackOrder",
                    "LiveStreamId"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/PlayMethod`.
        @frozen public enum PlayMethod: String, Codable, Hashable, Sendable, CaseIterable {
            case Transcode = "Transcode"
            case DirectStream = "DirectStream"
            case DirectPlay = "DirectPlay"
        }
        /// - Remark: Generated from `#/components/schemas/ProblemDetails`.
        public struct ProblemDetails: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/ProblemDetails/type`.
            public var _type: Swift.String?
            /// - Remark: Generated from `#/components/schemas/ProblemDetails/title`.
            public var title: Swift.String?
            /// - Remark: Generated from `#/components/schemas/ProblemDetails/status`.
            public var status: Swift.Int32?
            /// - Remark: Generated from `#/components/schemas/ProblemDetails/detail`.
            public var detail: Swift.String?
            /// - Remark: Generated from `#/components/schemas/ProblemDetails/instance`.
            public var instance: Swift.String?
            /// A container of undocumented properties.
            public var additionalProperties: [String: OpenAPIRuntime.OpenAPIValueContainer]
            /// Creates a new `ProblemDetails`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - title:
            ///   - status:
            ///   - detail:
            ///   - instance:
            ///   - additionalProperties: A container of undocumented properties.
            public init(
                _type: Swift.String? = nil,
                title: Swift.String? = nil,
                status: Swift.Int32? = nil,
                detail: Swift.String? = nil,
                instance: Swift.String? = nil,
                additionalProperties: [String: OpenAPIRuntime.OpenAPIValueContainer] = .init()
            ) {
                self._type = _type
                self.title = title
                self.status = status
                self.detail = detail
                self.instance = instance
                self.additionalProperties = additionalProperties
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case title
                case status
                case detail
                case instance
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                _type = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: ._type
                )
                title = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .title
                )
                status = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .status
                )
                detail = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .detail
                )
                instance = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .instance
                )
                additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [
                    "type",
                    "title",
                    "status",
                    "detail",
                    "instance"
                ])
            }
            public func encode(to encoder: any Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encodeIfPresent(
                    _type,
                    forKey: ._type
                )
                try container.encodeIfPresent(
                    title,
                    forKey: .title
                )
                try container.encodeIfPresent(
                    status,
                    forKey: .status
                )
                try container.encodeIfPresent(
                    detail,
                    forKey: .detail
                )
                try container.encodeIfPresent(
                    instance,
                    forKey: .instance
                )
                try encoder.encodeAdditionalProperties(additionalProperties)
            }
        }
        /// - Remark: Generated from `#/components/schemas/ProfileCondition`.
        public struct ProfileCondition: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/ProfileCondition/Condition`.
            public struct ConditionPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/ProfileCondition/Condition/value1`.
                public var value1: Components.Schemas.ProfileConditionType
                /// Creates a new `ConditionPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.ProfileConditionType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// - Remark: Generated from `#/components/schemas/ProfileCondition/Condition`.
            public var Condition: Components.Schemas.ProfileCondition.ConditionPayload?
            /// - Remark: Generated from `#/components/schemas/ProfileCondition/Property`.
            public struct PropertyPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/ProfileCondition/Property/value1`.
                public var value1: Components.Schemas.ProfileConditionValue
                /// Creates a new `PropertyPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.ProfileConditionValue) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// - Remark: Generated from `#/components/schemas/ProfileCondition/Property`.
            public var Property: Components.Schemas.ProfileCondition.PropertyPayload?
            /// - Remark: Generated from `#/components/schemas/ProfileCondition/Value`.
            public var Value: Swift.String?
            /// - Remark: Generated from `#/components/schemas/ProfileCondition/IsRequired`.
            public var IsRequired: Swift.Bool?
            /// Creates a new `ProfileCondition`.
            ///
            /// - Parameters:
            ///   - Condition:
            ///   - Property:
            ///   - Value:
            ///   - IsRequired:
            public init(
                Condition: Components.Schemas.ProfileCondition.ConditionPayload? = nil,
                Property: Components.Schemas.ProfileCondition.PropertyPayload? = nil,
                Value: Swift.String? = nil,
                IsRequired: Swift.Bool? = nil
            ) {
                self.Condition = Condition
                self.Property = Property
                self.Value = Value
                self.IsRequired = IsRequired
            }
            public enum CodingKeys: String, CodingKey {
                case Condition
                case Property
                case Value
                case IsRequired
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Condition = try container.decodeIfPresent(
                    Components.Schemas.ProfileCondition.ConditionPayload.self,
                    forKey: .Condition
                )
                Property = try container.decodeIfPresent(
                    Components.Schemas.ProfileCondition.PropertyPayload.self,
                    forKey: .Property
                )
                Value = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Value
                )
                IsRequired = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsRequired
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Condition",
                    "Property",
                    "Value",
                    "IsRequired"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/ProfileConditionType`.
        @frozen public enum ProfileConditionType: String, Codable, Hashable, Sendable, CaseIterable {
            case Equals = "Equals"
            case NotEquals = "NotEquals"
            case LessThanEqual = "LessThanEqual"
            case GreaterThanEqual = "GreaterThanEqual"
            case EqualsAny = "EqualsAny"
        }
        /// - Remark: Generated from `#/components/schemas/ProfileConditionValue`.
        @frozen public enum ProfileConditionValue: String, Codable, Hashable, Sendable, CaseIterable {
            case AudioChannels = "AudioChannels"
            case AudioBitrate = "AudioBitrate"
            case AudioProfile = "AudioProfile"
            case Width = "Width"
            case Height = "Height"
            case Has64BitOffsets = "Has64BitOffsets"
            case PacketLength = "PacketLength"
            case VideoBitDepth = "VideoBitDepth"
            case VideoBitrate = "VideoBitrate"
            case VideoFramerate = "VideoFramerate"
            case VideoLevel = "VideoLevel"
            case VideoProfile = "VideoProfile"
            case VideoTimestamp = "VideoTimestamp"
            case IsAnamorphic = "IsAnamorphic"
            case RefFrames = "RefFrames"
            case NumAudioStreams = "NumAudioStreams"
            case NumVideoStreams = "NumVideoStreams"
            case IsSecondaryAudio = "IsSecondaryAudio"
            case VideoCodecTag = "VideoCodecTag"
            case IsAvc = "IsAvc"
            case IsInterlaced = "IsInterlaced"
            case AudioSampleRate = "AudioSampleRate"
            case AudioBitDepth = "AudioBitDepth"
            case VideoRangeType = "VideoRangeType"
        }
        /// - Remark: Generated from `#/components/schemas/ProgramAudio`.
        @frozen public enum ProgramAudio: String, Codable, Hashable, Sendable, CaseIterable {
            case Mono = "Mono"
            case Stereo = "Stereo"
            case Dolby = "Dolby"
            case DolbyDigital = "DolbyDigital"
            case Thx = "Thx"
            case Atmos = "Atmos"
        }
        /// - Remark: Generated from `#/components/schemas/PublicSystemInfo`.
        public struct PublicSystemInfo: Codable, Hashable, Sendable {
            /// Gets or sets the local address.
            ///
            /// - Remark: Generated from `#/components/schemas/PublicSystemInfo/LocalAddress`.
            public var LocalAddress: Swift.String?
            /// Gets or sets the name of the server.
            ///
            /// - Remark: Generated from `#/components/schemas/PublicSystemInfo/ServerName`.
            public var ServerName: Swift.String?
            /// Gets or sets the server version.
            ///
            /// - Remark: Generated from `#/components/schemas/PublicSystemInfo/Version`.
            public var Version: Swift.String?
            /// Gets or sets the product name. This is the AssemblyProduct name.
            ///
            /// - Remark: Generated from `#/components/schemas/PublicSystemInfo/ProductName`.
            public var ProductName: Swift.String?
            /// Gets or sets the operating system.
            ///
            /// - Remark: Generated from `#/components/schemas/PublicSystemInfo/OperatingSystem`.
            @available(*, deprecated)
            public var OperatingSystem: Swift.String?
            /// Gets or sets the id.
            ///
            /// - Remark: Generated from `#/components/schemas/PublicSystemInfo/Id`.
            public var Id: Swift.String?
            /// Gets or sets a value indicating whether the startup wizard is completed.
            ///
            /// - Remark: Generated from `#/components/schemas/PublicSystemInfo/StartupWizardCompleted`.
            public var StartupWizardCompleted: Swift.Bool?
            /// Creates a new `PublicSystemInfo`.
            ///
            /// - Parameters:
            ///   - LocalAddress: Gets or sets the local address.
            ///   - ServerName: Gets or sets the name of the server.
            ///   - Version: Gets or sets the server version.
            ///   - ProductName: Gets or sets the product name. This is the AssemblyProduct name.
            ///   - OperatingSystem: Gets or sets the operating system.
            ///   - Id: Gets or sets the id.
            ///   - StartupWizardCompleted: Gets or sets a value indicating whether the startup wizard is completed.
            public init(
                LocalAddress: Swift.String? = nil,
                ServerName: Swift.String? = nil,
                Version: Swift.String? = nil,
                ProductName: Swift.String? = nil,
                OperatingSystem: Swift.String? = nil,
                Id: Swift.String? = nil,
                StartupWizardCompleted: Swift.Bool? = nil
            ) {
                self.LocalAddress = LocalAddress
                self.ServerName = ServerName
                self.Version = Version
                self.ProductName = ProductName
                self.OperatingSystem = OperatingSystem
                self.Id = Id
                self.StartupWizardCompleted = StartupWizardCompleted
            }
            public enum CodingKeys: String, CodingKey {
                case LocalAddress
                case ServerName
                case Version
                case ProductName
                case OperatingSystem
                case Id
                case StartupWizardCompleted
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                LocalAddress = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .LocalAddress
                )
                ServerName = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ServerName
                )
                Version = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Version
                )
                ProductName = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ProductName
                )
                OperatingSystem = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .OperatingSystem
                )
                Id = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Id
                )
                StartupWizardCompleted = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .StartupWizardCompleted
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "LocalAddress",
                    "ServerName",
                    "Version",
                    "ProductName",
                    "OperatingSystem",
                    "Id",
                    "StartupWizardCompleted"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/QueueItem`.
        public struct QueueItem: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/QueueItem/Id`.
            public var Id: Swift.String?
            /// - Remark: Generated from `#/components/schemas/QueueItem/PlaylistItemId`.
            public var PlaylistItemId: Swift.String?
            /// Creates a new `QueueItem`.
            ///
            /// - Parameters:
            ///   - Id:
            ///   - PlaylistItemId:
            public init(
                Id: Swift.String? = nil,
                PlaylistItemId: Swift.String? = nil
            ) {
                self.Id = Id
                self.PlaylistItemId = PlaylistItemId
            }
            public enum CodingKeys: String, CodingKey {
                case Id
                case PlaylistItemId
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Id = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Id
                )
                PlaylistItemId = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .PlaylistItemId
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Id",
                    "PlaylistItemId"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/RepeatMode`.
        @frozen public enum RepeatMode: String, Codable, Hashable, Sendable, CaseIterable {
            case RepeatNone = "RepeatNone"
            case RepeatAll = "RepeatAll"
            case RepeatOne = "RepeatOne"
        }
        /// The status of a series.
        ///
        /// - Remark: Generated from `#/components/schemas/SeriesStatus`.
        @frozen public enum SeriesStatus: String, Codable, Hashable, Sendable, CaseIterable {
            case Continuing = "Continuing"
            case Ended = "Ended"
            case Unreleased = "Unreleased"
        }
        /// Session info DTO.
        ///
        /// - Remark: Generated from `#/components/schemas/SessionInfoDto`.
        public struct SessionInfoDto: Codable, Hashable, Sendable {
            /// Gets or sets the play state.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/PlayState`.
            public struct PlayStatePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/SessionInfoDto/PlayState/value1`.
                public var value1: Components.Schemas.PlayerStateInfo
                /// Creates a new `PlayStatePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.PlayerStateInfo) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try value1.encode(to: encoder)
                }
            }
            /// Gets or sets the play state.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/PlayState`.
            public var PlayState: Components.Schemas.SessionInfoDto.PlayStatePayload?
            /// Gets or sets the additional users.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/AdditionalUsers`.
            public var AdditionalUsers: [Components.Schemas.SessionUserInfo]?
            /// Gets or sets the client capabilities.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/Capabilities`.
            public struct CapabilitiesPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/SessionInfoDto/Capabilities/value1`.
                public var value1: Components.Schemas.ClientCapabilitiesDto
                /// Creates a new `CapabilitiesPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.ClientCapabilitiesDto) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try value1.encode(to: encoder)
                }
            }
            /// Gets or sets the client capabilities.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/Capabilities`.
            public var Capabilities: Components.Schemas.SessionInfoDto.CapabilitiesPayload?
            /// Gets or sets the remote end point.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/RemoteEndPoint`.
            public var RemoteEndPoint: Swift.String?
            /// Gets or sets the playable media types.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/PlayableMediaTypes`.
            public var PlayableMediaTypes: [Components.Schemas.MediaType]?
            /// Gets or sets the id.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/Id`.
            public var Id: Swift.String?
            /// Gets or sets the user id.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/UserId`.
            public var UserId: Swift.String?
            /// Gets or sets the username.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/UserName`.
            public var UserName: Swift.String?
            /// Gets or sets the type of the client.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/Client`.
            public var Client: Swift.String?
            /// Gets or sets the last activity date.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/LastActivityDate`.
            public var LastActivityDate: Foundation.Date?
            /// Gets or sets the last playback check in.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/LastPlaybackCheckIn`.
            public var LastPlaybackCheckIn: Foundation.Date?
            /// Gets or sets the last paused date.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/LastPausedDate`.
            public var LastPausedDate: Foundation.Date?
            /// Gets or sets the name of the device.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/DeviceName`.
            public var DeviceName: Swift.String?
            /// Gets or sets the type of the device.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/DeviceType`.
            public var DeviceType: Swift.String?
            /// Gets or sets the now playing item.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/NowPlayingItem`.
            public struct NowPlayingItemPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/SessionInfoDto/NowPlayingItem/value1`.
                public var value1: Components.Schemas.BaseItemDto
                /// Creates a new `NowPlayingItemPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.BaseItemDto) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try value1.encode(to: encoder)
                }
            }
            /// Gets or sets the now playing item.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/NowPlayingItem`.
            public var NowPlayingItem: Components.Schemas.SessionInfoDto.NowPlayingItemPayload?
            /// Gets or sets the now viewing item.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/NowViewingItem`.
            public struct NowViewingItemPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/SessionInfoDto/NowViewingItem/value1`.
                public var value1: Components.Schemas.BaseItemDto
                /// Creates a new `NowViewingItemPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.BaseItemDto) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try value1.encode(to: encoder)
                }
            }
            /// Gets or sets the now viewing item.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/NowViewingItem`.
            public var NowViewingItem: Components.Schemas.SessionInfoDto.NowViewingItemPayload?
            /// Gets or sets the device id.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/DeviceId`.
            public var DeviceId: Swift.String?
            /// Gets or sets the application version.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/ApplicationVersion`.
            public var ApplicationVersion: Swift.String?
            /// Gets or sets the transcoding info.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/TranscodingInfo`.
            public struct TranscodingInfoPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/SessionInfoDto/TranscodingInfo/value1`.
                public var value1: Components.Schemas.TranscodingInfo
                /// Creates a new `TranscodingInfoPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.TranscodingInfo) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try value1.encode(to: encoder)
                }
            }
            /// Gets or sets the transcoding info.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/TranscodingInfo`.
            public var TranscodingInfo: Components.Schemas.SessionInfoDto.TranscodingInfoPayload?
            /// Gets or sets a value indicating whether this session is active.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/IsActive`.
            public var IsActive: Swift.Bool?
            /// Gets or sets a value indicating whether the session supports media control.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/SupportsMediaControl`.
            public var SupportsMediaControl: Swift.Bool?
            /// Gets or sets a value indicating whether the session supports remote control.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/SupportsRemoteControl`.
            public var SupportsRemoteControl: Swift.Bool?
            /// Gets or sets the now playing queue.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/NowPlayingQueue`.
            public var NowPlayingQueue: [Components.Schemas.QueueItem]?
            /// Gets or sets the now playing queue full items.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/NowPlayingQueueFullItems`.
            public var NowPlayingQueueFullItems: [Components.Schemas.BaseItemDto]?
            /// Gets or sets a value indicating whether the session has a custom device name.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/HasCustomDeviceName`.
            public var HasCustomDeviceName: Swift.Bool?
            /// Gets or sets the playlist item id.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/PlaylistItemId`.
            public var PlaylistItemId: Swift.String?
            /// Gets or sets the server id.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/ServerId`.
            public var ServerId: Swift.String?
            /// Gets or sets the user primary image tag.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/UserPrimaryImageTag`.
            public var UserPrimaryImageTag: Swift.String?
            /// Gets or sets the supported commands.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionInfoDto/SupportedCommands`.
            public var SupportedCommands: [Components.Schemas.GeneralCommandType]?
            /// Creates a new `SessionInfoDto`.
            ///
            /// - Parameters:
            ///   - PlayState: Gets or sets the play state.
            ///   - AdditionalUsers: Gets or sets the additional users.
            ///   - Capabilities: Gets or sets the client capabilities.
            ///   - RemoteEndPoint: Gets or sets the remote end point.
            ///   - PlayableMediaTypes: Gets or sets the playable media types.
            ///   - Id: Gets or sets the id.
            ///   - UserId: Gets or sets the user id.
            ///   - UserName: Gets or sets the username.
            ///   - Client: Gets or sets the type of the client.
            ///   - LastActivityDate: Gets or sets the last activity date.
            ///   - LastPlaybackCheckIn: Gets or sets the last playback check in.
            ///   - LastPausedDate: Gets or sets the last paused date.
            ///   - DeviceName: Gets or sets the name of the device.
            ///   - DeviceType: Gets or sets the type of the device.
            ///   - NowPlayingItem: Gets or sets the now playing item.
            ///   - NowViewingItem: Gets or sets the now viewing item.
            ///   - DeviceId: Gets or sets the device id.
            ///   - ApplicationVersion: Gets or sets the application version.
            ///   - TranscodingInfo: Gets or sets the transcoding info.
            ///   - IsActive: Gets or sets a value indicating whether this session is active.
            ///   - SupportsMediaControl: Gets or sets a value indicating whether the session supports media control.
            ///   - SupportsRemoteControl: Gets or sets a value indicating whether the session supports remote control.
            ///   - NowPlayingQueue: Gets or sets the now playing queue.
            ///   - NowPlayingQueueFullItems: Gets or sets the now playing queue full items.
            ///   - HasCustomDeviceName: Gets or sets a value indicating whether the session has a custom device name.
            ///   - PlaylistItemId: Gets or sets the playlist item id.
            ///   - ServerId: Gets or sets the server id.
            ///   - UserPrimaryImageTag: Gets or sets the user primary image tag.
            ///   - SupportedCommands: Gets or sets the supported commands.
            public init(
                PlayState: Components.Schemas.SessionInfoDto.PlayStatePayload? = nil,
                AdditionalUsers: [Components.Schemas.SessionUserInfo]? = nil,
                Capabilities: Components.Schemas.SessionInfoDto.CapabilitiesPayload? = nil,
                RemoteEndPoint: Swift.String? = nil,
                PlayableMediaTypes: [Components.Schemas.MediaType]? = nil,
                Id: Swift.String? = nil,
                UserId: Swift.String? = nil,
                UserName: Swift.String? = nil,
                Client: Swift.String? = nil,
                LastActivityDate: Foundation.Date? = nil,
                LastPlaybackCheckIn: Foundation.Date? = nil,
                LastPausedDate: Foundation.Date? = nil,
                DeviceName: Swift.String? = nil,
                DeviceType: Swift.String? = nil,
                NowPlayingItem: Components.Schemas.SessionInfoDto.NowPlayingItemPayload? = nil,
                NowViewingItem: Components.Schemas.SessionInfoDto.NowViewingItemPayload? = nil,
                DeviceId: Swift.String? = nil,
                ApplicationVersion: Swift.String? = nil,
                TranscodingInfo: Components.Schemas.SessionInfoDto.TranscodingInfoPayload? = nil,
                IsActive: Swift.Bool? = nil,
                SupportsMediaControl: Swift.Bool? = nil,
                SupportsRemoteControl: Swift.Bool? = nil,
                NowPlayingQueue: [Components.Schemas.QueueItem]? = nil,
                NowPlayingQueueFullItems: [Components.Schemas.BaseItemDto]? = nil,
                HasCustomDeviceName: Swift.Bool? = nil,
                PlaylistItemId: Swift.String? = nil,
                ServerId: Swift.String? = nil,
                UserPrimaryImageTag: Swift.String? = nil,
                SupportedCommands: [Components.Schemas.GeneralCommandType]? = nil
            ) {
                self.PlayState = PlayState
                self.AdditionalUsers = AdditionalUsers
                self.Capabilities = Capabilities
                self.RemoteEndPoint = RemoteEndPoint
                self.PlayableMediaTypes = PlayableMediaTypes
                self.Id = Id
                self.UserId = UserId
                self.UserName = UserName
                self.Client = Client
                self.LastActivityDate = LastActivityDate
                self.LastPlaybackCheckIn = LastPlaybackCheckIn
                self.LastPausedDate = LastPausedDate
                self.DeviceName = DeviceName
                self.DeviceType = DeviceType
                self.NowPlayingItem = NowPlayingItem
                self.NowViewingItem = NowViewingItem
                self.DeviceId = DeviceId
                self.ApplicationVersion = ApplicationVersion
                self.TranscodingInfo = TranscodingInfo
                self.IsActive = IsActive
                self.SupportsMediaControl = SupportsMediaControl
                self.SupportsRemoteControl = SupportsRemoteControl
                self.NowPlayingQueue = NowPlayingQueue
                self.NowPlayingQueueFullItems = NowPlayingQueueFullItems
                self.HasCustomDeviceName = HasCustomDeviceName
                self.PlaylistItemId = PlaylistItemId
                self.ServerId = ServerId
                self.UserPrimaryImageTag = UserPrimaryImageTag
                self.SupportedCommands = SupportedCommands
            }
            public enum CodingKeys: String, CodingKey {
                case PlayState
                case AdditionalUsers
                case Capabilities
                case RemoteEndPoint
                case PlayableMediaTypes
                case Id
                case UserId
                case UserName
                case Client
                case LastActivityDate
                case LastPlaybackCheckIn
                case LastPausedDate
                case DeviceName
                case DeviceType
                case NowPlayingItem
                case NowViewingItem
                case DeviceId
                case ApplicationVersion
                case TranscodingInfo
                case IsActive
                case SupportsMediaControl
                case SupportsRemoteControl
                case NowPlayingQueue
                case NowPlayingQueueFullItems
                case HasCustomDeviceName
                case PlaylistItemId
                case ServerId
                case UserPrimaryImageTag
                case SupportedCommands
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                PlayState = try container.decodeIfPresent(
                    Components.Schemas.SessionInfoDto.PlayStatePayload.self,
                    forKey: .PlayState
                )
                AdditionalUsers = try container.decodeIfPresent(
                    [Components.Schemas.SessionUserInfo].self,
                    forKey: .AdditionalUsers
                )
                Capabilities = try container.decodeIfPresent(
                    Components.Schemas.SessionInfoDto.CapabilitiesPayload.self,
                    forKey: .Capabilities
                )
                RemoteEndPoint = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .RemoteEndPoint
                )
                PlayableMediaTypes = try container.decodeIfPresent(
                    [Components.Schemas.MediaType].self,
                    forKey: .PlayableMediaTypes
                )
                Id = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Id
                )
                UserId = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .UserId
                )
                UserName = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .UserName
                )
                Client = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Client
                )
                LastActivityDate = try container.decodeIfPresent(
                    Foundation.Date.self,
                    forKey: .LastActivityDate
                )
                LastPlaybackCheckIn = try container.decodeIfPresent(
                    Foundation.Date.self,
                    forKey: .LastPlaybackCheckIn
                )
                LastPausedDate = try container.decodeIfPresent(
                    Foundation.Date.self,
                    forKey: .LastPausedDate
                )
                DeviceName = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .DeviceName
                )
                DeviceType = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .DeviceType
                )
                NowPlayingItem = try container.decodeIfPresent(
                    Components.Schemas.SessionInfoDto.NowPlayingItemPayload.self,
                    forKey: .NowPlayingItem
                )
                NowViewingItem = try container.decodeIfPresent(
                    Components.Schemas.SessionInfoDto.NowViewingItemPayload.self,
                    forKey: .NowViewingItem
                )
                DeviceId = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .DeviceId
                )
                ApplicationVersion = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ApplicationVersion
                )
                TranscodingInfo = try container.decodeIfPresent(
                    Components.Schemas.SessionInfoDto.TranscodingInfoPayload.self,
                    forKey: .TranscodingInfo
                )
                IsActive = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsActive
                )
                SupportsMediaControl = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .SupportsMediaControl
                )
                SupportsRemoteControl = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .SupportsRemoteControl
                )
                NowPlayingQueue = try container.decodeIfPresent(
                    [Components.Schemas.QueueItem].self,
                    forKey: .NowPlayingQueue
                )
                NowPlayingQueueFullItems = try container.decodeIfPresent(
                    [Components.Schemas.BaseItemDto].self,
                    forKey: .NowPlayingQueueFullItems
                )
                HasCustomDeviceName = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .HasCustomDeviceName
                )
                PlaylistItemId = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .PlaylistItemId
                )
                ServerId = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ServerId
                )
                UserPrimaryImageTag = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .UserPrimaryImageTag
                )
                SupportedCommands = try container.decodeIfPresent(
                    [Components.Schemas.GeneralCommandType].self,
                    forKey: .SupportedCommands
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "PlayState",
                    "AdditionalUsers",
                    "Capabilities",
                    "RemoteEndPoint",
                    "PlayableMediaTypes",
                    "Id",
                    "UserId",
                    "UserName",
                    "Client",
                    "LastActivityDate",
                    "LastPlaybackCheckIn",
                    "LastPausedDate",
                    "DeviceName",
                    "DeviceType",
                    "NowPlayingItem",
                    "NowViewingItem",
                    "DeviceId",
                    "ApplicationVersion",
                    "TranscodingInfo",
                    "IsActive",
                    "SupportsMediaControl",
                    "SupportsRemoteControl",
                    "NowPlayingQueue",
                    "NowPlayingQueueFullItems",
                    "HasCustomDeviceName",
                    "PlaylistItemId",
                    "ServerId",
                    "UserPrimaryImageTag",
                    "SupportedCommands"
                ])
            }
        }
        /// Class SessionUserInfo.
        ///
        /// - Remark: Generated from `#/components/schemas/SessionUserInfo`.
        public struct SessionUserInfo: Codable, Hashable, Sendable {
            /// Gets or sets the user identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionUserInfo/UserId`.
            public var UserId: Swift.String?
            /// Gets or sets the name of the user.
            ///
            /// - Remark: Generated from `#/components/schemas/SessionUserInfo/UserName`.
            public var UserName: Swift.String?
            /// Creates a new `SessionUserInfo`.
            ///
            /// - Parameters:
            ///   - UserId: Gets or sets the user identifier.
            ///   - UserName: Gets or sets the name of the user.
            public init(
                UserId: Swift.String? = nil,
                UserName: Swift.String? = nil
            ) {
                self.UserId = UserId
                self.UserName = UserName
            }
            public enum CodingKeys: String, CodingKey {
                case UserId
                case UserName
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                UserId = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .UserId
                )
                UserName = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .UserName
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "UserId",
                    "UserName"
                ])
            }
        }
        /// An enum representing the sorting order.
        ///
        /// - Remark: Generated from `#/components/schemas/SortOrder`.
        @frozen public enum SortOrder: String, Codable, Hashable, Sendable, CaseIterable {
            case Ascending = "Ascending"
            case Descending = "Descending"
        }
        /// Delivery method to use during playback of a specific subtitle format.
        ///
        /// - Remark: Generated from `#/components/schemas/SubtitleDeliveryMethod`.
        @frozen public enum SubtitleDeliveryMethod: String, Codable, Hashable, Sendable, CaseIterable {
            case Encode = "Encode"
            case Embed = "Embed"
            case External = "External"
            case Hls = "Hls"
            case Drop = "Drop"
        }
        /// An enum representing a subtitle playback mode.
        ///
        /// - Remark: Generated from `#/components/schemas/SubtitlePlaybackMode`.
        @frozen public enum SubtitlePlaybackMode: String, Codable, Hashable, Sendable, CaseIterable {
            case Default = "Default"
            case Always = "Always"
            case OnlyForced = "OnlyForced"
            case None = "None"
            case Smart = "Smart"
        }
        /// A class for subtitle profile information.
        ///
        /// - Remark: Generated from `#/components/schemas/SubtitleProfile`.
        public struct SubtitleProfile: Codable, Hashable, Sendable {
            /// Gets or sets the format.
            ///
            /// - Remark: Generated from `#/components/schemas/SubtitleProfile/Format`.
            public var Format: Swift.String?
            /// Gets or sets the delivery method.
            ///
            /// - Remark: Generated from `#/components/schemas/SubtitleProfile/Method`.
            public struct MethodPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/SubtitleProfile/Method/value1`.
                public var value1: Components.Schemas.SubtitleDeliveryMethod
                /// Creates a new `MethodPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.SubtitleDeliveryMethod) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the delivery method.
            ///
            /// - Remark: Generated from `#/components/schemas/SubtitleProfile/Method`.
            public var Method: Components.Schemas.SubtitleProfile.MethodPayload?
            /// Gets or sets the DIDL mode.
            ///
            /// - Remark: Generated from `#/components/schemas/SubtitleProfile/DidlMode`.
            public var DidlMode: Swift.String?
            /// Gets or sets the language.
            ///
            /// - Remark: Generated from `#/components/schemas/SubtitleProfile/Language`.
            public var Language: Swift.String?
            /// Gets or sets the container.
            ///
            /// - Remark: Generated from `#/components/schemas/SubtitleProfile/Container`.
            public var Container: Swift.String?
            /// Creates a new `SubtitleProfile`.
            ///
            /// - Parameters:
            ///   - Format: Gets or sets the format.
            ///   - Method: Gets or sets the delivery method.
            ///   - DidlMode: Gets or sets the DIDL mode.
            ///   - Language: Gets or sets the language.
            ///   - Container: Gets or sets the container.
            public init(
                Format: Swift.String? = nil,
                Method: Components.Schemas.SubtitleProfile.MethodPayload? = nil,
                DidlMode: Swift.String? = nil,
                Language: Swift.String? = nil,
                Container: Swift.String? = nil
            ) {
                self.Format = Format
                self.Method = Method
                self.DidlMode = DidlMode
                self.Language = Language
                self.Container = Container
            }
            public enum CodingKeys: String, CodingKey {
                case Format
                case Method
                case DidlMode
                case Language
                case Container
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Format = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Format
                )
                Method = try container.decodeIfPresent(
                    Components.Schemas.SubtitleProfile.MethodPayload.self,
                    forKey: .Method
                )
                DidlMode = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .DidlMode
                )
                Language = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Language
                )
                Container = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Container
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Format",
                    "Method",
                    "DidlMode",
                    "Language",
                    "Container"
                ])
            }
        }
        /// Enum SyncPlayUserAccessType.
        ///
        /// - Remark: Generated from `#/components/schemas/SyncPlayUserAccessType`.
        @frozen public enum SyncPlayUserAccessType: String, Codable, Hashable, Sendable, CaseIterable {
            case CreateAndJoinGroups = "CreateAndJoinGroups"
            case JoinGroups = "JoinGroups"
            case None = "None"
        }
        /// - Remark: Generated from `#/components/schemas/TranscodeReason`.
        @frozen public enum TranscodeReason: String, Codable, Hashable, Sendable, CaseIterable {
            case ContainerNotSupported = "ContainerNotSupported"
            case VideoCodecNotSupported = "VideoCodecNotSupported"
            case AudioCodecNotSupported = "AudioCodecNotSupported"
            case SubtitleCodecNotSupported = "SubtitleCodecNotSupported"
            case AudioIsExternal = "AudioIsExternal"
            case SecondaryAudioNotSupported = "SecondaryAudioNotSupported"
            case VideoProfileNotSupported = "VideoProfileNotSupported"
            case VideoLevelNotSupported = "VideoLevelNotSupported"
            case VideoResolutionNotSupported = "VideoResolutionNotSupported"
            case VideoBitDepthNotSupported = "VideoBitDepthNotSupported"
            case VideoFramerateNotSupported = "VideoFramerateNotSupported"
            case RefFramesNotSupported = "RefFramesNotSupported"
            case AnamorphicVideoNotSupported = "AnamorphicVideoNotSupported"
            case InterlacedVideoNotSupported = "InterlacedVideoNotSupported"
            case AudioChannelsNotSupported = "AudioChannelsNotSupported"
            case AudioProfileNotSupported = "AudioProfileNotSupported"
            case AudioSampleRateNotSupported = "AudioSampleRateNotSupported"
            case AudioBitDepthNotSupported = "AudioBitDepthNotSupported"
            case ContainerBitrateExceedsLimit = "ContainerBitrateExceedsLimit"
            case VideoBitrateNotSupported = "VideoBitrateNotSupported"
            case AudioBitrateNotSupported = "AudioBitrateNotSupported"
            case UnknownVideoStreamInfo = "UnknownVideoStreamInfo"
            case UnknownAudioStreamInfo = "UnknownAudioStreamInfo"
            case DirectPlayError = "DirectPlayError"
            case VideoRangeTypeNotSupported = "VideoRangeTypeNotSupported"
            case VideoCodecTagNotSupported = "VideoCodecTagNotSupported"
        }
        /// - Remark: Generated from `#/components/schemas/TranscodeSeekInfo`.
        @frozen public enum TranscodeSeekInfo: String, Codable, Hashable, Sendable, CaseIterable {
            case Auto = "Auto"
            case Bytes = "Bytes"
        }
        /// Class holding information on a runnning transcode.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscodingInfo`.
        public struct TranscodingInfo: Codable, Hashable, Sendable {
            /// Gets or sets the thread count used for encoding.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingInfo/AudioCodec`.
            public var AudioCodec: Swift.String?
            /// Gets or sets the thread count used for encoding.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingInfo/VideoCodec`.
            public var VideoCodec: Swift.String?
            /// Gets or sets the thread count used for encoding.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingInfo/Container`.
            public var Container: Swift.String?
            /// Gets or sets a value indicating whether the video is passed through.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingInfo/IsVideoDirect`.
            public var IsVideoDirect: Swift.Bool?
            /// Gets or sets a value indicating whether the audio is passed through.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingInfo/IsAudioDirect`.
            public var IsAudioDirect: Swift.Bool?
            /// Gets or sets the bitrate.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingInfo/Bitrate`.
            public var Bitrate: Swift.Int32?
            /// Gets or sets the framerate.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingInfo/Framerate`.
            public var Framerate: Swift.Float?
            /// Gets or sets the completion percentage.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingInfo/CompletionPercentage`.
            public var CompletionPercentage: Swift.Double?
            /// Gets or sets the video width.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingInfo/Width`.
            public var Width: Swift.Int32?
            /// Gets or sets the video height.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingInfo/Height`.
            public var Height: Swift.Int32?
            /// Gets or sets the audio channels.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingInfo/AudioChannels`.
            public var AudioChannels: Swift.Int32?
            /// Gets or sets the hardware acceleration type.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingInfo/HardwareAccelerationType`.
            public struct HardwareAccelerationTypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/TranscodingInfo/HardwareAccelerationType/value1`.
                public var value1: Components.Schemas.HardwareAccelerationType
                /// Creates a new `HardwareAccelerationTypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.HardwareAccelerationType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the hardware acceleration type.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingInfo/HardwareAccelerationType`.
            public var HardwareAccelerationType: Components.Schemas.TranscodingInfo.HardwareAccelerationTypePayload?
            /// Gets or sets the transcode reasons.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingInfo/TranscodeReasons`.
            public var TranscodeReasons: [Components.Schemas.TranscodeReason]?
            /// Creates a new `TranscodingInfo`.
            ///
            /// - Parameters:
            ///   - AudioCodec: Gets or sets the thread count used for encoding.
            ///   - VideoCodec: Gets or sets the thread count used for encoding.
            ///   - Container: Gets or sets the thread count used for encoding.
            ///   - IsVideoDirect: Gets or sets a value indicating whether the video is passed through.
            ///   - IsAudioDirect: Gets or sets a value indicating whether the audio is passed through.
            ///   - Bitrate: Gets or sets the bitrate.
            ///   - Framerate: Gets or sets the framerate.
            ///   - CompletionPercentage: Gets or sets the completion percentage.
            ///   - Width: Gets or sets the video width.
            ///   - Height: Gets or sets the video height.
            ///   - AudioChannels: Gets or sets the audio channels.
            ///   - HardwareAccelerationType: Gets or sets the hardware acceleration type.
            ///   - TranscodeReasons: Gets or sets the transcode reasons.
            public init(
                AudioCodec: Swift.String? = nil,
                VideoCodec: Swift.String? = nil,
                Container: Swift.String? = nil,
                IsVideoDirect: Swift.Bool? = nil,
                IsAudioDirect: Swift.Bool? = nil,
                Bitrate: Swift.Int32? = nil,
                Framerate: Swift.Float? = nil,
                CompletionPercentage: Swift.Double? = nil,
                Width: Swift.Int32? = nil,
                Height: Swift.Int32? = nil,
                AudioChannels: Swift.Int32? = nil,
                HardwareAccelerationType: Components.Schemas.TranscodingInfo.HardwareAccelerationTypePayload? = nil,
                TranscodeReasons: [Components.Schemas.TranscodeReason]? = nil
            ) {
                self.AudioCodec = AudioCodec
                self.VideoCodec = VideoCodec
                self.Container = Container
                self.IsVideoDirect = IsVideoDirect
                self.IsAudioDirect = IsAudioDirect
                self.Bitrate = Bitrate
                self.Framerate = Framerate
                self.CompletionPercentage = CompletionPercentage
                self.Width = Width
                self.Height = Height
                self.AudioChannels = AudioChannels
                self.HardwareAccelerationType = HardwareAccelerationType
                self.TranscodeReasons = TranscodeReasons
            }
            public enum CodingKeys: String, CodingKey {
                case AudioCodec
                case VideoCodec
                case Container
                case IsVideoDirect
                case IsAudioDirect
                case Bitrate
                case Framerate
                case CompletionPercentage
                case Width
                case Height
                case AudioChannels
                case HardwareAccelerationType
                case TranscodeReasons
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                AudioCodec = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .AudioCodec
                )
                VideoCodec = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .VideoCodec
                )
                Container = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Container
                )
                IsVideoDirect = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsVideoDirect
                )
                IsAudioDirect = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsAudioDirect
                )
                Bitrate = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .Bitrate
                )
                Framerate = try container.decodeIfPresent(
                    Swift.Float.self,
                    forKey: .Framerate
                )
                CompletionPercentage = try container.decodeIfPresent(
                    Swift.Double.self,
                    forKey: .CompletionPercentage
                )
                Width = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .Width
                )
                Height = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .Height
                )
                AudioChannels = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .AudioChannels
                )
                HardwareAccelerationType = try container.decodeIfPresent(
                    Components.Schemas.TranscodingInfo.HardwareAccelerationTypePayload.self,
                    forKey: .HardwareAccelerationType
                )
                TranscodeReasons = try container.decodeIfPresent(
                    [Components.Schemas.TranscodeReason].self,
                    forKey: .TranscodeReasons
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "AudioCodec",
                    "VideoCodec",
                    "Container",
                    "IsVideoDirect",
                    "IsAudioDirect",
                    "Bitrate",
                    "Framerate",
                    "CompletionPercentage",
                    "Width",
                    "Height",
                    "AudioChannels",
                    "HardwareAccelerationType",
                    "TranscodeReasons"
                ])
            }
        }
        /// A class for transcoding profile information.
        ///
        /// - Remark: Generated from `#/components/schemas/TranscodingProfile`.
        public struct TranscodingProfile: Codable, Hashable, Sendable {
            /// Gets or sets the container.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/Container`.
            public var Container: Swift.String?
            /// Gets or sets the DLNA profile type.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/Type`.
            public struct _TypePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/TranscodingProfile/Type/value1`.
                public var value1: Components.Schemas.DlnaProfileType
                /// Creates a new `_TypePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.DlnaProfileType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the DLNA profile type.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/Type`.
            public var _Type: Components.Schemas.TranscodingProfile._TypePayload?
            /// Gets or sets the video codec.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/VideoCodec`.
            public var VideoCodec: Swift.String?
            /// Gets or sets the audio codec.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/AudioCodec`.
            public var AudioCodec: Swift.String?
            /// Media streaming protocol.
            /// Lowercase for backwards compatibility.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/Protocol`.
            public struct _ProtocolPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/TranscodingProfile/Protocol/value1`.
                public var value1: Components.Schemas.MediaStreamProtocol
                /// Creates a new `_ProtocolPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.MediaStreamProtocol) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Media streaming protocol.
            /// Lowercase for backwards compatibility.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/Protocol`.
            public var _Protocol: Components.Schemas.TranscodingProfile._ProtocolPayload?
            /// Gets or sets a value indicating whether the content length should be estimated.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/EstimateContentLength`.
            public var EstimateContentLength: Swift.Bool?
            /// Gets or sets a value indicating whether M2TS mode is enabled.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/EnableMpegtsM2TsMode`.
            public var EnableMpegtsM2TsMode: Swift.Bool?
            /// Gets or sets the transcoding seek info mode.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/TranscodeSeekInfo`.
            public struct TranscodeSeekInfoPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/TranscodingProfile/TranscodeSeekInfo/value1`.
                public var value1: Components.Schemas.TranscodeSeekInfo
                /// Creates a new `TranscodeSeekInfoPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.TranscodeSeekInfo) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the transcoding seek info mode.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/TranscodeSeekInfo`.
            public var TranscodeSeekInfo: Components.Schemas.TranscodingProfile.TranscodeSeekInfoPayload?
            /// Gets or sets a value indicating whether timestamps should be copied.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/CopyTimestamps`.
            public var CopyTimestamps: Swift.Bool?
            /// Gets or sets the encoding context.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/Context`.
            public struct ContextPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/TranscodingProfile/Context/value1`.
                public var value1: Components.Schemas.EncodingContext
                /// Creates a new `ContextPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.EncodingContext) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Gets or sets the encoding context.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/Context`.
            public var Context: Components.Schemas.TranscodingProfile.ContextPayload?
            /// Gets or sets a value indicating whether subtitles are allowed in the manifest.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/EnableSubtitlesInManifest`.
            public var EnableSubtitlesInManifest: Swift.Bool?
            /// Gets or sets the maximum audio channels.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/MaxAudioChannels`.
            public var MaxAudioChannels: Swift.String?
            /// Gets or sets the minimum amount of segments.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/MinSegments`.
            public var MinSegments: Swift.Int32?
            /// Gets or sets the segment length.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/SegmentLength`.
            public var SegmentLength: Swift.Int32?
            /// Gets or sets a value indicating whether breaking the video stream on non-keyframes is supported.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/BreakOnNonKeyFrames`.
            public var BreakOnNonKeyFrames: Swift.Bool?
            /// Gets or sets the profile conditions.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/Conditions`.
            public var Conditions: [Components.Schemas.ProfileCondition]?
            /// Gets or sets a value indicating whether variable bitrate encoding is supported.
            ///
            /// - Remark: Generated from `#/components/schemas/TranscodingProfile/EnableAudioVbrEncoding`.
            public var EnableAudioVbrEncoding: Swift.Bool?
            /// Creates a new `TranscodingProfile`.
            ///
            /// - Parameters:
            ///   - Container: Gets or sets the container.
            ///   - _Type: Gets or sets the DLNA profile type.
            ///   - VideoCodec: Gets or sets the video codec.
            ///   - AudioCodec: Gets or sets the audio codec.
            ///   - _Protocol: Media streaming protocol.
            /// Lowercase for backwards compatibility.
            ///   - EstimateContentLength: Gets or sets a value indicating whether the content length should be estimated.
            ///   - EnableMpegtsM2TsMode: Gets or sets a value indicating whether M2TS mode is enabled.
            ///   - TranscodeSeekInfo: Gets or sets the transcoding seek info mode.
            ///   - CopyTimestamps: Gets or sets a value indicating whether timestamps should be copied.
            ///   - Context: Gets or sets the encoding context.
            ///   - EnableSubtitlesInManifest: Gets or sets a value indicating whether subtitles are allowed in the manifest.
            ///   - MaxAudioChannels: Gets or sets the maximum audio channels.
            ///   - MinSegments: Gets or sets the minimum amount of segments.
            ///   - SegmentLength: Gets or sets the segment length.
            ///   - BreakOnNonKeyFrames: Gets or sets a value indicating whether breaking the video stream on non-keyframes is supported.
            ///   - Conditions: Gets or sets the profile conditions.
            ///   - EnableAudioVbrEncoding: Gets or sets a value indicating whether variable bitrate encoding is supported.
            public init(
                Container: Swift.String? = nil,
                _Type: Components.Schemas.TranscodingProfile._TypePayload? = nil,
                VideoCodec: Swift.String? = nil,
                AudioCodec: Swift.String? = nil,
                _Protocol: Components.Schemas.TranscodingProfile._ProtocolPayload? = nil,
                EstimateContentLength: Swift.Bool? = nil,
                EnableMpegtsM2TsMode: Swift.Bool? = nil,
                TranscodeSeekInfo: Components.Schemas.TranscodingProfile.TranscodeSeekInfoPayload? = nil,
                CopyTimestamps: Swift.Bool? = nil,
                Context: Components.Schemas.TranscodingProfile.ContextPayload? = nil,
                EnableSubtitlesInManifest: Swift.Bool? = nil,
                MaxAudioChannels: Swift.String? = nil,
                MinSegments: Swift.Int32? = nil,
                SegmentLength: Swift.Int32? = nil,
                BreakOnNonKeyFrames: Swift.Bool? = nil,
                Conditions: [Components.Schemas.ProfileCondition]? = nil,
                EnableAudioVbrEncoding: Swift.Bool? = nil
            ) {
                self.Container = Container
                self._Type = _Type
                self.VideoCodec = VideoCodec
                self.AudioCodec = AudioCodec
                self._Protocol = _Protocol
                self.EstimateContentLength = EstimateContentLength
                self.EnableMpegtsM2TsMode = EnableMpegtsM2TsMode
                self.TranscodeSeekInfo = TranscodeSeekInfo
                self.CopyTimestamps = CopyTimestamps
                self.Context = Context
                self.EnableSubtitlesInManifest = EnableSubtitlesInManifest
                self.MaxAudioChannels = MaxAudioChannels
                self.MinSegments = MinSegments
                self.SegmentLength = SegmentLength
                self.BreakOnNonKeyFrames = BreakOnNonKeyFrames
                self.Conditions = Conditions
                self.EnableAudioVbrEncoding = EnableAudioVbrEncoding
            }
            public enum CodingKeys: String, CodingKey {
                case Container
                case _Type = "Type"
                case VideoCodec
                case AudioCodec
                case _Protocol = "Protocol"
                case EstimateContentLength
                case EnableMpegtsM2TsMode
                case TranscodeSeekInfo
                case CopyTimestamps
                case Context
                case EnableSubtitlesInManifest
                case MaxAudioChannels
                case MinSegments
                case SegmentLength
                case BreakOnNonKeyFrames
                case Conditions
                case EnableAudioVbrEncoding
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Container = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Container
                )
                _Type = try container.decodeIfPresent(
                    Components.Schemas.TranscodingProfile._TypePayload.self,
                    forKey: ._Type
                )
                VideoCodec = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .VideoCodec
                )
                AudioCodec = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .AudioCodec
                )
                _Protocol = try container.decodeIfPresent(
                    Components.Schemas.TranscodingProfile._ProtocolPayload.self,
                    forKey: ._Protocol
                )
                EstimateContentLength = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EstimateContentLength
                )
                EnableMpegtsM2TsMode = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableMpegtsM2TsMode
                )
                TranscodeSeekInfo = try container.decodeIfPresent(
                    Components.Schemas.TranscodingProfile.TranscodeSeekInfoPayload.self,
                    forKey: .TranscodeSeekInfo
                )
                CopyTimestamps = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .CopyTimestamps
                )
                Context = try container.decodeIfPresent(
                    Components.Schemas.TranscodingProfile.ContextPayload.self,
                    forKey: .Context
                )
                EnableSubtitlesInManifest = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableSubtitlesInManifest
                )
                MaxAudioChannels = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .MaxAudioChannels
                )
                MinSegments = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .MinSegments
                )
                SegmentLength = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .SegmentLength
                )
                BreakOnNonKeyFrames = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .BreakOnNonKeyFrames
                )
                Conditions = try container.decodeIfPresent(
                    [Components.Schemas.ProfileCondition].self,
                    forKey: .Conditions
                )
                EnableAudioVbrEncoding = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableAudioVbrEncoding
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Container",
                    "Type",
                    "VideoCodec",
                    "AudioCodec",
                    "Protocol",
                    "EstimateContentLength",
                    "EnableMpegtsM2TsMode",
                    "TranscodeSeekInfo",
                    "CopyTimestamps",
                    "Context",
                    "EnableSubtitlesInManifest",
                    "MaxAudioChannels",
                    "MinSegments",
                    "SegmentLength",
                    "BreakOnNonKeyFrames",
                    "Conditions",
                    "EnableAudioVbrEncoding"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/TransportStreamTimestamp`.
        @frozen public enum TransportStreamTimestamp: String, Codable, Hashable, Sendable, CaseIterable {
            case None = "None"
            case Zero = "Zero"
            case Valid = "Valid"
        }
        /// An entity representing the metadata for a group of trickplay tiles.
        ///
        /// - Remark: Generated from `#/components/schemas/TrickplayInfo`.
        public struct TrickplayInfo: Codable, Hashable, Sendable {
            /// Gets or sets width of an individual thumbnail.
            ///
            /// - Remark: Generated from `#/components/schemas/TrickplayInfo/Width`.
            public var Width: Swift.Int32?
            /// Gets or sets height of an individual thumbnail.
            ///
            /// - Remark: Generated from `#/components/schemas/TrickplayInfo/Height`.
            public var Height: Swift.Int32?
            /// Gets or sets amount of thumbnails per row.
            ///
            /// - Remark: Generated from `#/components/schemas/TrickplayInfo/TileWidth`.
            public var TileWidth: Swift.Int32?
            /// Gets or sets amount of thumbnails per column.
            ///
            /// - Remark: Generated from `#/components/schemas/TrickplayInfo/TileHeight`.
            public var TileHeight: Swift.Int32?
            /// Gets or sets total amount of non-black thumbnails.
            ///
            /// - Remark: Generated from `#/components/schemas/TrickplayInfo/ThumbnailCount`.
            public var ThumbnailCount: Swift.Int32?
            /// Gets or sets interval in milliseconds between each trickplay thumbnail.
            ///
            /// - Remark: Generated from `#/components/schemas/TrickplayInfo/Interval`.
            public var Interval: Swift.Int32?
            /// Gets or sets peak bandwith usage in bits per second.
            ///
            /// - Remark: Generated from `#/components/schemas/TrickplayInfo/Bandwidth`.
            public var Bandwidth: Swift.Int32?
            /// Creates a new `TrickplayInfo`.
            ///
            /// - Parameters:
            ///   - Width: Gets or sets width of an individual thumbnail.
            ///   - Height: Gets or sets height of an individual thumbnail.
            ///   - TileWidth: Gets or sets amount of thumbnails per row.
            ///   - TileHeight: Gets or sets amount of thumbnails per column.
            ///   - ThumbnailCount: Gets or sets total amount of non-black thumbnails.
            ///   - Interval: Gets or sets interval in milliseconds between each trickplay thumbnail.
            ///   - Bandwidth: Gets or sets peak bandwith usage in bits per second.
            public init(
                Width: Swift.Int32? = nil,
                Height: Swift.Int32? = nil,
                TileWidth: Swift.Int32? = nil,
                TileHeight: Swift.Int32? = nil,
                ThumbnailCount: Swift.Int32? = nil,
                Interval: Swift.Int32? = nil,
                Bandwidth: Swift.Int32? = nil
            ) {
                self.Width = Width
                self.Height = Height
                self.TileWidth = TileWidth
                self.TileHeight = TileHeight
                self.ThumbnailCount = ThumbnailCount
                self.Interval = Interval
                self.Bandwidth = Bandwidth
            }
            public enum CodingKeys: String, CodingKey {
                case Width
                case Height
                case TileWidth
                case TileHeight
                case ThumbnailCount
                case Interval
                case Bandwidth
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Width = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .Width
                )
                Height = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .Height
                )
                TileWidth = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .TileWidth
                )
                TileHeight = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .TileHeight
                )
                ThumbnailCount = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .ThumbnailCount
                )
                Interval = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .Interval
                )
                Bandwidth = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .Bandwidth
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Width",
                    "Height",
                    "TileWidth",
                    "TileHeight",
                    "ThumbnailCount",
                    "Interval",
                    "Bandwidth"
                ])
            }
        }
        /// An enum representing an unrated item.
        ///
        /// - Remark: Generated from `#/components/schemas/UnratedItem`.
        @frozen public enum UnratedItem: String, Codable, Hashable, Sendable, CaseIterable {
            case Movie = "Movie"
            case Trailer = "Trailer"
            case Series = "Series"
            case Music = "Music"
            case Book = "Book"
            case LiveTvChannel = "LiveTvChannel"
            case LiveTvProgram = "LiveTvProgram"
            case ChannelContent = "ChannelContent"
            case Other = "Other"
        }
        /// This is used by the api to get information about a item user data.
        ///
        /// - Remark: Generated from `#/components/schemas/UpdateUserItemDataDto`.
        public struct UpdateUserItemDataDto: Codable, Hashable, Sendable {
            /// Gets or sets the rating.
            ///
            /// - Remark: Generated from `#/components/schemas/UpdateUserItemDataDto/Rating`.
            public var Rating: Swift.Double?
            /// Gets or sets the played percentage.
            ///
            /// - Remark: Generated from `#/components/schemas/UpdateUserItemDataDto/PlayedPercentage`.
            public var PlayedPercentage: Swift.Double?
            /// Gets or sets the unplayed item count.
            ///
            /// - Remark: Generated from `#/components/schemas/UpdateUserItemDataDto/UnplayedItemCount`.
            public var UnplayedItemCount: Swift.Int32?
            /// Gets or sets the playback position ticks.
            ///
            /// - Remark: Generated from `#/components/schemas/UpdateUserItemDataDto/PlaybackPositionTicks`.
            public var PlaybackPositionTicks: Swift.Int64?
            /// Gets or sets the play count.
            ///
            /// - Remark: Generated from `#/components/schemas/UpdateUserItemDataDto/PlayCount`.
            public var PlayCount: Swift.Int32?
            /// Gets or sets a value indicating whether this instance is favorite.
            ///
            /// - Remark: Generated from `#/components/schemas/UpdateUserItemDataDto/IsFavorite`.
            public var IsFavorite: Swift.Bool?
            /// Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UpdateUserItemDataDto is likes.
            ///
            /// - Remark: Generated from `#/components/schemas/UpdateUserItemDataDto/Likes`.
            public var Likes: Swift.Bool?
            /// Gets or sets the last played date.
            ///
            /// - Remark: Generated from `#/components/schemas/UpdateUserItemDataDto/LastPlayedDate`.
            public var LastPlayedDate: Foundation.Date?
            /// Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is played.
            ///
            /// - Remark: Generated from `#/components/schemas/UpdateUserItemDataDto/Played`.
            public var Played: Swift.Bool?
            /// Gets or sets the key.
            ///
            /// - Remark: Generated from `#/components/schemas/UpdateUserItemDataDto/Key`.
            public var Key: Swift.String?
            /// Gets or sets the item identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/UpdateUserItemDataDto/ItemId`.
            public var ItemId: Swift.String?
            /// Creates a new `UpdateUserItemDataDto`.
            ///
            /// - Parameters:
            ///   - Rating: Gets or sets the rating.
            ///   - PlayedPercentage: Gets or sets the played percentage.
            ///   - UnplayedItemCount: Gets or sets the unplayed item count.
            ///   - PlaybackPositionTicks: Gets or sets the playback position ticks.
            ///   - PlayCount: Gets or sets the play count.
            ///   - IsFavorite: Gets or sets a value indicating whether this instance is favorite.
            ///   - Likes: Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UpdateUserItemDataDto is likes.
            ///   - LastPlayedDate: Gets or sets the last played date.
            ///   - Played: Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is played.
            ///   - Key: Gets or sets the key.
            ///   - ItemId: Gets or sets the item identifier.
            public init(
                Rating: Swift.Double? = nil,
                PlayedPercentage: Swift.Double? = nil,
                UnplayedItemCount: Swift.Int32? = nil,
                PlaybackPositionTicks: Swift.Int64? = nil,
                PlayCount: Swift.Int32? = nil,
                IsFavorite: Swift.Bool? = nil,
                Likes: Swift.Bool? = nil,
                LastPlayedDate: Foundation.Date? = nil,
                Played: Swift.Bool? = nil,
                Key: Swift.String? = nil,
                ItemId: Swift.String? = nil
            ) {
                self.Rating = Rating
                self.PlayedPercentage = PlayedPercentage
                self.UnplayedItemCount = UnplayedItemCount
                self.PlaybackPositionTicks = PlaybackPositionTicks
                self.PlayCount = PlayCount
                self.IsFavorite = IsFavorite
                self.Likes = Likes
                self.LastPlayedDate = LastPlayedDate
                self.Played = Played
                self.Key = Key
                self.ItemId = ItemId
            }
            public enum CodingKeys: String, CodingKey {
                case Rating
                case PlayedPercentage
                case UnplayedItemCount
                case PlaybackPositionTicks
                case PlayCount
                case IsFavorite
                case Likes
                case LastPlayedDate
                case Played
                case Key
                case ItemId
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Rating = try container.decodeIfPresent(
                    Swift.Double.self,
                    forKey: .Rating
                )
                PlayedPercentage = try container.decodeIfPresent(
                    Swift.Double.self,
                    forKey: .PlayedPercentage
                )
                UnplayedItemCount = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .UnplayedItemCount
                )
                PlaybackPositionTicks = try container.decodeIfPresent(
                    Swift.Int64.self,
                    forKey: .PlaybackPositionTicks
                )
                PlayCount = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .PlayCount
                )
                IsFavorite = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsFavorite
                )
                Likes = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .Likes
                )
                LastPlayedDate = try container.decodeIfPresent(
                    Foundation.Date.self,
                    forKey: .LastPlayedDate
                )
                Played = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .Played
                )
                Key = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Key
                )
                ItemId = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ItemId
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Rating",
                    "PlayedPercentage",
                    "UnplayedItemCount",
                    "PlaybackPositionTicks",
                    "PlayCount",
                    "IsFavorite",
                    "Likes",
                    "LastPlayedDate",
                    "Played",
                    "Key",
                    "ItemId"
                ])
            }
        }
        /// Class UserConfiguration.
        ///
        /// - Remark: Generated from `#/components/schemas/UserConfiguration`.
        public struct UserConfiguration: Codable, Hashable, Sendable {
            /// Gets or sets the audio language preference.
            ///
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/AudioLanguagePreference`.
            public var AudioLanguagePreference: Swift.String?
            /// Gets or sets a value indicating whether [play default audio track].
            ///
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/PlayDefaultAudioTrack`.
            public var PlayDefaultAudioTrack: Swift.Bool?
            /// Gets or sets the subtitle language preference.
            ///
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/SubtitleLanguagePreference`.
            public var SubtitleLanguagePreference: Swift.String?
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/DisplayMissingEpisodes`.
            public var DisplayMissingEpisodes: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/GroupedFolders`.
            public var GroupedFolders: [Swift.String]?
            /// An enum representing a subtitle playback mode.
            ///
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/SubtitleMode`.
            public struct SubtitleModePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/UserConfiguration/SubtitleMode/value1`.
                public var value1: Components.Schemas.SubtitlePlaybackMode
                /// Creates a new `SubtitleModePayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.SubtitlePlaybackMode) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// An enum representing a subtitle playback mode.
            ///
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/SubtitleMode`.
            public var SubtitleMode: Components.Schemas.UserConfiguration.SubtitleModePayload?
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/DisplayCollectionsView`.
            public var DisplayCollectionsView: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/EnableLocalPassword`.
            public var EnableLocalPassword: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/OrderedViews`.
            public var OrderedViews: [Swift.String]?
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/LatestItemsExcludes`.
            public var LatestItemsExcludes: [Swift.String]?
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/MyMediaExcludes`.
            public var MyMediaExcludes: [Swift.String]?
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/HidePlayedInLatest`.
            public var HidePlayedInLatest: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/RememberAudioSelections`.
            public var RememberAudioSelections: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/RememberSubtitleSelections`.
            public var RememberSubtitleSelections: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/EnableNextEpisodeAutoPlay`.
            public var EnableNextEpisodeAutoPlay: Swift.Bool?
            /// Gets or sets the id of the selected cast receiver.
            ///
            /// - Remark: Generated from `#/components/schemas/UserConfiguration/CastReceiverId`.
            public var CastReceiverId: Swift.String?
            /// Creates a new `UserConfiguration`.
            ///
            /// - Parameters:
            ///   - AudioLanguagePreference: Gets or sets the audio language preference.
            ///   - PlayDefaultAudioTrack: Gets or sets a value indicating whether [play default audio track].
            ///   - SubtitleLanguagePreference: Gets or sets the subtitle language preference.
            ///   - DisplayMissingEpisodes:
            ///   - GroupedFolders:
            ///   - SubtitleMode: An enum representing a subtitle playback mode.
            ///   - DisplayCollectionsView:
            ///   - EnableLocalPassword:
            ///   - OrderedViews:
            ///   - LatestItemsExcludes:
            ///   - MyMediaExcludes:
            ///   - HidePlayedInLatest:
            ///   - RememberAudioSelections:
            ///   - RememberSubtitleSelections:
            ///   - EnableNextEpisodeAutoPlay:
            ///   - CastReceiverId: Gets or sets the id of the selected cast receiver.
            public init(
                AudioLanguagePreference: Swift.String? = nil,
                PlayDefaultAudioTrack: Swift.Bool? = nil,
                SubtitleLanguagePreference: Swift.String? = nil,
                DisplayMissingEpisodes: Swift.Bool? = nil,
                GroupedFolders: [Swift.String]? = nil,
                SubtitleMode: Components.Schemas.UserConfiguration.SubtitleModePayload? = nil,
                DisplayCollectionsView: Swift.Bool? = nil,
                EnableLocalPassword: Swift.Bool? = nil,
                OrderedViews: [Swift.String]? = nil,
                LatestItemsExcludes: [Swift.String]? = nil,
                MyMediaExcludes: [Swift.String]? = nil,
                HidePlayedInLatest: Swift.Bool? = nil,
                RememberAudioSelections: Swift.Bool? = nil,
                RememberSubtitleSelections: Swift.Bool? = nil,
                EnableNextEpisodeAutoPlay: Swift.Bool? = nil,
                CastReceiverId: Swift.String? = nil
            ) {
                self.AudioLanguagePreference = AudioLanguagePreference
                self.PlayDefaultAudioTrack = PlayDefaultAudioTrack
                self.SubtitleLanguagePreference = SubtitleLanguagePreference
                self.DisplayMissingEpisodes = DisplayMissingEpisodes
                self.GroupedFolders = GroupedFolders
                self.SubtitleMode = SubtitleMode
                self.DisplayCollectionsView = DisplayCollectionsView
                self.EnableLocalPassword = EnableLocalPassword
                self.OrderedViews = OrderedViews
                self.LatestItemsExcludes = LatestItemsExcludes
                self.MyMediaExcludes = MyMediaExcludes
                self.HidePlayedInLatest = HidePlayedInLatest
                self.RememberAudioSelections = RememberAudioSelections
                self.RememberSubtitleSelections = RememberSubtitleSelections
                self.EnableNextEpisodeAutoPlay = EnableNextEpisodeAutoPlay
                self.CastReceiverId = CastReceiverId
            }
            public enum CodingKeys: String, CodingKey {
                case AudioLanguagePreference
                case PlayDefaultAudioTrack
                case SubtitleLanguagePreference
                case DisplayMissingEpisodes
                case GroupedFolders
                case SubtitleMode
                case DisplayCollectionsView
                case EnableLocalPassword
                case OrderedViews
                case LatestItemsExcludes
                case MyMediaExcludes
                case HidePlayedInLatest
                case RememberAudioSelections
                case RememberSubtitleSelections
                case EnableNextEpisodeAutoPlay
                case CastReceiverId
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                AudioLanguagePreference = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .AudioLanguagePreference
                )
                PlayDefaultAudioTrack = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .PlayDefaultAudioTrack
                )
                SubtitleLanguagePreference = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .SubtitleLanguagePreference
                )
                DisplayMissingEpisodes = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .DisplayMissingEpisodes
                )
                GroupedFolders = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .GroupedFolders
                )
                SubtitleMode = try container.decodeIfPresent(
                    Components.Schemas.UserConfiguration.SubtitleModePayload.self,
                    forKey: .SubtitleMode
                )
                DisplayCollectionsView = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .DisplayCollectionsView
                )
                EnableLocalPassword = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableLocalPassword
                )
                OrderedViews = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .OrderedViews
                )
                LatestItemsExcludes = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .LatestItemsExcludes
                )
                MyMediaExcludes = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .MyMediaExcludes
                )
                HidePlayedInLatest = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .HidePlayedInLatest
                )
                RememberAudioSelections = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .RememberAudioSelections
                )
                RememberSubtitleSelections = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .RememberSubtitleSelections
                )
                EnableNextEpisodeAutoPlay = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableNextEpisodeAutoPlay
                )
                CastReceiverId = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .CastReceiverId
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "AudioLanguagePreference",
                    "PlayDefaultAudioTrack",
                    "SubtitleLanguagePreference",
                    "DisplayMissingEpisodes",
                    "GroupedFolders",
                    "SubtitleMode",
                    "DisplayCollectionsView",
                    "EnableLocalPassword",
                    "OrderedViews",
                    "LatestItemsExcludes",
                    "MyMediaExcludes",
                    "HidePlayedInLatest",
                    "RememberAudioSelections",
                    "RememberSubtitleSelections",
                    "EnableNextEpisodeAutoPlay",
                    "CastReceiverId"
                ])
            }
        }
        /// Class UserDto.
        ///
        /// - Remark: Generated from `#/components/schemas/UserDto`.
        public struct UserDto: Codable, Hashable, Sendable {
            /// Gets or sets the name.
            ///
            /// - Remark: Generated from `#/components/schemas/UserDto/Name`.
            public var Name: Swift.String?
            /// Gets or sets the server identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/UserDto/ServerId`.
            public var ServerId: Swift.String?
            /// Gets or sets the name of the server.
            /// This is not used by the server and is for client-side usage only.
            ///
            /// - Remark: Generated from `#/components/schemas/UserDto/ServerName`.
            public var ServerName: Swift.String?
            /// Gets or sets the id.
            ///
            /// - Remark: Generated from `#/components/schemas/UserDto/Id`.
            public var Id: Swift.String?
            /// Gets or sets the primary image tag.
            ///
            /// - Remark: Generated from `#/components/schemas/UserDto/PrimaryImageTag`.
            public var PrimaryImageTag: Swift.String?
            /// Gets or sets a value indicating whether this instance has password.
            ///
            /// - Remark: Generated from `#/components/schemas/UserDto/HasPassword`.
            public var HasPassword: Swift.Bool?
            /// Gets or sets a value indicating whether this instance has configured password.
            ///
            /// - Remark: Generated from `#/components/schemas/UserDto/HasConfiguredPassword`.
            public var HasConfiguredPassword: Swift.Bool?
            /// Gets or sets a value indicating whether this instance has configured easy password.
            ///
            /// - Remark: Generated from `#/components/schemas/UserDto/HasConfiguredEasyPassword`.
            @available(*, deprecated)
            public var HasConfiguredEasyPassword: Swift.Bool?
            /// Gets or sets whether async login is enabled or not.
            ///
            /// - Remark: Generated from `#/components/schemas/UserDto/EnableAutoLogin`.
            public var EnableAutoLogin: Swift.Bool?
            /// Gets or sets the last login date.
            ///
            /// - Remark: Generated from `#/components/schemas/UserDto/LastLoginDate`.
            public var LastLoginDate: Foundation.Date?
            /// Gets or sets the last activity date.
            ///
            /// - Remark: Generated from `#/components/schemas/UserDto/LastActivityDate`.
            public var LastActivityDate: Foundation.Date?
            /// Gets or sets the configuration.
            ///
            /// - Remark: Generated from `#/components/schemas/UserDto/Configuration`.
            public struct ConfigurationPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/UserDto/Configuration/value1`.
                public var value1: Components.Schemas.UserConfiguration
                /// Creates a new `ConfigurationPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.UserConfiguration) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try value1.encode(to: encoder)
                }
            }
            /// Gets or sets the configuration.
            ///
            /// - Remark: Generated from `#/components/schemas/UserDto/Configuration`.
            public var Configuration: Components.Schemas.UserDto.ConfigurationPayload?
            /// Gets or sets the policy.
            ///
            /// - Remark: Generated from `#/components/schemas/UserDto/Policy`.
            public struct PolicyPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/UserDto/Policy/value1`.
                public var value1: Components.Schemas.UserPolicy
                /// Creates a new `PolicyPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.UserPolicy) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try value1.encode(to: encoder)
                }
            }
            /// Gets or sets the policy.
            ///
            /// - Remark: Generated from `#/components/schemas/UserDto/Policy`.
            public var Policy: Components.Schemas.UserDto.PolicyPayload?
            /// Gets or sets the primary image aspect ratio.
            ///
            /// - Remark: Generated from `#/components/schemas/UserDto/PrimaryImageAspectRatio`.
            public var PrimaryImageAspectRatio: Swift.Double?
            /// Creates a new `UserDto`.
            ///
            /// - Parameters:
            ///   - Name: Gets or sets the name.
            ///   - ServerId: Gets or sets the server identifier.
            ///   - ServerName: Gets or sets the name of the server.
            /// This is not used by the server and is for client-side usage only.
            ///   - Id: Gets or sets the id.
            ///   - PrimaryImageTag: Gets or sets the primary image tag.
            ///   - HasPassword: Gets or sets a value indicating whether this instance has password.
            ///   - HasConfiguredPassword: Gets or sets a value indicating whether this instance has configured password.
            ///   - HasConfiguredEasyPassword: Gets or sets a value indicating whether this instance has configured easy password.
            ///   - EnableAutoLogin: Gets or sets whether async login is enabled or not.
            ///   - LastLoginDate: Gets or sets the last login date.
            ///   - LastActivityDate: Gets or sets the last activity date.
            ///   - Configuration: Gets or sets the configuration.
            ///   - Policy: Gets or sets the policy.
            ///   - PrimaryImageAspectRatio: Gets or sets the primary image aspect ratio.
            public init(
                Name: Swift.String? = nil,
                ServerId: Swift.String? = nil,
                ServerName: Swift.String? = nil,
                Id: Swift.String? = nil,
                PrimaryImageTag: Swift.String? = nil,
                HasPassword: Swift.Bool? = nil,
                HasConfiguredPassword: Swift.Bool? = nil,
                HasConfiguredEasyPassword: Swift.Bool? = nil,
                EnableAutoLogin: Swift.Bool? = nil,
                LastLoginDate: Foundation.Date? = nil,
                LastActivityDate: Foundation.Date? = nil,
                Configuration: Components.Schemas.UserDto.ConfigurationPayload? = nil,
                Policy: Components.Schemas.UserDto.PolicyPayload? = nil,
                PrimaryImageAspectRatio: Swift.Double? = nil
            ) {
                self.Name = Name
                self.ServerId = ServerId
                self.ServerName = ServerName
                self.Id = Id
                self.PrimaryImageTag = PrimaryImageTag
                self.HasPassword = HasPassword
                self.HasConfiguredPassword = HasConfiguredPassword
                self.HasConfiguredEasyPassword = HasConfiguredEasyPassword
                self.EnableAutoLogin = EnableAutoLogin
                self.LastLoginDate = LastLoginDate
                self.LastActivityDate = LastActivityDate
                self.Configuration = Configuration
                self.Policy = Policy
                self.PrimaryImageAspectRatio = PrimaryImageAspectRatio
            }
            public enum CodingKeys: String, CodingKey {
                case Name
                case ServerId
                case ServerName
                case Id
                case PrimaryImageTag
                case HasPassword
                case HasConfiguredPassword
                case HasConfiguredEasyPassword
                case EnableAutoLogin
                case LastLoginDate
                case LastActivityDate
                case Configuration
                case Policy
                case PrimaryImageAspectRatio
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Name = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Name
                )
                ServerId = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ServerId
                )
                ServerName = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ServerName
                )
                Id = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Id
                )
                PrimaryImageTag = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .PrimaryImageTag
                )
                HasPassword = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .HasPassword
                )
                HasConfiguredPassword = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .HasConfiguredPassword
                )
                HasConfiguredEasyPassword = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .HasConfiguredEasyPassword
                )
                EnableAutoLogin = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableAutoLogin
                )
                LastLoginDate = try container.decodeIfPresent(
                    Foundation.Date.self,
                    forKey: .LastLoginDate
                )
                LastActivityDate = try container.decodeIfPresent(
                    Foundation.Date.self,
                    forKey: .LastActivityDate
                )
                Configuration = try container.decodeIfPresent(
                    Components.Schemas.UserDto.ConfigurationPayload.self,
                    forKey: .Configuration
                )
                Policy = try container.decodeIfPresent(
                    Components.Schemas.UserDto.PolicyPayload.self,
                    forKey: .Policy
                )
                PrimaryImageAspectRatio = try container.decodeIfPresent(
                    Swift.Double.self,
                    forKey: .PrimaryImageAspectRatio
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Name",
                    "ServerId",
                    "ServerName",
                    "Id",
                    "PrimaryImageTag",
                    "HasPassword",
                    "HasConfiguredPassword",
                    "HasConfiguredEasyPassword",
                    "EnableAutoLogin",
                    "LastLoginDate",
                    "LastActivityDate",
                    "Configuration",
                    "Policy",
                    "PrimaryImageAspectRatio"
                ])
            }
        }
        /// Class UserItemDataDto.
        ///
        /// - Remark: Generated from `#/components/schemas/UserItemDataDto`.
        public struct UserItemDataDto: Codable, Hashable, Sendable {
            /// Gets or sets the rating.
            ///
            /// - Remark: Generated from `#/components/schemas/UserItemDataDto/Rating`.
            public var Rating: Swift.Double?
            /// Gets or sets the played percentage.
            ///
            /// - Remark: Generated from `#/components/schemas/UserItemDataDto/PlayedPercentage`.
            public var PlayedPercentage: Swift.Double?
            /// Gets or sets the unplayed item count.
            ///
            /// - Remark: Generated from `#/components/schemas/UserItemDataDto/UnplayedItemCount`.
            public var UnplayedItemCount: Swift.Int32?
            /// Gets or sets the playback position ticks.
            ///
            /// - Remark: Generated from `#/components/schemas/UserItemDataDto/PlaybackPositionTicks`.
            public var PlaybackPositionTicks: Swift.Int64?
            /// Gets or sets the play count.
            ///
            /// - Remark: Generated from `#/components/schemas/UserItemDataDto/PlayCount`.
            public var PlayCount: Swift.Int32?
            /// Gets or sets a value indicating whether this instance is favorite.
            ///
            /// - Remark: Generated from `#/components/schemas/UserItemDataDto/IsFavorite`.
            public var IsFavorite: Swift.Bool?
            /// Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is likes.
            ///
            /// - Remark: Generated from `#/components/schemas/UserItemDataDto/Likes`.
            public var Likes: Swift.Bool?
            /// Gets or sets the last played date.
            ///
            /// - Remark: Generated from `#/components/schemas/UserItemDataDto/LastPlayedDate`.
            public var LastPlayedDate: Foundation.Date?
            /// Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is played.
            ///
            /// - Remark: Generated from `#/components/schemas/UserItemDataDto/Played`.
            public var Played: Swift.Bool?
            /// Gets or sets the key.
            ///
            /// - Remark: Generated from `#/components/schemas/UserItemDataDto/Key`.
            public var Key: Swift.String?
            /// Gets or sets the item identifier.
            ///
            /// - Remark: Generated from `#/components/schemas/UserItemDataDto/ItemId`.
            public var ItemId: Swift.String?
            /// Creates a new `UserItemDataDto`.
            ///
            /// - Parameters:
            ///   - Rating: Gets or sets the rating.
            ///   - PlayedPercentage: Gets or sets the played percentage.
            ///   - UnplayedItemCount: Gets or sets the unplayed item count.
            ///   - PlaybackPositionTicks: Gets or sets the playback position ticks.
            ///   - PlayCount: Gets or sets the play count.
            ///   - IsFavorite: Gets or sets a value indicating whether this instance is favorite.
            ///   - Likes: Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is likes.
            ///   - LastPlayedDate: Gets or sets the last played date.
            ///   - Played: Gets or sets a value indicating whether this MediaBrowser.Model.Dto.UserItemDataDto is played.
            ///   - Key: Gets or sets the key.
            ///   - ItemId: Gets or sets the item identifier.
            public init(
                Rating: Swift.Double? = nil,
                PlayedPercentage: Swift.Double? = nil,
                UnplayedItemCount: Swift.Int32? = nil,
                PlaybackPositionTicks: Swift.Int64? = nil,
                PlayCount: Swift.Int32? = nil,
                IsFavorite: Swift.Bool? = nil,
                Likes: Swift.Bool? = nil,
                LastPlayedDate: Foundation.Date? = nil,
                Played: Swift.Bool? = nil,
                Key: Swift.String? = nil,
                ItemId: Swift.String? = nil
            ) {
                self.Rating = Rating
                self.PlayedPercentage = PlayedPercentage
                self.UnplayedItemCount = UnplayedItemCount
                self.PlaybackPositionTicks = PlaybackPositionTicks
                self.PlayCount = PlayCount
                self.IsFavorite = IsFavorite
                self.Likes = Likes
                self.LastPlayedDate = LastPlayedDate
                self.Played = Played
                self.Key = Key
                self.ItemId = ItemId
            }
            public enum CodingKeys: String, CodingKey {
                case Rating
                case PlayedPercentage
                case UnplayedItemCount
                case PlaybackPositionTicks
                case PlayCount
                case IsFavorite
                case Likes
                case LastPlayedDate
                case Played
                case Key
                case ItemId
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                Rating = try container.decodeIfPresent(
                    Swift.Double.self,
                    forKey: .Rating
                )
                PlayedPercentage = try container.decodeIfPresent(
                    Swift.Double.self,
                    forKey: .PlayedPercentage
                )
                UnplayedItemCount = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .UnplayedItemCount
                )
                PlaybackPositionTicks = try container.decodeIfPresent(
                    Swift.Int64.self,
                    forKey: .PlaybackPositionTicks
                )
                PlayCount = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .PlayCount
                )
                IsFavorite = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsFavorite
                )
                Likes = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .Likes
                )
                LastPlayedDate = try container.decodeIfPresent(
                    Foundation.Date.self,
                    forKey: .LastPlayedDate
                )
                Played = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .Played
                )
                Key = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .Key
                )
                ItemId = try container.decodeIfPresent(
                    Swift.String.self,
                    forKey: .ItemId
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "Rating",
                    "PlayedPercentage",
                    "UnplayedItemCount",
                    "PlaybackPositionTicks",
                    "PlayCount",
                    "IsFavorite",
                    "Likes",
                    "LastPlayedDate",
                    "Played",
                    "Key",
                    "ItemId"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/UserPolicy`.
        public struct UserPolicy: Codable, Hashable, Sendable {
            /// Gets or sets a value indicating whether this instance is administrator.
            ///
            /// - Remark: Generated from `#/components/schemas/UserPolicy/IsAdministrator`.
            public var IsAdministrator: Swift.Bool?
            /// Gets or sets a value indicating whether this instance is hidden.
            ///
            /// - Remark: Generated from `#/components/schemas/UserPolicy/IsHidden`.
            public var IsHidden: Swift.Bool?
            /// Gets or sets a value indicating whether this instance can manage collections.
            ///
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableCollectionManagement`.
            public var EnableCollectionManagement: Swift.Bool?
            /// Gets or sets a value indicating whether this instance can manage subtitles.
            ///
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableSubtitleManagement`.
            public var EnableSubtitleManagement: Swift.Bool?
            /// Gets or sets a value indicating whether this user can manage lyrics.
            ///
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableLyricManagement`.
            public var EnableLyricManagement: Swift.Bool?
            /// Gets or sets a value indicating whether this instance is disabled.
            ///
            /// - Remark: Generated from `#/components/schemas/UserPolicy/IsDisabled`.
            public var IsDisabled: Swift.Bool?
            /// Gets or sets the max parental rating.
            ///
            /// - Remark: Generated from `#/components/schemas/UserPolicy/MaxParentalRating`.
            public var MaxParentalRating: Swift.Int32?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/BlockedTags`.
            public var BlockedTags: [Swift.String]?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/AllowedTags`.
            public var AllowedTags: [Swift.String]?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableUserPreferenceAccess`.
            public var EnableUserPreferenceAccess: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/AccessSchedules`.
            public var AccessSchedules: [Components.Schemas.AccessSchedule]?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/BlockUnratedItems`.
            public var BlockUnratedItems: [Components.Schemas.UnratedItem]?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableRemoteControlOfOtherUsers`.
            public var EnableRemoteControlOfOtherUsers: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableSharedDeviceControl`.
            public var EnableSharedDeviceControl: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableRemoteAccess`.
            public var EnableRemoteAccess: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableLiveTvManagement`.
            public var EnableLiveTvManagement: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableLiveTvAccess`.
            public var EnableLiveTvAccess: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableMediaPlayback`.
            public var EnableMediaPlayback: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableAudioPlaybackTranscoding`.
            public var EnableAudioPlaybackTranscoding: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableVideoPlaybackTranscoding`.
            public var EnableVideoPlaybackTranscoding: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnablePlaybackRemuxing`.
            public var EnablePlaybackRemuxing: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/ForceRemoteSourceTranscoding`.
            public var ForceRemoteSourceTranscoding: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableContentDeletion`.
            public var EnableContentDeletion: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableContentDeletionFromFolders`.
            public var EnableContentDeletionFromFolders: [Swift.String]?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableContentDownloading`.
            public var EnableContentDownloading: Swift.Bool?
            /// Gets or sets a value indicating whether [enable synchronize].
            ///
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableSyncTranscoding`.
            public var EnableSyncTranscoding: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableMediaConversion`.
            public var EnableMediaConversion: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnabledDevices`.
            public var EnabledDevices: [Swift.String]?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableAllDevices`.
            public var EnableAllDevices: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnabledChannels`.
            public var EnabledChannels: [Swift.String]?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableAllChannels`.
            public var EnableAllChannels: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnabledFolders`.
            public var EnabledFolders: [Swift.String]?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnableAllFolders`.
            public var EnableAllFolders: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/InvalidLoginAttemptCount`.
            public var InvalidLoginAttemptCount: Swift.Int32?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/LoginAttemptsBeforeLockout`.
            public var LoginAttemptsBeforeLockout: Swift.Int32?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/MaxActiveSessions`.
            public var MaxActiveSessions: Swift.Int32?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/EnablePublicSharing`.
            public var EnablePublicSharing: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/BlockedMediaFolders`.
            public var BlockedMediaFolders: [Swift.String]?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/BlockedChannels`.
            public var BlockedChannels: [Swift.String]?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/RemoteClientBitrateLimit`.
            public var RemoteClientBitrateLimit: Swift.Int32?
            /// - Remark: Generated from `#/components/schemas/UserPolicy/AuthenticationProviderId`.
            public var AuthenticationProviderId: Swift.String
            /// - Remark: Generated from `#/components/schemas/UserPolicy/PasswordResetProviderId`.
            public var PasswordResetProviderId: Swift.String
            /// Enum SyncPlayUserAccessType.
            ///
            /// - Remark: Generated from `#/components/schemas/UserPolicy/SyncPlayAccess`.
            public struct SyncPlayAccessPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/UserPolicy/SyncPlayAccess/value1`.
                public var value1: Components.Schemas.SyncPlayUserAccessType
                /// Creates a new `SyncPlayAccessPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                public init(value1: Components.Schemas.SyncPlayUserAccessType) {
                    self.value1 = value1
                }
                public init(from decoder: any Decoder) throws {
                    value1 = try decoder.decodeFromSingleValueContainer()
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeToSingleValueContainer(value1)
                }
            }
            /// Enum SyncPlayUserAccessType.
            ///
            /// - Remark: Generated from `#/components/schemas/UserPolicy/SyncPlayAccess`.
            public var SyncPlayAccess: Components.Schemas.UserPolicy.SyncPlayAccessPayload?
            /// Creates a new `UserPolicy`.
            ///
            /// - Parameters:
            ///   - IsAdministrator: Gets or sets a value indicating whether this instance is administrator.
            ///   - IsHidden: Gets or sets a value indicating whether this instance is hidden.
            ///   - EnableCollectionManagement: Gets or sets a value indicating whether this instance can manage collections.
            ///   - EnableSubtitleManagement: Gets or sets a value indicating whether this instance can manage subtitles.
            ///   - EnableLyricManagement: Gets or sets a value indicating whether this user can manage lyrics.
            ///   - IsDisabled: Gets or sets a value indicating whether this instance is disabled.
            ///   - MaxParentalRating: Gets or sets the max parental rating.
            ///   - BlockedTags:
            ///   - AllowedTags:
            ///   - EnableUserPreferenceAccess:
            ///   - AccessSchedules:
            ///   - BlockUnratedItems:
            ///   - EnableRemoteControlOfOtherUsers:
            ///   - EnableSharedDeviceControl:
            ///   - EnableRemoteAccess:
            ///   - EnableLiveTvManagement:
            ///   - EnableLiveTvAccess:
            ///   - EnableMediaPlayback:
            ///   - EnableAudioPlaybackTranscoding:
            ///   - EnableVideoPlaybackTranscoding:
            ///   - EnablePlaybackRemuxing:
            ///   - ForceRemoteSourceTranscoding:
            ///   - EnableContentDeletion:
            ///   - EnableContentDeletionFromFolders:
            ///   - EnableContentDownloading:
            ///   - EnableSyncTranscoding: Gets or sets a value indicating whether [enable synchronize].
            ///   - EnableMediaConversion:
            ///   - EnabledDevices:
            ///   - EnableAllDevices:
            ///   - EnabledChannels:
            ///   - EnableAllChannels:
            ///   - EnabledFolders:
            ///   - EnableAllFolders:
            ///   - InvalidLoginAttemptCount:
            ///   - LoginAttemptsBeforeLockout:
            ///   - MaxActiveSessions:
            ///   - EnablePublicSharing:
            ///   - BlockedMediaFolders:
            ///   - BlockedChannels:
            ///   - RemoteClientBitrateLimit:
            ///   - AuthenticationProviderId:
            ///   - PasswordResetProviderId:
            ///   - SyncPlayAccess: Enum SyncPlayUserAccessType.
            public init(
                IsAdministrator: Swift.Bool? = nil,
                IsHidden: Swift.Bool? = nil,
                EnableCollectionManagement: Swift.Bool? = nil,
                EnableSubtitleManagement: Swift.Bool? = nil,
                EnableLyricManagement: Swift.Bool? = nil,
                IsDisabled: Swift.Bool? = nil,
                MaxParentalRating: Swift.Int32? = nil,
                BlockedTags: [Swift.String]? = nil,
                AllowedTags: [Swift.String]? = nil,
                EnableUserPreferenceAccess: Swift.Bool? = nil,
                AccessSchedules: [Components.Schemas.AccessSchedule]? = nil,
                BlockUnratedItems: [Components.Schemas.UnratedItem]? = nil,
                EnableRemoteControlOfOtherUsers: Swift.Bool? = nil,
                EnableSharedDeviceControl: Swift.Bool? = nil,
                EnableRemoteAccess: Swift.Bool? = nil,
                EnableLiveTvManagement: Swift.Bool? = nil,
                EnableLiveTvAccess: Swift.Bool? = nil,
                EnableMediaPlayback: Swift.Bool? = nil,
                EnableAudioPlaybackTranscoding: Swift.Bool? = nil,
                EnableVideoPlaybackTranscoding: Swift.Bool? = nil,
                EnablePlaybackRemuxing: Swift.Bool? = nil,
                ForceRemoteSourceTranscoding: Swift.Bool? = nil,
                EnableContentDeletion: Swift.Bool? = nil,
                EnableContentDeletionFromFolders: [Swift.String]? = nil,
                EnableContentDownloading: Swift.Bool? = nil,
                EnableSyncTranscoding: Swift.Bool? = nil,
                EnableMediaConversion: Swift.Bool? = nil,
                EnabledDevices: [Swift.String]? = nil,
                EnableAllDevices: Swift.Bool? = nil,
                EnabledChannels: [Swift.String]? = nil,
                EnableAllChannels: Swift.Bool? = nil,
                EnabledFolders: [Swift.String]? = nil,
                EnableAllFolders: Swift.Bool? = nil,
                InvalidLoginAttemptCount: Swift.Int32? = nil,
                LoginAttemptsBeforeLockout: Swift.Int32? = nil,
                MaxActiveSessions: Swift.Int32? = nil,
                EnablePublicSharing: Swift.Bool? = nil,
                BlockedMediaFolders: [Swift.String]? = nil,
                BlockedChannels: [Swift.String]? = nil,
                RemoteClientBitrateLimit: Swift.Int32? = nil,
                AuthenticationProviderId: Swift.String,
                PasswordResetProviderId: Swift.String,
                SyncPlayAccess: Components.Schemas.UserPolicy.SyncPlayAccessPayload? = nil
            ) {
                self.IsAdministrator = IsAdministrator
                self.IsHidden = IsHidden
                self.EnableCollectionManagement = EnableCollectionManagement
                self.EnableSubtitleManagement = EnableSubtitleManagement
                self.EnableLyricManagement = EnableLyricManagement
                self.IsDisabled = IsDisabled
                self.MaxParentalRating = MaxParentalRating
                self.BlockedTags = BlockedTags
                self.AllowedTags = AllowedTags
                self.EnableUserPreferenceAccess = EnableUserPreferenceAccess
                self.AccessSchedules = AccessSchedules
                self.BlockUnratedItems = BlockUnratedItems
                self.EnableRemoteControlOfOtherUsers = EnableRemoteControlOfOtherUsers
                self.EnableSharedDeviceControl = EnableSharedDeviceControl
                self.EnableRemoteAccess = EnableRemoteAccess
                self.EnableLiveTvManagement = EnableLiveTvManagement
                self.EnableLiveTvAccess = EnableLiveTvAccess
                self.EnableMediaPlayback = EnableMediaPlayback
                self.EnableAudioPlaybackTranscoding = EnableAudioPlaybackTranscoding
                self.EnableVideoPlaybackTranscoding = EnableVideoPlaybackTranscoding
                self.EnablePlaybackRemuxing = EnablePlaybackRemuxing
                self.ForceRemoteSourceTranscoding = ForceRemoteSourceTranscoding
                self.EnableContentDeletion = EnableContentDeletion
                self.EnableContentDeletionFromFolders = EnableContentDeletionFromFolders
                self.EnableContentDownloading = EnableContentDownloading
                self.EnableSyncTranscoding = EnableSyncTranscoding
                self.EnableMediaConversion = EnableMediaConversion
                self.EnabledDevices = EnabledDevices
                self.EnableAllDevices = EnableAllDevices
                self.EnabledChannels = EnabledChannels
                self.EnableAllChannels = EnableAllChannels
                self.EnabledFolders = EnabledFolders
                self.EnableAllFolders = EnableAllFolders
                self.InvalidLoginAttemptCount = InvalidLoginAttemptCount
                self.LoginAttemptsBeforeLockout = LoginAttemptsBeforeLockout
                self.MaxActiveSessions = MaxActiveSessions
                self.EnablePublicSharing = EnablePublicSharing
                self.BlockedMediaFolders = BlockedMediaFolders
                self.BlockedChannels = BlockedChannels
                self.RemoteClientBitrateLimit = RemoteClientBitrateLimit
                self.AuthenticationProviderId = AuthenticationProviderId
                self.PasswordResetProviderId = PasswordResetProviderId
                self.SyncPlayAccess = SyncPlayAccess
            }
            public enum CodingKeys: String, CodingKey {
                case IsAdministrator
                case IsHidden
                case EnableCollectionManagement
                case EnableSubtitleManagement
                case EnableLyricManagement
                case IsDisabled
                case MaxParentalRating
                case BlockedTags
                case AllowedTags
                case EnableUserPreferenceAccess
                case AccessSchedules
                case BlockUnratedItems
                case EnableRemoteControlOfOtherUsers
                case EnableSharedDeviceControl
                case EnableRemoteAccess
                case EnableLiveTvManagement
                case EnableLiveTvAccess
                case EnableMediaPlayback
                case EnableAudioPlaybackTranscoding
                case EnableVideoPlaybackTranscoding
                case EnablePlaybackRemuxing
                case ForceRemoteSourceTranscoding
                case EnableContentDeletion
                case EnableContentDeletionFromFolders
                case EnableContentDownloading
                case EnableSyncTranscoding
                case EnableMediaConversion
                case EnabledDevices
                case EnableAllDevices
                case EnabledChannels
                case EnableAllChannels
                case EnabledFolders
                case EnableAllFolders
                case InvalidLoginAttemptCount
                case LoginAttemptsBeforeLockout
                case MaxActiveSessions
                case EnablePublicSharing
                case BlockedMediaFolders
                case BlockedChannels
                case RemoteClientBitrateLimit
                case AuthenticationProviderId
                case PasswordResetProviderId
                case SyncPlayAccess
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                IsAdministrator = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsAdministrator
                )
                IsHidden = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsHidden
                )
                EnableCollectionManagement = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableCollectionManagement
                )
                EnableSubtitleManagement = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableSubtitleManagement
                )
                EnableLyricManagement = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableLyricManagement
                )
                IsDisabled = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .IsDisabled
                )
                MaxParentalRating = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .MaxParentalRating
                )
                BlockedTags = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .BlockedTags
                )
                AllowedTags = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .AllowedTags
                )
                EnableUserPreferenceAccess = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableUserPreferenceAccess
                )
                AccessSchedules = try container.decodeIfPresent(
                    [Components.Schemas.AccessSchedule].self,
                    forKey: .AccessSchedules
                )
                BlockUnratedItems = try container.decodeIfPresent(
                    [Components.Schemas.UnratedItem].self,
                    forKey: .BlockUnratedItems
                )
                EnableRemoteControlOfOtherUsers = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableRemoteControlOfOtherUsers
                )
                EnableSharedDeviceControl = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableSharedDeviceControl
                )
                EnableRemoteAccess = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableRemoteAccess
                )
                EnableLiveTvManagement = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableLiveTvManagement
                )
                EnableLiveTvAccess = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableLiveTvAccess
                )
                EnableMediaPlayback = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableMediaPlayback
                )
                EnableAudioPlaybackTranscoding = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableAudioPlaybackTranscoding
                )
                EnableVideoPlaybackTranscoding = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableVideoPlaybackTranscoding
                )
                EnablePlaybackRemuxing = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnablePlaybackRemuxing
                )
                ForceRemoteSourceTranscoding = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .ForceRemoteSourceTranscoding
                )
                EnableContentDeletion = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableContentDeletion
                )
                EnableContentDeletionFromFolders = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .EnableContentDeletionFromFolders
                )
                EnableContentDownloading = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableContentDownloading
                )
                EnableSyncTranscoding = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableSyncTranscoding
                )
                EnableMediaConversion = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableMediaConversion
                )
                EnabledDevices = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .EnabledDevices
                )
                EnableAllDevices = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableAllDevices
                )
                EnabledChannels = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .EnabledChannels
                )
                EnableAllChannels = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableAllChannels
                )
                EnabledFolders = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .EnabledFolders
                )
                EnableAllFolders = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnableAllFolders
                )
                InvalidLoginAttemptCount = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .InvalidLoginAttemptCount
                )
                LoginAttemptsBeforeLockout = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .LoginAttemptsBeforeLockout
                )
                MaxActiveSessions = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .MaxActiveSessions
                )
                EnablePublicSharing = try container.decodeIfPresent(
                    Swift.Bool.self,
                    forKey: .EnablePublicSharing
                )
                BlockedMediaFolders = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .BlockedMediaFolders
                )
                BlockedChannels = try container.decodeIfPresent(
                    [Swift.String].self,
                    forKey: .BlockedChannels
                )
                RemoteClientBitrateLimit = try container.decodeIfPresent(
                    Swift.Int32.self,
                    forKey: .RemoteClientBitrateLimit
                )
                AuthenticationProviderId = try container.decode(
                    Swift.String.self,
                    forKey: .AuthenticationProviderId
                )
                PasswordResetProviderId = try container.decode(
                    Swift.String.self,
                    forKey: .PasswordResetProviderId
                )
                SyncPlayAccess = try container.decodeIfPresent(
                    Components.Schemas.UserPolicy.SyncPlayAccessPayload.self,
                    forKey: .SyncPlayAccess
                )
                try decoder.ensureNoAdditionalProperties(knownKeys: [
                    "IsAdministrator",
                    "IsHidden",
                    "EnableCollectionManagement",
                    "EnableSubtitleManagement",
                    "EnableLyricManagement",
                    "IsDisabled",
                    "MaxParentalRating",
                    "BlockedTags",
                    "AllowedTags",
                    "EnableUserPreferenceAccess",
                    "AccessSchedules",
                    "BlockUnratedItems",
                    "EnableRemoteControlOfOtherUsers",
                    "EnableSharedDeviceControl",
                    "EnableRemoteAccess",
                    "EnableLiveTvManagement",
                    "EnableLiveTvAccess",
                    "EnableMediaPlayback",
                    "EnableAudioPlaybackTranscoding",
                    "EnableVideoPlaybackTranscoding",
                    "EnablePlaybackRemuxing",
                    "ForceRemoteSourceTranscoding",
                    "EnableContentDeletion",
                    "EnableContentDeletionFromFolders",
                    "EnableContentDownloading",
                    "EnableSyncTranscoding",
                    "EnableMediaConversion",
                    "EnabledDevices",
                    "EnableAllDevices",
                    "EnabledChannels",
                    "EnableAllChannels",
                    "EnabledFolders",
                    "EnableAllFolders",
                    "InvalidLoginAttemptCount",
                    "LoginAttemptsBeforeLockout",
                    "MaxActiveSessions",
                    "EnablePublicSharing",
                    "BlockedMediaFolders",
                    "BlockedChannels",
                    "RemoteClientBitrateLimit",
                    "AuthenticationProviderId",
                    "PasswordResetProviderId",
                    "SyncPlayAccess"
                ])
            }
        }
        /// - Remark: Generated from `#/components/schemas/Video3DFormat`.
        @frozen public enum Video3DFormat: String, Codable, Hashable, Sendable, CaseIterable {
            case HalfSideBySide = "HalfSideBySide"
            case FullSideBySide = "FullSideBySide"
            case FullTopAndBottom = "FullTopAndBottom"
            case HalfTopAndBottom = "HalfTopAndBottom"
            case MVC = "MVC"
        }
        /// An enum representing video ranges.
        ///
        /// - Remark: Generated from `#/components/schemas/VideoRange`.
        @frozen public enum VideoRange: String, Codable, Hashable, Sendable, CaseIterable {
            case Unknown = "Unknown"
            case SDR = "SDR"
            case HDR = "HDR"
        }
        /// An enum representing types of video ranges.
        ///
        /// - Remark: Generated from `#/components/schemas/VideoRangeType`.
        @frozen public enum VideoRangeType: String, Codable, Hashable, Sendable, CaseIterable {
            case Unknown = "Unknown"
            case SDR = "SDR"
            case HDR10 = "HDR10"
            case HLG = "HLG"
            case DOVI = "DOVI"
            case DOVIWithHDR10 = "DOVIWithHDR10"
            case DOVIWithHLG = "DOVIWithHLG"
            case DOVIWithSDR = "DOVIWithSDR"
            case HDR10Plus = "HDR10Plus"
        }
        /// Enum VideoType.
        ///
        /// - Remark: Generated from `#/components/schemas/VideoType`.
        @frozen public enum VideoType: String, Codable, Hashable, Sendable, CaseIterable {
            case VideoFile = "VideoFile"
            case Iso = "Iso"
            case Dvd = "Dvd"
            case BluRay = "BluRay"
        }
    }
    /// Types generated from the `#/components/parameters` section of the OpenAPI document.
    public enum Parameters {}
    /// Types generated from the `#/components/requestBodies` section of the OpenAPI document.
    public enum RequestBodies {}
    /// Types generated from the `#/components/responses` section of the OpenAPI document.
    public enum Responses {}
    /// Types generated from the `#/components/headers` section of the OpenAPI document.
    public enum Headers {}
}

/// API operations, with input and output types, generated from `#/paths` in the OpenAPI document.
public enum Operations {
    /// Gets all artists from a given item, folder, or the entire library.
    ///
    /// - Remark: HTTP `GET /Artists`.
    /// - Remark: Generated from `#/paths//Artists/get(GetArtists)`.
    public enum GetArtists {
        public static let id: Swift.String = "GetArtists"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/Artists/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Optional filter by minimum community rating.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/minCommunityRating`.
                public var minCommunityRating: Swift.Double?
                /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/startIndex`.
                public var startIndex: Swift.Int32?
                /// Optional. The maximum number of records to return.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/limit`.
                public var limit: Swift.Int32?
                /// Optional. Search term.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/searchTerm`.
                public var searchTerm: Swift.String?
                /// Specify this to localize the search to a specific item or folder. Omit to use the root.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/parentId`.
                public var parentId: Swift.String?
                /// Optional. Specify additional fields of information to return in the output.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/fields`.
                public var fields: [Components.Schemas.ItemFields]?
                /// Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/excludeItemTypes`.
                public var excludeItemTypes: [Components.Schemas.BaseItemKind]?
                /// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/includeItemTypes`.
                public var includeItemTypes: [Components.Schemas.BaseItemKind]?
                /// Optional. Specify additional filters to apply.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/filters`.
                public var filters: [Components.Schemas.ItemFilter]?
                /// Optional filter by items that are marked as favorite, or not.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/isFavorite`.
                public var isFavorite: Swift.Bool?
                /// Optional filter by MediaType. Allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/mediaTypes`.
                public var mediaTypes: [Components.Schemas.MediaType]?
                /// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/genres`.
                public var genres: [Swift.String]?
                /// Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/genreIds`.
                public var genreIds: [Swift.String]?
                /// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/officialRatings`.
                public var officialRatings: [Swift.String]?
                /// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/tags`.
                public var tags: [Swift.String]?
                /// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/years`.
                public var years: [Swift.Int32]?
                /// Optional, include user data.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/enableUserData`.
                public var enableUserData: Swift.Bool?
                /// Optional, the max number of images to return, per image type.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/imageTypeLimit`.
                public var imageTypeLimit: Swift.Int32?
                /// Optional. The image types to include in the output.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/enableImageTypes`.
                public var enableImageTypes: [Components.Schemas.ImageType]?
                /// Optional. If specified, results will be filtered to include only those containing the specified person.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/person`.
                public var person: Swift.String?
                /// Optional. If specified, results will be filtered to include only those containing the specified person ids.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/personIds`.
                public var personIds: [Swift.String]?
                /// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/personTypes`.
                public var personTypes: [Swift.String]?
                /// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/studios`.
                public var studios: [Swift.String]?
                /// Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/studioIds`.
                public var studioIds: [Swift.String]?
                /// User id.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/userId`.
                public var userId: Swift.String?
                /// Optional filter by items whose name is sorted equally or greater than a given input string.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/nameStartsWithOrGreater`.
                public var nameStartsWithOrGreater: Swift.String?
                /// Optional filter by items whose name is sorted equally than a given input string.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/nameStartsWith`.
                public var nameStartsWith: Swift.String?
                /// Optional filter by items whose name is equally or lesser than a given input string.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/nameLessThan`.
                public var nameLessThan: Swift.String?
                /// Optional. Specify one or more sort orders, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/sortBy`.
                public var sortBy: [Components.Schemas.ItemSortBy]?
                /// Sort Order - Ascending,Descending.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/sortOrder`.
                public var sortOrder: [Components.Schemas.SortOrder]?
                /// Optional, include image information in output.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/enableImages`.
                public var enableImages: Swift.Bool?
                /// Total record count.
                ///
                /// - Remark: Generated from `#/paths/Artists/GET/query/enableTotalRecordCount`.
                public var enableTotalRecordCount: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - minCommunityRating: Optional filter by minimum community rating.
                ///   - startIndex: Optional. The record index to start at. All items with a lower index will be dropped from the results.
                ///   - limit: Optional. The maximum number of records to return.
                ///   - searchTerm: Optional. Search term.
                ///   - parentId: Specify this to localize the search to a specific item or folder. Omit to use the root.
                ///   - fields: Optional. Specify additional fields of information to return in the output.
                ///   - excludeItemTypes: Optional. If specified, results will be filtered out based on item type. This allows multiple, comma delimited.
                ///   - includeItemTypes: Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
                ///   - filters: Optional. Specify additional filters to apply.
                ///   - isFavorite: Optional filter by items that are marked as favorite, or not.
                ///   - mediaTypes: Optional filter by MediaType. Allows multiple, comma delimited.
                ///   - genres: Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
                ///   - genreIds: Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
                ///   - officialRatings: Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
                ///   - tags: Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
                ///   - years: Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
                ///   - enableUserData: Optional, include user data.
                ///   - imageTypeLimit: Optional, the max number of images to return, per image type.
                ///   - enableImageTypes: Optional. The image types to include in the output.
                ///   - person: Optional. If specified, results will be filtered to include only those containing the specified person.
                ///   - personIds: Optional. If specified, results will be filtered to include only those containing the specified person ids.
                ///   - personTypes: Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
                ///   - studios: Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
                ///   - studioIds: Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
                ///   - userId: User id.
                ///   - nameStartsWithOrGreater: Optional filter by items whose name is sorted equally or greater than a given input string.
                ///   - nameStartsWith: Optional filter by items whose name is sorted equally than a given input string.
                ///   - nameLessThan: Optional filter by items whose name is equally or lesser than a given input string.
                ///   - sortBy: Optional. Specify one or more sort orders, comma delimited.
                ///   - sortOrder: Sort Order - Ascending,Descending.
                ///   - enableImages: Optional, include image information in output.
                ///   - enableTotalRecordCount: Total record count.
                public init(
                    minCommunityRating: Swift.Double? = nil,
                    startIndex: Swift.Int32? = nil,
                    limit: Swift.Int32? = nil,
                    searchTerm: Swift.String? = nil,
                    parentId: Swift.String? = nil,
                    fields: [Components.Schemas.ItemFields]? = nil,
                    excludeItemTypes: [Components.Schemas.BaseItemKind]? = nil,
                    includeItemTypes: [Components.Schemas.BaseItemKind]? = nil,
                    filters: [Components.Schemas.ItemFilter]? = nil,
                    isFavorite: Swift.Bool? = nil,
                    mediaTypes: [Components.Schemas.MediaType]? = nil,
                    genres: [Swift.String]? = nil,
                    genreIds: [Swift.String]? = nil,
                    officialRatings: [Swift.String]? = nil,
                    tags: [Swift.String]? = nil,
                    years: [Swift.Int32]? = nil,
                    enableUserData: Swift.Bool? = nil,
                    imageTypeLimit: Swift.Int32? = nil,
                    enableImageTypes: [Components.Schemas.ImageType]? = nil,
                    person: Swift.String? = nil,
                    personIds: [Swift.String]? = nil,
                    personTypes: [Swift.String]? = nil,
                    studios: [Swift.String]? = nil,
                    studioIds: [Swift.String]? = nil,
                    userId: Swift.String? = nil,
                    nameStartsWithOrGreater: Swift.String? = nil,
                    nameStartsWith: Swift.String? = nil,
                    nameLessThan: Swift.String? = nil,
                    sortBy: [Components.Schemas.ItemSortBy]? = nil,
                    sortOrder: [Components.Schemas.SortOrder]? = nil,
                    enableImages: Swift.Bool? = nil,
                    enableTotalRecordCount: Swift.Bool? = nil
                ) {
                    self.minCommunityRating = minCommunityRating
                    self.startIndex = startIndex
                    self.limit = limit
                    self.searchTerm = searchTerm
                    self.parentId = parentId
                    self.fields = fields
                    self.excludeItemTypes = excludeItemTypes
                    self.includeItemTypes = includeItemTypes
                    self.filters = filters
                    self.isFavorite = isFavorite
                    self.mediaTypes = mediaTypes
                    self.genres = genres
                    self.genreIds = genreIds
                    self.officialRatings = officialRatings
                    self.tags = tags
                    self.years = years
                    self.enableUserData = enableUserData
                    self.imageTypeLimit = imageTypeLimit
                    self.enableImageTypes = enableImageTypes
                    self.person = person
                    self.personIds = personIds
                    self.personTypes = personTypes
                    self.studios = studios
                    self.studioIds = studioIds
                    self.userId = userId
                    self.nameStartsWithOrGreater = nameStartsWithOrGreater
                    self.nameStartsWith = nameStartsWith
                    self.nameLessThan = nameLessThan
                    self.sortBy = sortBy
                    self.sortOrder = sortOrder
                    self.enableImages = enableImages
                    self.enableTotalRecordCount = enableTotalRecordCount
                }
            }
            public var query: Operations.GetArtists.Input.Query
            /// - Remark: Generated from `#/paths/Artists/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.GetArtists.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.GetArtists.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.GetArtists.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.GetArtists.Input.Query = .init(),
                headers: Operations.GetArtists.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/Artists/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/Artists/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.BaseItemDtoQueryResult)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.BaseItemDtoQueryResult {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/Artists/GET/responses/200/content/application\/json; profile="camelcase"`.
                    case application_json_profile__quot_camelcase_quot_(Components.Schemas.BaseItemDtoQueryResult)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_camelcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_camelcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_camelcase_quot_`.
                    public var application_json_profile__quot_camelcase_quot_: Components.Schemas.BaseItemDtoQueryResult {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_camelcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/Artists/GET/responses/200/content/application\/json; profile="pascalcase"`.
                    case application_json_profile__quot_pascalcase_quot_(Components.Schemas.BaseItemDtoQueryResult)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_pascalcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_pascalcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_pascalcase_quot_`.
                    public var application_json_profile__quot_pascalcase_quot_: Components.Schemas.BaseItemDtoQueryResult {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_pascalcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.GetArtists.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.GetArtists.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Artists returned.
            ///
            /// - Remark: Generated from `#/paths//Artists/get(GetArtists)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.GetArtists.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.GetArtists.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct Unauthorized: Sendable, Hashable {
                /// Creates a new `Unauthorized`.
                public init() {}
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//Artists/get(GetArtists)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Operations.GetArtists.Output.Unauthorized)
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//Artists/get(GetArtists)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            public static var unauthorized: Self {
                .unauthorized(.init())
            }
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Operations.GetArtists.Output.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            public struct Forbidden: Sendable, Hashable {
                /// Creates a new `Forbidden`.
                public init() {}
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//Artists/get(GetArtists)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Operations.GetArtists.Output.Forbidden)
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//Artists/get(GetArtists)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            public static var forbidden: Self {
                .forbidden(.init())
            }
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Operations.GetArtists.Output.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Gets an artist by name.
    ///
    /// - Remark: HTTP `GET /Artists/{name}`.
    /// - Remark: Generated from `#/paths//Artists/{name}/get(GetArtistByName)`.
    public enum GetArtistByName {
        public static let id: Swift.String = "GetArtistByName"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/Artists/{name}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// Studio name.
                ///
                /// - Remark: Generated from `#/paths/Artists/{name}/GET/path/name`.
                public var name: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - name: Studio name.
                public init(name: Swift.String) {
                    self.name = name
                }
            }
            public var path: Operations.GetArtistByName.Input.Path
            /// - Remark: Generated from `#/paths/Artists/{name}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Optional. Filter by user id, and attach user data.
                ///
                /// - Remark: Generated from `#/paths/Artists/{name}/GET/query/userId`.
                public var userId: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - userId: Optional. Filter by user id, and attach user data.
                public init(userId: Swift.String? = nil) {
                    self.userId = userId
                }
            }
            public var query: Operations.GetArtistByName.Input.Query
            /// - Remark: Generated from `#/paths/Artists/{name}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.GetArtistByName.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.GetArtistByName.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.GetArtistByName.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.GetArtistByName.Input.Path,
                query: Operations.GetArtistByName.Input.Query = .init(),
                headers: Operations.GetArtistByName.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/Artists/{name}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/Artists/{name}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.BaseItemDto)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.BaseItemDto {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/Artists/{name}/GET/responses/200/content/application\/json; profile="camelcase"`.
                    case application_json_profile__quot_camelcase_quot_(Components.Schemas.BaseItemDto)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_camelcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_camelcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_camelcase_quot_`.
                    public var application_json_profile__quot_camelcase_quot_: Components.Schemas.BaseItemDto {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_camelcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/Artists/{name}/GET/responses/200/content/application\/json; profile="pascalcase"`.
                    case application_json_profile__quot_pascalcase_quot_(Components.Schemas.BaseItemDto)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_pascalcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_pascalcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_pascalcase_quot_`.
                    public var application_json_profile__quot_pascalcase_quot_: Components.Schemas.BaseItemDto {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_pascalcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.GetArtistByName.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.GetArtistByName.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Artist returned.
            ///
            /// - Remark: Generated from `#/paths//Artists/{name}/get(GetArtistByName)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.GetArtistByName.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.GetArtistByName.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct Unauthorized: Sendable, Hashable {
                /// Creates a new `Unauthorized`.
                public init() {}
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//Artists/{name}/get(GetArtistByName)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Operations.GetArtistByName.Output.Unauthorized)
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//Artists/{name}/get(GetArtistByName)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            public static var unauthorized: Self {
                .unauthorized(.init())
            }
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Operations.GetArtistByName.Output.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            public struct Forbidden: Sendable, Hashable {
                /// Creates a new `Forbidden`.
                public init() {}
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//Artists/{name}/get(GetArtistByName)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Operations.GetArtistByName.Output.Forbidden)
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//Artists/{name}/get(GetArtistByName)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            public static var forbidden: Self {
                .forbidden(.init())
            }
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Operations.GetArtistByName.Output.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Gets items based on a query.
    ///
    /// - Remark: HTTP `GET /Items`.
    /// - Remark: Generated from `#/paths//Items/get(GetItems)`.
    public enum GetItems {
        public static let id: Swift.String = "GetItems"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/Items/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The user id supplied as query parameter; this is required when not using an API key.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/userId`.
                public var userId: Swift.String?
                /// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/maxOfficialRating`.
                public var maxOfficialRating: Swift.String?
                /// Optional filter by items with theme songs.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/hasThemeSong`.
                public var hasThemeSong: Swift.Bool?
                /// Optional filter by items with theme videos.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/hasThemeVideo`.
                public var hasThemeVideo: Swift.Bool?
                /// Optional filter by items with subtitles.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/hasSubtitles`.
                public var hasSubtitles: Swift.Bool?
                /// Optional filter by items with special features.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/hasSpecialFeature`.
                public var hasSpecialFeature: Swift.Bool?
                /// Optional filter by items with trailers.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/hasTrailer`.
                public var hasTrailer: Swift.Bool?
                /// Optional. Return items that are siblings of a supplied item.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/adjacentTo`.
                public var adjacentTo: Swift.String?
                /// Optional filter by index number.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/indexNumber`.
                public var indexNumber: Swift.Int32?
                /// Optional filter by parent index number.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/parentIndexNumber`.
                public var parentIndexNumber: Swift.Int32?
                /// Optional filter by items that have or do not have a parental rating.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/hasParentalRating`.
                public var hasParentalRating: Swift.Bool?
                /// Optional filter by items that are HD or not.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/isHd`.
                public var isHd: Swift.Bool?
                /// Optional filter by items that are 4K or not.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/is4K`.
                public var is4K: Swift.Bool?
                /// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/locationTypes`.
                public var locationTypes: [Components.Schemas.LocationType]?
                /// Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/excludeLocationTypes`.
                public var excludeLocationTypes: [Components.Schemas.LocationType]?
                /// Optional filter by items that are missing episodes or not.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/isMissing`.
                public var isMissing: Swift.Bool?
                /// Optional filter by items that are unaired episodes or not.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/isUnaired`.
                public var isUnaired: Swift.Bool?
                /// Optional filter by minimum community rating.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/minCommunityRating`.
                public var minCommunityRating: Swift.Double?
                /// Optional filter by minimum critic rating.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/minCriticRating`.
                public var minCriticRating: Swift.Double?
                /// Optional. The minimum premiere date. Format = ISO.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/minPremiereDate`.
                public var minPremiereDate: Foundation.Date?
                /// Optional. The minimum last saved date. Format = ISO.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/minDateLastSaved`.
                public var minDateLastSaved: Foundation.Date?
                /// Optional. The minimum last saved date for the current user. Format = ISO.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/minDateLastSavedForUser`.
                public var minDateLastSavedForUser: Foundation.Date?
                /// Optional. The maximum premiere date. Format = ISO.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/maxPremiereDate`.
                public var maxPremiereDate: Foundation.Date?
                /// Optional filter by items that have an overview or not.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/hasOverview`.
                public var hasOverview: Swift.Bool?
                /// Optional filter by items that have an IMDb id or not.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/hasImdbId`.
                public var hasImdbId: Swift.Bool?
                /// Optional filter by items that have a TMDb id or not.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/hasTmdbId`.
                public var hasTmdbId: Swift.Bool?
                /// Optional filter by items that have a TVDb id or not.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/hasTvdbId`.
                public var hasTvdbId: Swift.Bool?
                /// Optional filter for live tv movies.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/isMovie`.
                public var isMovie: Swift.Bool?
                /// Optional filter for live tv series.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/isSeries`.
                public var isSeries: Swift.Bool?
                /// Optional filter for live tv news.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/isNews`.
                public var isNews: Swift.Bool?
                /// Optional filter for live tv kids.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/isKids`.
                public var isKids: Swift.Bool?
                /// Optional filter for live tv sports.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/isSports`.
                public var isSports: Swift.Bool?
                /// Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/excludeItemIds`.
                public var excludeItemIds: [Swift.String]?
                /// Optional. The record index to start at. All items with a lower index will be dropped from the results.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/startIndex`.
                public var startIndex: Swift.Int32?
                /// Optional. The maximum number of records to return.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/limit`.
                public var limit: Swift.Int32?
                /// When searching within folders, this determines whether or not the search will be recursive. true/false.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/recursive`.
                public var recursive: Swift.Bool?
                /// Optional. Filter based on a search term.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/searchTerm`.
                public var searchTerm: Swift.String?
                /// Sort Order - Ascending, Descending.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/sortOrder`.
                public var sortOrder: [Components.Schemas.SortOrder]?
                /// Specify this to localize the search to a specific item or folder. Omit to use the root.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/parentId`.
                public var parentId: Swift.String?
                /// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/fields`.
                public var fields: [Components.Schemas.ItemFields]?
                /// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/excludeItemTypes`.
                public var excludeItemTypes: [Components.Schemas.BaseItemKind]?
                /// Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/includeItemTypes`.
                public var includeItemTypes: [Components.Schemas.BaseItemKind]?
                /// Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/filters`.
                public var filters: [Components.Schemas.ItemFilter]?
                /// Optional filter by items that are marked as favorite, or not.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/isFavorite`.
                public var isFavorite: Swift.Bool?
                /// Optional filter by MediaType. Allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/mediaTypes`.
                public var mediaTypes: [Components.Schemas.MediaType]?
                /// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/imageTypes`.
                public var imageTypes: [Components.Schemas.ImageType]?
                /// Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/sortBy`.
                public var sortBy: [Components.Schemas.ItemSortBy]?
                /// Optional filter by items that are played, or not.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/isPlayed`.
                public var isPlayed: Swift.Bool?
                /// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/genres`.
                public var genres: [Swift.String]?
                /// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/officialRatings`.
                public var officialRatings: [Swift.String]?
                /// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/tags`.
                public var tags: [Swift.String]?
                /// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/years`.
                public var years: [Swift.Int32]?
                /// Optional, include user data.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/enableUserData`.
                public var enableUserData: Swift.Bool?
                /// Optional, the max number of images to return, per image type.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/imageTypeLimit`.
                public var imageTypeLimit: Swift.Int32?
                /// Optional. The image types to include in the output.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/enableImageTypes`.
                public var enableImageTypes: [Components.Schemas.ImageType]?
                /// Optional. If specified, results will be filtered to include only those containing the specified person.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/person`.
                public var person: Swift.String?
                /// Optional. If specified, results will be filtered to include only those containing the specified person id.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/personIds`.
                public var personIds: [Swift.String]?
                /// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/personTypes`.
                public var personTypes: [Swift.String]?
                /// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/studios`.
                public var studios: [Swift.String]?
                /// Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/artists`.
                public var artists: [Swift.String]?
                /// Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/excludeArtistIds`.
                public var excludeArtistIds: [Swift.String]?
                /// Optional. If specified, results will be filtered to include only those containing the specified artist id.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/artistIds`.
                public var artistIds: [Swift.String]?
                /// Optional. If specified, results will be filtered to include only those containing the specified album artist id.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/albumArtistIds`.
                public var albumArtistIds: [Swift.String]?
                /// Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/contributingArtistIds`.
                public var contributingArtistIds: [Swift.String]?
                /// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/albums`.
                public var albums: [Swift.String]?
                /// Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/albumIds`.
                public var albumIds: [Swift.String]?
                /// Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/ids`.
                public var ids: [Swift.String]?
                /// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/videoTypes`.
                public var videoTypes: [Components.Schemas.VideoType]?
                /// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/minOfficialRating`.
                public var minOfficialRating: Swift.String?
                /// Optional filter by items that are locked.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/isLocked`.
                public var isLocked: Swift.Bool?
                /// Optional filter by items that are placeholders.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/isPlaceHolder`.
                public var isPlaceHolder: Swift.Bool?
                /// Optional filter by items that have official ratings.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/hasOfficialRating`.
                public var hasOfficialRating: Swift.Bool?
                /// Whether or not to hide items behind their boxsets.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/collapseBoxSetItems`.
                public var collapseBoxSetItems: Swift.Bool?
                /// Optional. Filter by the minimum width of the item.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/minWidth`.
                public var minWidth: Swift.Int32?
                /// Optional. Filter by the minimum height of the item.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/minHeight`.
                public var minHeight: Swift.Int32?
                /// Optional. Filter by the maximum width of the item.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/maxWidth`.
                public var maxWidth: Swift.Int32?
                /// Optional. Filter by the maximum height of the item.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/maxHeight`.
                public var maxHeight: Swift.Int32?
                /// Optional filter by items that are 3D, or not.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/is3D`.
                public var is3D: Swift.Bool?
                /// Optional filter by Series Status. Allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/seriesStatus`.
                public var seriesStatus: [Components.Schemas.SeriesStatus]?
                /// Optional filter by items whose name is sorted equally or greater than a given input string.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/nameStartsWithOrGreater`.
                public var nameStartsWithOrGreater: Swift.String?
                /// Optional filter by items whose name is sorted equally than a given input string.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/nameStartsWith`.
                public var nameStartsWith: Swift.String?
                /// Optional filter by items whose name is equally or lesser than a given input string.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/nameLessThan`.
                public var nameLessThan: Swift.String?
                /// Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/studioIds`.
                public var studioIds: [Swift.String]?
                /// Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/genreIds`.
                public var genreIds: [Swift.String]?
                /// Optional. Enable the total record count.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/enableTotalRecordCount`.
                public var enableTotalRecordCount: Swift.Bool?
                /// Optional, include image information in output.
                ///
                /// - Remark: Generated from `#/paths/Items/GET/query/enableImages`.
                public var enableImages: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - userId: The user id supplied as query parameter; this is required when not using an API key.
                ///   - maxOfficialRating: Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
                ///   - hasThemeSong: Optional filter by items with theme songs.
                ///   - hasThemeVideo: Optional filter by items with theme videos.
                ///   - hasSubtitles: Optional filter by items with subtitles.
                ///   - hasSpecialFeature: Optional filter by items with special features.
                ///   - hasTrailer: Optional filter by items with trailers.
                ///   - adjacentTo: Optional. Return items that are siblings of a supplied item.
                ///   - indexNumber: Optional filter by index number.
                ///   - parentIndexNumber: Optional filter by parent index number.
                ///   - hasParentalRating: Optional filter by items that have or do not have a parental rating.
                ///   - isHd: Optional filter by items that are HD or not.
                ///   - is4K: Optional filter by items that are 4K or not.
                ///   - locationTypes: Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.
                ///   - excludeLocationTypes: Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.
                ///   - isMissing: Optional filter by items that are missing episodes or not.
                ///   - isUnaired: Optional filter by items that are unaired episodes or not.
                ///   - minCommunityRating: Optional filter by minimum community rating.
                ///   - minCriticRating: Optional filter by minimum critic rating.
                ///   - minPremiereDate: Optional. The minimum premiere date. Format = ISO.
                ///   - minDateLastSaved: Optional. The minimum last saved date. Format = ISO.
                ///   - minDateLastSavedForUser: Optional. The minimum last saved date for the current user. Format = ISO.
                ///   - maxPremiereDate: Optional. The maximum premiere date. Format = ISO.
                ///   - hasOverview: Optional filter by items that have an overview or not.
                ///   - hasImdbId: Optional filter by items that have an IMDb id or not.
                ///   - hasTmdbId: Optional filter by items that have a TMDb id or not.
                ///   - hasTvdbId: Optional filter by items that have a TVDb id or not.
                ///   - isMovie: Optional filter for live tv movies.
                ///   - isSeries: Optional filter for live tv series.
                ///   - isNews: Optional filter for live tv news.
                ///   - isKids: Optional filter for live tv kids.
                ///   - isSports: Optional filter for live tv sports.
                ///   - excludeItemIds: Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.
                ///   - startIndex: Optional. The record index to start at. All items with a lower index will be dropped from the results.
                ///   - limit: Optional. The maximum number of records to return.
                ///   - recursive: When searching within folders, this determines whether or not the search will be recursive. true/false.
                ///   - searchTerm: Optional. Filter based on a search term.
                ///   - sortOrder: Sort Order - Ascending, Descending.
                ///   - parentId: Specify this to localize the search to a specific item or folder. Omit to use the root.
                ///   - fields: Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
                ///   - excludeItemTypes: Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
                ///   - includeItemTypes: Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
                ///   - filters: Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
                ///   - isFavorite: Optional filter by items that are marked as favorite, or not.
                ///   - mediaTypes: Optional filter by MediaType. Allows multiple, comma delimited.
                ///   - imageTypes: Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
                ///   - sortBy: Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
                ///   - isPlayed: Optional filter by items that are played, or not.
                ///   - genres: Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
                ///   - officialRatings: Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
                ///   - tags: Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
                ///   - years: Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
                ///   - enableUserData: Optional, include user data.
                ///   - imageTypeLimit: Optional, the max number of images to return, per image type.
                ///   - enableImageTypes: Optional. The image types to include in the output.
                ///   - person: Optional. If specified, results will be filtered to include only those containing the specified person.
                ///   - personIds: Optional. If specified, results will be filtered to include only those containing the specified person id.
                ///   - personTypes: Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
                ///   - studios: Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
                ///   - artists: Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.
                ///   - excludeArtistIds: Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.
                ///   - artistIds: Optional. If specified, results will be filtered to include only those containing the specified artist id.
                ///   - albumArtistIds: Optional. If specified, results will be filtered to include only those containing the specified album artist id.
                ///   - contributingArtistIds: Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
                ///   - albums: Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.
                ///   - albumIds: Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.
                ///   - ids: Optional. If specific items are needed, specify a list of item id's to retrieve. This allows multiple, comma delimited.
                ///   - videoTypes: Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.
                ///   - minOfficialRating: Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
                ///   - isLocked: Optional filter by items that are locked.
                ///   - isPlaceHolder: Optional filter by items that are placeholders.
                ///   - hasOfficialRating: Optional filter by items that have official ratings.
                ///   - collapseBoxSetItems: Whether or not to hide items behind their boxsets.
                ///   - minWidth: Optional. Filter by the minimum width of the item.
                ///   - minHeight: Optional. Filter by the minimum height of the item.
                ///   - maxWidth: Optional. Filter by the maximum width of the item.
                ///   - maxHeight: Optional. Filter by the maximum height of the item.
                ///   - is3D: Optional filter by items that are 3D, or not.
                ///   - seriesStatus: Optional filter by Series Status. Allows multiple, comma delimited.
                ///   - nameStartsWithOrGreater: Optional filter by items whose name is sorted equally or greater than a given input string.
                ///   - nameStartsWith: Optional filter by items whose name is sorted equally than a given input string.
                ///   - nameLessThan: Optional filter by items whose name is equally or lesser than a given input string.
                ///   - studioIds: Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
                ///   - genreIds: Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
                ///   - enableTotalRecordCount: Optional. Enable the total record count.
                ///   - enableImages: Optional, include image information in output.
                public init(
                    userId: Swift.String? = nil,
                    maxOfficialRating: Swift.String? = nil,
                    hasThemeSong: Swift.Bool? = nil,
                    hasThemeVideo: Swift.Bool? = nil,
                    hasSubtitles: Swift.Bool? = nil,
                    hasSpecialFeature: Swift.Bool? = nil,
                    hasTrailer: Swift.Bool? = nil,
                    adjacentTo: Swift.String? = nil,
                    indexNumber: Swift.Int32? = nil,
                    parentIndexNumber: Swift.Int32? = nil,
                    hasParentalRating: Swift.Bool? = nil,
                    isHd: Swift.Bool? = nil,
                    is4K: Swift.Bool? = nil,
                    locationTypes: [Components.Schemas.LocationType]? = nil,
                    excludeLocationTypes: [Components.Schemas.LocationType]? = nil,
                    isMissing: Swift.Bool? = nil,
                    isUnaired: Swift.Bool? = nil,
                    minCommunityRating: Swift.Double? = nil,
                    minCriticRating: Swift.Double? = nil,
                    minPremiereDate: Foundation.Date? = nil,
                    minDateLastSaved: Foundation.Date? = nil,
                    minDateLastSavedForUser: Foundation.Date? = nil,
                    maxPremiereDate: Foundation.Date? = nil,
                    hasOverview: Swift.Bool? = nil,
                    hasImdbId: Swift.Bool? = nil,
                    hasTmdbId: Swift.Bool? = nil,
                    hasTvdbId: Swift.Bool? = nil,
                    isMovie: Swift.Bool? = nil,
                    isSeries: Swift.Bool? = nil,
                    isNews: Swift.Bool? = nil,
                    isKids: Swift.Bool? = nil,
                    isSports: Swift.Bool? = nil,
                    excludeItemIds: [Swift.String]? = nil,
                    startIndex: Swift.Int32? = nil,
                    limit: Swift.Int32? = nil,
                    recursive: Swift.Bool? = nil,
                    searchTerm: Swift.String? = nil,
                    sortOrder: [Components.Schemas.SortOrder]? = nil,
                    parentId: Swift.String? = nil,
                    fields: [Components.Schemas.ItemFields]? = nil,
                    excludeItemTypes: [Components.Schemas.BaseItemKind]? = nil,
                    includeItemTypes: [Components.Schemas.BaseItemKind]? = nil,
                    filters: [Components.Schemas.ItemFilter]? = nil,
                    isFavorite: Swift.Bool? = nil,
                    mediaTypes: [Components.Schemas.MediaType]? = nil,
                    imageTypes: [Components.Schemas.ImageType]? = nil,
                    sortBy: [Components.Schemas.ItemSortBy]? = nil,
                    isPlayed: Swift.Bool? = nil,
                    genres: [Swift.String]? = nil,
                    officialRatings: [Swift.String]? = nil,
                    tags: [Swift.String]? = nil,
                    years: [Swift.Int32]? = nil,
                    enableUserData: Swift.Bool? = nil,
                    imageTypeLimit: Swift.Int32? = nil,
                    enableImageTypes: [Components.Schemas.ImageType]? = nil,
                    person: Swift.String? = nil,
                    personIds: [Swift.String]? = nil,
                    personTypes: [Swift.String]? = nil,
                    studios: [Swift.String]? = nil,
                    artists: [Swift.String]? = nil,
                    excludeArtistIds: [Swift.String]? = nil,
                    artistIds: [Swift.String]? = nil,
                    albumArtistIds: [Swift.String]? = nil,
                    contributingArtistIds: [Swift.String]? = nil,
                    albums: [Swift.String]? = nil,
                    albumIds: [Swift.String]? = nil,
                    ids: [Swift.String]? = nil,
                    videoTypes: [Components.Schemas.VideoType]? = nil,
                    minOfficialRating: Swift.String? = nil,
                    isLocked: Swift.Bool? = nil,
                    isPlaceHolder: Swift.Bool? = nil,
                    hasOfficialRating: Swift.Bool? = nil,
                    collapseBoxSetItems: Swift.Bool? = nil,
                    minWidth: Swift.Int32? = nil,
                    minHeight: Swift.Int32? = nil,
                    maxWidth: Swift.Int32? = nil,
                    maxHeight: Swift.Int32? = nil,
                    is3D: Swift.Bool? = nil,
                    seriesStatus: [Components.Schemas.SeriesStatus]? = nil,
                    nameStartsWithOrGreater: Swift.String? = nil,
                    nameStartsWith: Swift.String? = nil,
                    nameLessThan: Swift.String? = nil,
                    studioIds: [Swift.String]? = nil,
                    genreIds: [Swift.String]? = nil,
                    enableTotalRecordCount: Swift.Bool? = nil,
                    enableImages: Swift.Bool? = nil
                ) {
                    self.userId = userId
                    self.maxOfficialRating = maxOfficialRating
                    self.hasThemeSong = hasThemeSong
                    self.hasThemeVideo = hasThemeVideo
                    self.hasSubtitles = hasSubtitles
                    self.hasSpecialFeature = hasSpecialFeature
                    self.hasTrailer = hasTrailer
                    self.adjacentTo = adjacentTo
                    self.indexNumber = indexNumber
                    self.parentIndexNumber = parentIndexNumber
                    self.hasParentalRating = hasParentalRating
                    self.isHd = isHd
                    self.is4K = is4K
                    self.locationTypes = locationTypes
                    self.excludeLocationTypes = excludeLocationTypes
                    self.isMissing = isMissing
                    self.isUnaired = isUnaired
                    self.minCommunityRating = minCommunityRating
                    self.minCriticRating = minCriticRating
                    self.minPremiereDate = minPremiereDate
                    self.minDateLastSaved = minDateLastSaved
                    self.minDateLastSavedForUser = minDateLastSavedForUser
                    self.maxPremiereDate = maxPremiereDate
                    self.hasOverview = hasOverview
                    self.hasImdbId = hasImdbId
                    self.hasTmdbId = hasTmdbId
                    self.hasTvdbId = hasTvdbId
                    self.isMovie = isMovie
                    self.isSeries = isSeries
                    self.isNews = isNews
                    self.isKids = isKids
                    self.isSports = isSports
                    self.excludeItemIds = excludeItemIds
                    self.startIndex = startIndex
                    self.limit = limit
                    self.recursive = recursive
                    self.searchTerm = searchTerm
                    self.sortOrder = sortOrder
                    self.parentId = parentId
                    self.fields = fields
                    self.excludeItemTypes = excludeItemTypes
                    self.includeItemTypes = includeItemTypes
                    self.filters = filters
                    self.isFavorite = isFavorite
                    self.mediaTypes = mediaTypes
                    self.imageTypes = imageTypes
                    self.sortBy = sortBy
                    self.isPlayed = isPlayed
                    self.genres = genres
                    self.officialRatings = officialRatings
                    self.tags = tags
                    self.years = years
                    self.enableUserData = enableUserData
                    self.imageTypeLimit = imageTypeLimit
                    self.enableImageTypes = enableImageTypes
                    self.person = person
                    self.personIds = personIds
                    self.personTypes = personTypes
                    self.studios = studios
                    self.artists = artists
                    self.excludeArtistIds = excludeArtistIds
                    self.artistIds = artistIds
                    self.albumArtistIds = albumArtistIds
                    self.contributingArtistIds = contributingArtistIds
                    self.albums = albums
                    self.albumIds = albumIds
                    self.ids = ids
                    self.videoTypes = videoTypes
                    self.minOfficialRating = minOfficialRating
                    self.isLocked = isLocked
                    self.isPlaceHolder = isPlaceHolder
                    self.hasOfficialRating = hasOfficialRating
                    self.collapseBoxSetItems = collapseBoxSetItems
                    self.minWidth = minWidth
                    self.minHeight = minHeight
                    self.maxWidth = maxWidth
                    self.maxHeight = maxHeight
                    self.is3D = is3D
                    self.seriesStatus = seriesStatus
                    self.nameStartsWithOrGreater = nameStartsWithOrGreater
                    self.nameStartsWith = nameStartsWith
                    self.nameLessThan = nameLessThan
                    self.studioIds = studioIds
                    self.genreIds = genreIds
                    self.enableTotalRecordCount = enableTotalRecordCount
                    self.enableImages = enableImages
                }
            }
            public var query: Operations.GetItems.Input.Query
            /// - Remark: Generated from `#/paths/Items/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.GetItems.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.GetItems.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.GetItems.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.GetItems.Input.Query = .init(),
                headers: Operations.GetItems.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/Items/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/Items/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.BaseItemDtoQueryResult)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.BaseItemDtoQueryResult {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/Items/GET/responses/200/content/application\/json; profile="camelcase"`.
                    case application_json_profile__quot_camelcase_quot_(Components.Schemas.BaseItemDtoQueryResult)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_camelcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_camelcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_camelcase_quot_`.
                    public var application_json_profile__quot_camelcase_quot_: Components.Schemas.BaseItemDtoQueryResult {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_camelcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/Items/GET/responses/200/content/application\/json; profile="pascalcase"`.
                    case application_json_profile__quot_pascalcase_quot_(Components.Schemas.BaseItemDtoQueryResult)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_pascalcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_pascalcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_pascalcase_quot_`.
                    public var application_json_profile__quot_pascalcase_quot_: Components.Schemas.BaseItemDtoQueryResult {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_pascalcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.GetItems.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.GetItems.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Success
            ///
            /// - Remark: Generated from `#/paths//Items/get(GetItems)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.GetItems.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.GetItems.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct Unauthorized: Sendable, Hashable {
                /// Creates a new `Unauthorized`.
                public init() {}
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//Items/get(GetItems)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Operations.GetItems.Output.Unauthorized)
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//Items/get(GetItems)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            public static var unauthorized: Self {
                .unauthorized(.init())
            }
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Operations.GetItems.Output.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            public struct Forbidden: Sendable, Hashable {
                /// Creates a new `Forbidden`.
                public init() {}
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//Items/get(GetItems)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Operations.GetItems.Output.Forbidden)
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//Items/get(GetItems)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            public static var forbidden: Self {
                .forbidden(.init())
            }
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Operations.GetItems.Output.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get Item User Data.
    ///
    /// - Remark: HTTP `GET /UserItems/{itemId}/UserData`.
    /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/get(GetItemUserData)`.
    public enum GetItemUserData {
        public static let id: Swift.String = "GetItemUserData"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The item id.
                ///
                /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/GET/path/itemId`.
                public var itemId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - itemId: The item id.
                public init(itemId: Swift.String) {
                    self.itemId = itemId
                }
            }
            public var path: Operations.GetItemUserData.Input.Path
            /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The user id.
                ///
                /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/GET/query/userId`.
                public var userId: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - userId: The user id.
                public init(userId: Swift.String? = nil) {
                    self.userId = userId
                }
            }
            public var query: Operations.GetItemUserData.Input.Query
            /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.GetItemUserData.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.GetItemUserData.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.GetItemUserData.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.GetItemUserData.Input.Path,
                query: Operations.GetItemUserData.Input.Query = .init(),
                headers: Operations.GetItemUserData.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.UserItemDataDto)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.UserItemDataDto {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/GET/responses/200/content/application\/json; profile="camelcase"`.
                    case application_json_profile__quot_camelcase_quot_(Components.Schemas.UserItemDataDto)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_camelcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_camelcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_camelcase_quot_`.
                    public var application_json_profile__quot_camelcase_quot_: Components.Schemas.UserItemDataDto {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_camelcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/GET/responses/200/content/application\/json; profile="pascalcase"`.
                    case application_json_profile__quot_pascalcase_quot_(Components.Schemas.UserItemDataDto)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_pascalcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_pascalcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_pascalcase_quot_`.
                    public var application_json_profile__quot_pascalcase_quot_: Components.Schemas.UserItemDataDto {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_pascalcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.GetItemUserData.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.GetItemUserData.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// return item user data.
            ///
            /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/get(GetItemUserData)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.GetItemUserData.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.GetItemUserData.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct NotFound: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/GET/responses/404/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/GET/responses/404/content/application\/json`.
                    case json(Components.Schemas.ProblemDetails)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ProblemDetails {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/GET/responses/404/content/application\/json; profile="camelcase"`.
                    case application_json_profile__quot_camelcase_quot_(Components.Schemas.ProblemDetails)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_camelcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_camelcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_camelcase_quot_`.
                    public var application_json_profile__quot_camelcase_quot_: Components.Schemas.ProblemDetails {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_camelcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/GET/responses/404/content/application\/json; profile="pascalcase"`.
                    case application_json_profile__quot_pascalcase_quot_(Components.Schemas.ProblemDetails)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_pascalcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_pascalcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_pascalcase_quot_`.
                    public var application_json_profile__quot_pascalcase_quot_: Components.Schemas.ProblemDetails {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_pascalcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.GetItemUserData.Output.NotFound.Body
                /// Creates a new `NotFound`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.GetItemUserData.Output.NotFound.Body) {
                    self.body = body
                }
            }
            /// Item is not found.
            ///
            /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/get(GetItemUserData)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Operations.GetItemUserData.Output.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Operations.GetItemUserData.Output.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            public struct Unauthorized: Sendable, Hashable {
                /// Creates a new `Unauthorized`.
                public init() {}
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/get(GetItemUserData)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Operations.GetItemUserData.Output.Unauthorized)
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/get(GetItemUserData)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            public static var unauthorized: Self {
                .unauthorized(.init())
            }
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Operations.GetItemUserData.Output.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            public struct Forbidden: Sendable, Hashable {
                /// Creates a new `Forbidden`.
                public init() {}
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/get(GetItemUserData)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Operations.GetItemUserData.Output.Forbidden)
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/get(GetItemUserData)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            public static var forbidden: Self {
                .forbidden(.init())
            }
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Operations.GetItemUserData.Output.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Update Item User Data.
    ///
    /// - Remark: HTTP `POST /UserItems/{itemId}/UserData`.
    /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/post(UpdateItemUserData)`.
    public enum UpdateItemUserData {
        public static let id: Swift.String = "UpdateItemUserData"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The item id.
                ///
                /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/path/itemId`.
                public var itemId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - itemId: The item id.
                public init(itemId: Swift.String) {
                    self.itemId = itemId
                }
            }
            public var path: Operations.UpdateItemUserData.Input.Path
            /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/query`.
            public struct Query: Sendable, Hashable {
                /// The user id.
                ///
                /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/query/userId`.
                public var userId: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - userId: The user id.
                public init(userId: Swift.String? = nil) {
                    self.userId = userId
                }
            }
            public var query: Operations.UpdateItemUserData.Input.Query
            /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.UpdateItemUserData.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.UpdateItemUserData.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.UpdateItemUserData.Input.Headers
            /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// This is used by the api to get information about a item user data.
                ///
                /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/requestBody/json`.
                public struct jsonPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/requestBody/json/value1`.
                    public var value1: Components.Schemas.UpdateUserItemDataDto
                    /// Creates a new `jsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.UpdateUserItemDataDto) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try .init(from: decoder)
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try value1.encode(to: encoder)
                    }
                }
                /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/requestBody/content/application\/json`.
                case json(Operations.UpdateItemUserData.Input.Body.jsonPayload)
                /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/requestBody/content/text\/json`.
                case text_json(OpenAPIRuntime.HTTPBody)
                /// This is used by the api to get information about a item user data.
                ///
                /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/requestBody/application__ast__plus_json`.
                public struct application__ast__plus_jsonPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/requestBody/application__ast__plus_json/value1`.
                    public var value1: Components.Schemas.UpdateUserItemDataDto
                    /// Creates a new `application__ast__plus_jsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.UpdateUserItemDataDto) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try .init(from: decoder)
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try value1.encode(to: encoder)
                    }
                }
                /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/requestBody/content/application\/*+json`.
                case application__ast__plus_json(Operations.UpdateItemUserData.Input.Body.application__ast__plus_jsonPayload)
            }
            public var body: Operations.UpdateItemUserData.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.UpdateItemUserData.Input.Path,
                query: Operations.UpdateItemUserData.Input.Query = .init(),
                headers: Operations.UpdateItemUserData.Input.Headers = .init(),
                body: Operations.UpdateItemUserData.Input.Body
            ) {
                self.path = path
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.UserItemDataDto)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.UserItemDataDto {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/responses/200/content/application\/json; profile="camelcase"`.
                    case application_json_profile__quot_camelcase_quot_(Components.Schemas.UserItemDataDto)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_camelcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_camelcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_camelcase_quot_`.
                    public var application_json_profile__quot_camelcase_quot_: Components.Schemas.UserItemDataDto {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_camelcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/responses/200/content/application\/json; profile="pascalcase"`.
                    case application_json_profile__quot_pascalcase_quot_(Components.Schemas.UserItemDataDto)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_pascalcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_pascalcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_pascalcase_quot_`.
                    public var application_json_profile__quot_pascalcase_quot_: Components.Schemas.UserItemDataDto {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_pascalcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.UpdateItemUserData.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.UpdateItemUserData.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// return updated user item data.
            ///
            /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/post(UpdateItemUserData)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.UpdateItemUserData.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.UpdateItemUserData.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct NotFound: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/responses/404/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/responses/404/content/application\/json`.
                    case json(Components.Schemas.ProblemDetails)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ProblemDetails {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/responses/404/content/application\/json; profile="camelcase"`.
                    case application_json_profile__quot_camelcase_quot_(Components.Schemas.ProblemDetails)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_camelcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_camelcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_camelcase_quot_`.
                    public var application_json_profile__quot_camelcase_quot_: Components.Schemas.ProblemDetails {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_camelcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/UserItems/{itemId}/UserData/POST/responses/404/content/application\/json; profile="pascalcase"`.
                    case application_json_profile__quot_pascalcase_quot_(Components.Schemas.ProblemDetails)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_pascalcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_pascalcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_pascalcase_quot_`.
                    public var application_json_profile__quot_pascalcase_quot_: Components.Schemas.ProblemDetails {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_pascalcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.UpdateItemUserData.Output.NotFound.Body
                /// Creates a new `NotFound`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.UpdateItemUserData.Output.NotFound.Body) {
                    self.body = body
                }
            }
            /// Item is not found.
            ///
            /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/post(UpdateItemUserData)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Operations.UpdateItemUserData.Output.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Operations.UpdateItemUserData.Output.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            public struct Unauthorized: Sendable, Hashable {
                /// Creates a new `Unauthorized`.
                public init() {}
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/post(UpdateItemUserData)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Operations.UpdateItemUserData.Output.Unauthorized)
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/post(UpdateItemUserData)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            public static var unauthorized: Self {
                .unauthorized(.init())
            }
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Operations.UpdateItemUserData.Output.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            public struct Forbidden: Sendable, Hashable {
                /// Creates a new `Forbidden`.
                public init() {}
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/post(UpdateItemUserData)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Operations.UpdateItemUserData.Output.Forbidden)
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//UserItems/{itemId}/UserData/post(UpdateItemUserData)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            public static var forbidden: Self {
                .forbidden(.init())
            }
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Operations.UpdateItemUserData.Output.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Gets items based on a query.
    ///
    /// - Remark: HTTP `GET /UserItems/Resume`.
    /// - Remark: Generated from `#/paths//UserItems/Resume/get(GetResumeItems)`.
    public enum GetResumeItems {
        public static let id: Swift.String = "GetResumeItems"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/UserItems/Resume/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The user id.
                ///
                /// - Remark: Generated from `#/paths/UserItems/Resume/GET/query/userId`.
                public var userId: Swift.String?
                /// The start index.
                ///
                /// - Remark: Generated from `#/paths/UserItems/Resume/GET/query/startIndex`.
                public var startIndex: Swift.Int32?
                /// The item limit.
                ///
                /// - Remark: Generated from `#/paths/UserItems/Resume/GET/query/limit`.
                public var limit: Swift.Int32?
                /// The search term.
                ///
                /// - Remark: Generated from `#/paths/UserItems/Resume/GET/query/searchTerm`.
                public var searchTerm: Swift.String?
                /// Specify this to localize the search to a specific item or folder. Omit to use the root.
                ///
                /// - Remark: Generated from `#/paths/UserItems/Resume/GET/query/parentId`.
                public var parentId: Swift.String?
                /// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
                ///
                /// - Remark: Generated from `#/paths/UserItems/Resume/GET/query/fields`.
                public var fields: [Components.Schemas.ItemFields]?
                /// Optional. Filter by MediaType. Allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/UserItems/Resume/GET/query/mediaTypes`.
                public var mediaTypes: [Components.Schemas.MediaType]?
                /// Optional. Include user data.
                ///
                /// - Remark: Generated from `#/paths/UserItems/Resume/GET/query/enableUserData`.
                public var enableUserData: Swift.Bool?
                /// Optional. The max number of images to return, per image type.
                ///
                /// - Remark: Generated from `#/paths/UserItems/Resume/GET/query/imageTypeLimit`.
                public var imageTypeLimit: Swift.Int32?
                /// Optional. The image types to include in the output.
                ///
                /// - Remark: Generated from `#/paths/UserItems/Resume/GET/query/enableImageTypes`.
                public var enableImageTypes: [Components.Schemas.ImageType]?
                /// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/UserItems/Resume/GET/query/excludeItemTypes`.
                public var excludeItemTypes: [Components.Schemas.BaseItemKind]?
                /// Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
                ///
                /// - Remark: Generated from `#/paths/UserItems/Resume/GET/query/includeItemTypes`.
                public var includeItemTypes: [Components.Schemas.BaseItemKind]?
                /// Optional. Enable the total record count.
                ///
                /// - Remark: Generated from `#/paths/UserItems/Resume/GET/query/enableTotalRecordCount`.
                public var enableTotalRecordCount: Swift.Bool?
                /// Optional. Include image information in output.
                ///
                /// - Remark: Generated from `#/paths/UserItems/Resume/GET/query/enableImages`.
                public var enableImages: Swift.Bool?
                /// Optional. Whether to exclude the currently active sessions.
                ///
                /// - Remark: Generated from `#/paths/UserItems/Resume/GET/query/excludeActiveSessions`.
                public var excludeActiveSessions: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - userId: The user id.
                ///   - startIndex: The start index.
                ///   - limit: The item limit.
                ///   - searchTerm: The search term.
                ///   - parentId: Specify this to localize the search to a specific item or folder. Omit to use the root.
                ///   - fields: Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
                ///   - mediaTypes: Optional. Filter by MediaType. Allows multiple, comma delimited.
                ///   - enableUserData: Optional. Include user data.
                ///   - imageTypeLimit: Optional. The max number of images to return, per image type.
                ///   - enableImageTypes: Optional. The image types to include in the output.
                ///   - excludeItemTypes: Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
                ///   - includeItemTypes: Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
                ///   - enableTotalRecordCount: Optional. Enable the total record count.
                ///   - enableImages: Optional. Include image information in output.
                ///   - excludeActiveSessions: Optional. Whether to exclude the currently active sessions.
                public init(
                    userId: Swift.String? = nil,
                    startIndex: Swift.Int32? = nil,
                    limit: Swift.Int32? = nil,
                    searchTerm: Swift.String? = nil,
                    parentId: Swift.String? = nil,
                    fields: [Components.Schemas.ItemFields]? = nil,
                    mediaTypes: [Components.Schemas.MediaType]? = nil,
                    enableUserData: Swift.Bool? = nil,
                    imageTypeLimit: Swift.Int32? = nil,
                    enableImageTypes: [Components.Schemas.ImageType]? = nil,
                    excludeItemTypes: [Components.Schemas.BaseItemKind]? = nil,
                    includeItemTypes: [Components.Schemas.BaseItemKind]? = nil,
                    enableTotalRecordCount: Swift.Bool? = nil,
                    enableImages: Swift.Bool? = nil,
                    excludeActiveSessions: Swift.Bool? = nil
                ) {
                    self.userId = userId
                    self.startIndex = startIndex
                    self.limit = limit
                    self.searchTerm = searchTerm
                    self.parentId = parentId
                    self.fields = fields
                    self.mediaTypes = mediaTypes
                    self.enableUserData = enableUserData
                    self.imageTypeLimit = imageTypeLimit
                    self.enableImageTypes = enableImageTypes
                    self.excludeItemTypes = excludeItemTypes
                    self.includeItemTypes = includeItemTypes
                    self.enableTotalRecordCount = enableTotalRecordCount
                    self.enableImages = enableImages
                    self.excludeActiveSessions = excludeActiveSessions
                }
            }
            public var query: Operations.GetResumeItems.Input.Query
            /// - Remark: Generated from `#/paths/UserItems/Resume/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.GetResumeItems.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.GetResumeItems.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.GetResumeItems.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.GetResumeItems.Input.Query = .init(),
                headers: Operations.GetResumeItems.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/UserItems/Resume/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/UserItems/Resume/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.BaseItemDtoQueryResult)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.BaseItemDtoQueryResult {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/UserItems/Resume/GET/responses/200/content/application\/json; profile="camelcase"`.
                    case application_json_profile__quot_camelcase_quot_(Components.Schemas.BaseItemDtoQueryResult)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_camelcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_camelcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_camelcase_quot_`.
                    public var application_json_profile__quot_camelcase_quot_: Components.Schemas.BaseItemDtoQueryResult {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_camelcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/UserItems/Resume/GET/responses/200/content/application\/json; profile="pascalcase"`.
                    case application_json_profile__quot_pascalcase_quot_(Components.Schemas.BaseItemDtoQueryResult)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_pascalcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_pascalcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_pascalcase_quot_`.
                    public var application_json_profile__quot_pascalcase_quot_: Components.Schemas.BaseItemDtoQueryResult {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_pascalcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.GetResumeItems.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.GetResumeItems.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Items returned.
            ///
            /// - Remark: Generated from `#/paths//UserItems/Resume/get(GetResumeItems)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.GetResumeItems.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.GetResumeItems.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct Unauthorized: Sendable, Hashable {
                /// Creates a new `Unauthorized`.
                public init() {}
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//UserItems/Resume/get(GetResumeItems)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Operations.GetResumeItems.Output.Unauthorized)
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//UserItems/Resume/get(GetResumeItems)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            public static var unauthorized: Self {
                .unauthorized(.init())
            }
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Operations.GetResumeItems.Output.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            public struct Forbidden: Sendable, Hashable {
                /// Creates a new `Forbidden`.
                public init() {}
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//UserItems/Resume/get(GetResumeItems)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Operations.GetResumeItems.Output.Forbidden)
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//UserItems/Resume/get(GetResumeItems)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            public static var forbidden: Self {
                .forbidden(.init())
            }
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Operations.GetResumeItems.Output.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Gets all user media folders.
    ///
    /// - Remark: HTTP `GET /Library/MediaFolders`.
    /// - Remark: Generated from `#/paths//Library/MediaFolders/get(GetMediaFolders)`.
    public enum GetMediaFolders {
        public static let id: Swift.String = "GetMediaFolders"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/Library/MediaFolders/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Optional. Filter by folders that are marked hidden, or not.
                ///
                /// - Remark: Generated from `#/paths/Library/MediaFolders/GET/query/isHidden`.
                public var isHidden: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - isHidden: Optional. Filter by folders that are marked hidden, or not.
                public init(isHidden: Swift.Bool? = nil) {
                    self.isHidden = isHidden
                }
            }
            public var query: Operations.GetMediaFolders.Input.Query
            /// - Remark: Generated from `#/paths/Library/MediaFolders/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.GetMediaFolders.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.GetMediaFolders.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.GetMediaFolders.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.GetMediaFolders.Input.Query = .init(),
                headers: Operations.GetMediaFolders.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/Library/MediaFolders/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/Library/MediaFolders/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.BaseItemDtoQueryResult)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.BaseItemDtoQueryResult {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/Library/MediaFolders/GET/responses/200/content/application\/json; profile="camelcase"`.
                    case application_json_profile__quot_camelcase_quot_(Components.Schemas.BaseItemDtoQueryResult)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_camelcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_camelcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_camelcase_quot_`.
                    public var application_json_profile__quot_camelcase_quot_: Components.Schemas.BaseItemDtoQueryResult {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_camelcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/Library/MediaFolders/GET/responses/200/content/application\/json; profile="pascalcase"`.
                    case application_json_profile__quot_pascalcase_quot_(Components.Schemas.BaseItemDtoQueryResult)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_pascalcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_pascalcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_pascalcase_quot_`.
                    public var application_json_profile__quot_pascalcase_quot_: Components.Schemas.BaseItemDtoQueryResult {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_pascalcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.GetMediaFolders.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.GetMediaFolders.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Media folders returned.
            ///
            /// - Remark: Generated from `#/paths//Library/MediaFolders/get(GetMediaFolders)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.GetMediaFolders.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.GetMediaFolders.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct Unauthorized: Sendable, Hashable {
                /// Creates a new `Unauthorized`.
                public init() {}
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//Library/MediaFolders/get(GetMediaFolders)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Operations.GetMediaFolders.Output.Unauthorized)
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//Library/MediaFolders/get(GetMediaFolders)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            public static var unauthorized: Self {
                .unauthorized(.init())
            }
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Operations.GetMediaFolders.Output.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            public struct Forbidden: Sendable, Hashable {
                /// Creates a new `Forbidden`.
                public init() {}
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//Library/MediaFolders/get(GetMediaFolders)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Operations.GetMediaFolders.Output.Forbidden)
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//Library/MediaFolders/get(GetMediaFolders)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            public static var forbidden: Self {
                .forbidden(.init())
            }
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Operations.GetMediaFolders.Output.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Gets public information about the server.
    ///
    /// - Remark: HTTP `GET /System/Info/Public`.
    /// - Remark: Generated from `#/paths//System/Info/Public/get(GetPublicSystemInfo)`.
    public enum GetPublicSystemInfo {
        public static let id: Swift.String = "GetPublicSystemInfo"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/System/Info/Public/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.GetPublicSystemInfo.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.GetPublicSystemInfo.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.GetPublicSystemInfo.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            public init(headers: Operations.GetPublicSystemInfo.Input.Headers = .init()) {
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/System/Info/Public/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/System/Info/Public/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.PublicSystemInfo)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.PublicSystemInfo {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/System/Info/Public/GET/responses/200/content/application\/json; profile="camelcase"`.
                    case application_json_profile__quot_camelcase_quot_(Components.Schemas.PublicSystemInfo)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_camelcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_camelcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_camelcase_quot_`.
                    public var application_json_profile__quot_camelcase_quot_: Components.Schemas.PublicSystemInfo {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_camelcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/System/Info/Public/GET/responses/200/content/application\/json; profile="pascalcase"`.
                    case application_json_profile__quot_pascalcase_quot_(Components.Schemas.PublicSystemInfo)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_pascalcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_pascalcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_pascalcase_quot_`.
                    public var application_json_profile__quot_pascalcase_quot_: Components.Schemas.PublicSystemInfo {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_pascalcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.GetPublicSystemInfo.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.GetPublicSystemInfo.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Information retrieved.
            ///
            /// - Remark: Generated from `#/paths//System/Info/Public/get(GetPublicSystemInfo)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.GetPublicSystemInfo.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.GetPublicSystemInfo.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Authenticates a user by name.
    ///
    /// - Remark: HTTP `POST /Users/AuthenticateByName`.
    /// - Remark: Generated from `#/paths//Users/AuthenticateByName/post(AuthenticateUserByName)`.
    public enum AuthenticateUserByName {
        public static let id: Swift.String = "AuthenticateUserByName"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/Users/AuthenticateByName/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.AuthenticateUserByName.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.AuthenticateUserByName.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.AuthenticateUserByName.Input.Headers
            /// - Remark: Generated from `#/paths/Users/AuthenticateByName/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// The authenticate user by name request body.
                ///
                /// - Remark: Generated from `#/paths/Users/AuthenticateByName/POST/requestBody/json`.
                public struct jsonPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/paths/Users/AuthenticateByName/POST/requestBody/json/value1`.
                    public var value1: Components.Schemas.AuthenticateUserByName
                    /// Creates a new `jsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.AuthenticateUserByName) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try .init(from: decoder)
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try value1.encode(to: encoder)
                    }
                }
                /// - Remark: Generated from `#/paths/Users/AuthenticateByName/POST/requestBody/content/application\/json`.
                case json(Operations.AuthenticateUserByName.Input.Body.jsonPayload)
                /// - Remark: Generated from `#/paths/Users/AuthenticateByName/POST/requestBody/content/text\/json`.
                case text_json(OpenAPIRuntime.HTTPBody)
                /// The authenticate user by name request body.
                ///
                /// - Remark: Generated from `#/paths/Users/AuthenticateByName/POST/requestBody/application__ast__plus_json`.
                public struct application__ast__plus_jsonPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/paths/Users/AuthenticateByName/POST/requestBody/application__ast__plus_json/value1`.
                    public var value1: Components.Schemas.AuthenticateUserByName
                    /// Creates a new `application__ast__plus_jsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    public init(value1: Components.Schemas.AuthenticateUserByName) {
                        self.value1 = value1
                    }
                    public init(from decoder: any Decoder) throws {
                        value1 = try .init(from: decoder)
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try value1.encode(to: encoder)
                    }
                }
                /// - Remark: Generated from `#/paths/Users/AuthenticateByName/POST/requestBody/content/application\/*+json`.
                case application__ast__plus_json(Operations.AuthenticateUserByName.Input.Body.application__ast__plus_jsonPayload)
            }
            public var body: Operations.AuthenticateUserByName.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.AuthenticateUserByName.Input.Headers = .init(),
                body: Operations.AuthenticateUserByName.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/Users/AuthenticateByName/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/Users/AuthenticateByName/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.AuthenticationResult)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.AuthenticationResult {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/Users/AuthenticateByName/POST/responses/200/content/application\/json; profile="camelcase"`.
                    case application_json_profile__quot_camelcase_quot_(Components.Schemas.AuthenticationResult)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_camelcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_camelcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_camelcase_quot_`.
                    public var application_json_profile__quot_camelcase_quot_: Components.Schemas.AuthenticationResult {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_camelcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/Users/AuthenticateByName/POST/responses/200/content/application\/json; profile="pascalcase"`.
                    case application_json_profile__quot_pascalcase_quot_(Components.Schemas.AuthenticationResult)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_pascalcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_pascalcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_pascalcase_quot_`.
                    public var application_json_profile__quot_pascalcase_quot_: Components.Schemas.AuthenticationResult {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_pascalcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.AuthenticateUserByName.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.AuthenticateUserByName.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// User authenticated.
            ///
            /// - Remark: Generated from `#/paths//Users/AuthenticateByName/post(AuthenticateUserByName)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.AuthenticateUserByName.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.AuthenticateUserByName.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Marks an item as a favorite.
    ///
    /// - Remark: HTTP `POST /UserFavoriteItems/{itemId}`.
    /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/post(MarkFavoriteItem)`.
    public enum MarkFavoriteItem {
        public static let id: Swift.String = "MarkFavoriteItem"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/POST/path`.
            public struct Path: Sendable, Hashable {
                /// Item id.
                ///
                /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/POST/path/itemId`.
                public var itemId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - itemId: Item id.
                public init(itemId: Swift.String) {
                    self.itemId = itemId
                }
            }
            public var path: Operations.MarkFavoriteItem.Input.Path
            /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/POST/query`.
            public struct Query: Sendable, Hashable {
                /// User id.
                ///
                /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/POST/query/userId`.
                public var userId: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - userId: User id.
                public init(userId: Swift.String? = nil) {
                    self.userId = userId
                }
            }
            public var query: Operations.MarkFavoriteItem.Input.Query
            /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.MarkFavoriteItem.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.MarkFavoriteItem.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.MarkFavoriteItem.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.MarkFavoriteItem.Input.Path,
                query: Operations.MarkFavoriteItem.Input.Query = .init(),
                headers: Operations.MarkFavoriteItem.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.UserItemDataDto)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.UserItemDataDto {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/POST/responses/200/content/application\/json; profile="camelcase"`.
                    case application_json_profile__quot_camelcase_quot_(Components.Schemas.UserItemDataDto)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_camelcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_camelcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_camelcase_quot_`.
                    public var application_json_profile__quot_camelcase_quot_: Components.Schemas.UserItemDataDto {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_camelcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/POST/responses/200/content/application\/json; profile="pascalcase"`.
                    case application_json_profile__quot_pascalcase_quot_(Components.Schemas.UserItemDataDto)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_pascalcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_pascalcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_pascalcase_quot_`.
                    public var application_json_profile__quot_pascalcase_quot_: Components.Schemas.UserItemDataDto {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_pascalcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.MarkFavoriteItem.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.MarkFavoriteItem.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Item marked as favorite.
            ///
            /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/post(MarkFavoriteItem)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.MarkFavoriteItem.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.MarkFavoriteItem.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct Unauthorized: Sendable, Hashable {
                /// Creates a new `Unauthorized`.
                public init() {}
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/post(MarkFavoriteItem)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Operations.MarkFavoriteItem.Output.Unauthorized)
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/post(MarkFavoriteItem)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            public static var unauthorized: Self {
                .unauthorized(.init())
            }
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Operations.MarkFavoriteItem.Output.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            public struct Forbidden: Sendable, Hashable {
                /// Creates a new `Forbidden`.
                public init() {}
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/post(MarkFavoriteItem)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Operations.MarkFavoriteItem.Output.Forbidden)
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/post(MarkFavoriteItem)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            public static var forbidden: Self {
                .forbidden(.init())
            }
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Operations.MarkFavoriteItem.Output.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Unmarks item as a favorite.
    ///
    /// - Remark: HTTP `DELETE /UserFavoriteItems/{itemId}`.
    /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/delete(UnmarkFavoriteItem)`.
    public enum UnmarkFavoriteItem {
        public static let id: Swift.String = "UnmarkFavoriteItem"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// Item id.
                ///
                /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/DELETE/path/itemId`.
                public var itemId: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - itemId: Item id.
                public init(itemId: Swift.String) {
                    self.itemId = itemId
                }
            }
            public var path: Operations.UnmarkFavoriteItem.Input.Path
            /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/DELETE/query`.
            public struct Query: Sendable, Hashable {
                /// User id.
                ///
                /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/DELETE/query/userId`.
                public var userId: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - userId: User id.
                public init(userId: Swift.String? = nil) {
                    self.userId = userId
                }
            }
            public var query: Operations.UnmarkFavoriteItem.Input.Query
            /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.UnmarkFavoriteItem.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.UnmarkFavoriteItem.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.UnmarkFavoriteItem.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.UnmarkFavoriteItem.Input.Path,
                query: Operations.UnmarkFavoriteItem.Input.Query = .init(),
                headers: Operations.UnmarkFavoriteItem.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/DELETE/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/DELETE/responses/200/content/application\/json`.
                    case json(Components.Schemas.UserItemDataDto)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.UserItemDataDto {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/DELETE/responses/200/content/application\/json; profile="camelcase"`.
                    case application_json_profile__quot_camelcase_quot_(Components.Schemas.UserItemDataDto)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_camelcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_camelcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_camelcase_quot_`.
                    public var application_json_profile__quot_camelcase_quot_: Components.Schemas.UserItemDataDto {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_camelcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/UserFavoriteItems/{itemId}/DELETE/responses/200/content/application\/json; profile="pascalcase"`.
                    case application_json_profile__quot_pascalcase_quot_(Components.Schemas.UserItemDataDto)
                    /// The associated value of the enum case if `self` is `.application_json_profile__quot_pascalcase_quot_`.
                    ///
                    /// - Throws: An error if `self` is not `.application_json_profile__quot_pascalcase_quot_`.
                    /// - SeeAlso: `.application_json_profile__quot_pascalcase_quot_`.
                    public var application_json_profile__quot_pascalcase_quot_: Components.Schemas.UserItemDataDto {
                        get throws {
                            switch self {
                            case let .application_json_profile__quot_pascalcase_quot_(body):
                                return body
                            default:
                                try throwUnexpectedResponseBody(
                                    expectedContent: "application/json",
                                    body: self
                                )
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.UnmarkFavoriteItem.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.UnmarkFavoriteItem.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Item unmarked as favorite.
            ///
            /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/delete(UnmarkFavoriteItem)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.UnmarkFavoriteItem.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.UnmarkFavoriteItem.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct Unauthorized: Sendable, Hashable {
                /// Creates a new `Unauthorized`.
                public init() {}
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/delete(UnmarkFavoriteItem)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Operations.UnmarkFavoriteItem.Output.Unauthorized)
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/delete(UnmarkFavoriteItem)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            public static var unauthorized: Self {
                .unauthorized(.init())
            }
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Operations.UnmarkFavoriteItem.Output.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            public struct Forbidden: Sendable, Hashable {
                /// Creates a new `Forbidden`.
                public init() {}
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/delete(UnmarkFavoriteItem)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Operations.UnmarkFavoriteItem.Output.Forbidden)
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//UserFavoriteItems/{itemId}/delete(UnmarkFavoriteItem)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            public static var forbidden: Self {
                .forbidden(.init())
            }
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Operations.UnmarkFavoriteItem.Output.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
}
